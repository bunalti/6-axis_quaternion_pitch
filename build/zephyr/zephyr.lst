
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_start>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   0:	20001d20 	.word	0x20001d20
}
   4:	0000315d 	.word	0x0000315d
   8:	00007c41 	.word	0x00007c41
   c:	00003115 	.word	0x00003115
  10:	00003115 	.word	0x00003115
  14:	00003115 	.word	0x00003115
  18:	00003115 	.word	0x00003115
	...
  2c:	00002859 	.word	0x00002859
  30:	00003115 	.word	0x00003115
  34:	00000000 	.word	0x00000000
  38:	00002801 	.word	0x00002801
  3c:	00003115 	.word	0x00003115

00000040 <_irq_vector_table>:
  40:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  50:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  60:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  70:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  80:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  90:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  a0:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  b0:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  c0:	00002945 00002945 00002945 00002945     E)..E)..E)..E)..
  d0:	00002945 00002945 00002945              E)..E)..E)..

Disassembly of section text:

000000dc <__aeabi_fmul>:
      dc:	f04f 0cff 	mov.w	ip, #255	; 0xff
      e0:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
      e4:	bf1e      	ittt	ne
      e6:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
      ea:	ea92 0f0c 	teqne	r2, ip
      ee:	ea93 0f0c 	teqne	r3, ip
      f2:	d06f      	beq.n	1d4 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x8a>
      f4:	441a      	add	r2, r3
      f6:	ea80 0c01 	eor.w	ip, r0, r1
      fa:	0240      	lsls	r0, r0, #9
      fc:	bf18      	it	ne
      fe:	ea5f 2141 	movsne.w	r1, r1, lsl #9
     102:	d01e      	beq.n	142 <CONFIG_IDLE_STACK_SIZE+0x2>
     104:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
     108:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
     10c:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
     110:	fba0 3101 	umull	r3, r1, r0, r1
     114:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
     118:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
     11c:	bf3e      	ittt	cc
     11e:	0049      	lslcc	r1, r1, #1
     120:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
     124:	005b      	lslcc	r3, r3, #1
     126:	ea40 0001 	orr.w	r0, r0, r1
     12a:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
     12e:	2afd      	cmp	r2, #253	; 0xfd
     130:	d81d      	bhi.n	16e <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x24>
     132:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     136:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
     13a:	bf08      	it	eq
     13c:	f020 0001 	biceq.w	r0, r0, #1
     140:	4770      	bx	lr
     142:	f090 0f00 	teq	r0, #0
     146:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
     14a:	bf08      	it	eq
     14c:	0249      	lsleq	r1, r1, #9
     14e:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
     152:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
     156:	3a7f      	subs	r2, #127	; 0x7f
     158:	bfc2      	ittt	gt
     15a:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
     15e:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
     162:	4770      	bxgt	lr
     164:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     168:	f04f 0300 	mov.w	r3, #0
     16c:	3a01      	subs	r2, #1
     16e:	dc5d      	bgt.n	22c <CONFIG_FLASH_SIZE+0x2c>
     170:	f112 0f19 	cmn.w	r2, #25
     174:	bfdc      	itt	le
     176:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
     17a:	4770      	bxle	lr
     17c:	f1c2 0200 	rsb	r2, r2, #0
     180:	0041      	lsls	r1, r0, #1
     182:	fa21 f102 	lsr.w	r1, r1, r2
     186:	f1c2 0220 	rsb	r2, r2, #32
     18a:	fa00 fc02 	lsl.w	ip, r0, r2
     18e:	ea5f 0031 	movs.w	r0, r1, rrx
     192:	f140 0000 	adc.w	r0, r0, #0
     196:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
     19a:	bf08      	it	eq
     19c:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
     1a0:	4770      	bx	lr
     1a2:	f092 0f00 	teq	r2, #0
     1a6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
     1aa:	bf02      	ittt	eq
     1ac:	0040      	lsleq	r0, r0, #1
     1ae:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
     1b2:	3a01      	subeq	r2, #1
     1b4:	d0f9      	beq.n	1aa <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x60>
     1b6:	ea40 000c 	orr.w	r0, r0, ip
     1ba:	f093 0f00 	teq	r3, #0
     1be:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
     1c2:	bf02      	ittt	eq
     1c4:	0049      	lsleq	r1, r1, #1
     1c6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
     1ca:	3b01      	subeq	r3, #1
     1cc:	d0f9      	beq.n	1c2 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x78>
     1ce:	ea41 010c 	orr.w	r1, r1, ip
     1d2:	e78f      	b.n	f4 <__data_size>
     1d4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
     1d8:	ea92 0f0c 	teq	r2, ip
     1dc:	bf18      	it	ne
     1de:	ea93 0f0c 	teqne	r3, ip
     1e2:	d00a      	beq.n	1fa <CONFIG_NRF52_ANOMALY_132_DELAY_US+0xb0>
     1e4:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
     1e8:	bf18      	it	ne
     1ea:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
     1ee:	d1d8      	bne.n	1a2 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x58>
     1f0:	ea80 0001 	eor.w	r0, r0, r1
     1f4:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
     1f8:	4770      	bx	lr
     1fa:	f090 0f00 	teq	r0, #0
     1fe:	bf17      	itett	ne
     200:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
     204:	4608      	moveq	r0, r1
     206:	f091 0f00 	teqne	r1, #0
     20a:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
     20e:	d014      	beq.n	23a <CONFIG_FLASH_SIZE+0x3a>
     210:	ea92 0f0c 	teq	r2, ip
     214:	d101      	bne.n	21a <CONFIG_FLASH_SIZE+0x1a>
     216:	0242      	lsls	r2, r0, #9
     218:	d10f      	bne.n	23a <CONFIG_FLASH_SIZE+0x3a>
     21a:	ea93 0f0c 	teq	r3, ip
     21e:	d103      	bne.n	228 <CONFIG_FLASH_SIZE+0x28>
     220:	024b      	lsls	r3, r1, #9
     222:	bf18      	it	ne
     224:	4608      	movne	r0, r1
     226:	d108      	bne.n	23a <CONFIG_FLASH_SIZE+0x3a>
     228:	ea80 0001 	eor.w	r0, r0, r1
     22c:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
     230:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     234:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     238:	4770      	bx	lr
     23a:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
     23e:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
     242:	4770      	bx	lr

00000244 <__aeabi_frsub>:
     244:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
     248:	e002      	b.n	250 <__addsf3>
     24a:	bf00      	nop

0000024c <__aeabi_fsub>:
     24c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00000250 <__addsf3>:
     250:	0042      	lsls	r2, r0, #1
     252:	bf1f      	itttt	ne
     254:	ea5f 0341 	movsne.w	r3, r1, lsl #1
     258:	ea92 0f03 	teqne	r2, r3
     25c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
     260:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     264:	d06a      	beq.n	33c <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x3c>
     266:	ea4f 6212 	mov.w	r2, r2, lsr #24
     26a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
     26e:	bfc1      	itttt	gt
     270:	18d2      	addgt	r2, r2, r3
     272:	4041      	eorgt	r1, r0
     274:	4048      	eorgt	r0, r1
     276:	4041      	eorgt	r1, r0
     278:	bfb8      	it	lt
     27a:	425b      	neglt	r3, r3
     27c:	2b19      	cmp	r3, #25
     27e:	bf88      	it	hi
     280:	4770      	bxhi	lr
     282:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
     286:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     28a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
     28e:	bf18      	it	ne
     290:	4240      	negne	r0, r0
     292:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
     296:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
     29a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
     29e:	bf18      	it	ne
     2a0:	4249      	negne	r1, r1
     2a2:	ea92 0f03 	teq	r2, r3
     2a6:	d03f      	beq.n	328 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x28>
     2a8:	f1a2 0201 	sub.w	r2, r2, #1
     2ac:	fa41 fc03 	asr.w	ip, r1, r3
     2b0:	eb10 000c 	adds.w	r0, r0, ip
     2b4:	f1c3 0320 	rsb	r3, r3, #32
     2b8:	fa01 f103 	lsl.w	r1, r1, r3
     2bc:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     2c0:	d502      	bpl.n	2c8 <__addsf3+0x78>
     2c2:	4249      	negs	r1, r1
     2c4:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
     2c8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
     2cc:	d313      	bcc.n	2f6 <__addsf3+0xa6>
     2ce:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
     2d2:	d306      	bcc.n	2e2 <__addsf3+0x92>
     2d4:	0840      	lsrs	r0, r0, #1
     2d6:	ea4f 0131 	mov.w	r1, r1, rrx
     2da:	f102 0201 	add.w	r2, r2, #1
     2de:	2afe      	cmp	r2, #254	; 0xfe
     2e0:	d251      	bcs.n	386 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x86>
     2e2:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
     2e6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
     2ea:	bf08      	it	eq
     2ec:	f020 0001 	biceq.w	r0, r0, #1
     2f0:	ea40 0003 	orr.w	r0, r0, r3
     2f4:	4770      	bx	lr
     2f6:	0049      	lsls	r1, r1, #1
     2f8:	eb40 0000 	adc.w	r0, r0, r0
     2fc:	3a01      	subs	r2, #1
     2fe:	bf28      	it	cs
     300:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
     304:	d2ed      	bcs.n	2e2 <__addsf3+0x92>
     306:	fab0 fc80 	clz	ip, r0
     30a:	f1ac 0c08 	sub.w	ip, ip, #8
     30e:	ebb2 020c 	subs.w	r2, r2, ip
     312:	fa00 f00c 	lsl.w	r0, r0, ip
     316:	bfaa      	itet	ge
     318:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
     31c:	4252      	neglt	r2, r2
     31e:	4318      	orrge	r0, r3
     320:	bfbc      	itt	lt
     322:	40d0      	lsrlt	r0, r2
     324:	4318      	orrlt	r0, r3
     326:	4770      	bx	lr
     328:	f092 0f00 	teq	r2, #0
     32c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
     330:	bf06      	itte	eq
     332:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
     336:	3201      	addeq	r2, #1
     338:	3b01      	subne	r3, #1
     33a:	e7b5      	b.n	2a8 <__addsf3+0x58>
     33c:	ea4f 0341 	mov.w	r3, r1, lsl #1
     340:	ea7f 6c22 	mvns.w	ip, r2, asr #24
     344:	bf18      	it	ne
     346:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
     34a:	d021      	beq.n	390 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x90>
     34c:	ea92 0f03 	teq	r2, r3
     350:	d004      	beq.n	35c <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x5c>
     352:	f092 0f00 	teq	r2, #0
     356:	bf08      	it	eq
     358:	4608      	moveq	r0, r1
     35a:	4770      	bx	lr
     35c:	ea90 0f01 	teq	r0, r1
     360:	bf1c      	itt	ne
     362:	2000      	movne	r0, #0
     364:	4770      	bxne	lr
     366:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
     36a:	d104      	bne.n	376 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x76>
     36c:	0040      	lsls	r0, r0, #1
     36e:	bf28      	it	cs
     370:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
     374:	4770      	bx	lr
     376:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
     37a:	bf3c      	itt	cc
     37c:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
     380:	4770      	bxcc	lr
     382:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
     386:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
     38a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
     38e:	4770      	bx	lr
     390:	ea7f 6222 	mvns.w	r2, r2, asr #24
     394:	bf16      	itet	ne
     396:	4608      	movne	r0, r1
     398:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
     39c:	4601      	movne	r1, r0
     39e:	0242      	lsls	r2, r0, #9
     3a0:	bf06      	itte	eq
     3a2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
     3a6:	ea90 0f01 	teqeq	r0, r1
     3aa:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
     3ae:	4770      	bx	lr

000003b0 <__aeabi_ui2f>:
     3b0:	f04f 0300 	mov.w	r3, #0
     3b4:	e004      	b.n	3c0 <__aeabi_i2f+0x8>
     3b6:	bf00      	nop

000003b8 <__aeabi_i2f>:
     3b8:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
     3bc:	bf48      	it	mi
     3be:	4240      	negmi	r0, r0
     3c0:	ea5f 0c00 	movs.w	ip, r0
     3c4:	bf08      	it	eq
     3c6:	4770      	bxeq	lr
     3c8:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
     3cc:	4601      	mov	r1, r0
     3ce:	f04f 0000 	mov.w	r0, #0
     3d2:	e01c      	b.n	40e <CONFIG_LOG_BUFFER_SIZE+0xe>

000003d4 <__aeabi_ul2f>:
     3d4:	ea50 0201 	orrs.w	r2, r0, r1
     3d8:	bf08      	it	eq
     3da:	4770      	bxeq	lr
     3dc:	f04f 0300 	mov.w	r3, #0
     3e0:	e00a      	b.n	3f8 <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0x10>
     3e2:	bf00      	nop

000003e4 <__aeabi_l2f>:
     3e4:	ea50 0201 	orrs.w	r2, r0, r1
     3e8:	bf08      	it	eq
     3ea:	4770      	bxeq	lr
     3ec:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
     3f0:	d502      	bpl.n	3f8 <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0x10>
     3f2:	4240      	negs	r0, r0
     3f4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
     3f8:	ea5f 0c01 	movs.w	ip, r1
     3fc:	bf02      	ittt	eq
     3fe:	4684      	moveq	ip, r0
     400:	4601      	moveq	r1, r0
     402:	2000      	moveq	r0, #0
     404:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
     408:	bf08      	it	eq
     40a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
     40e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
     412:	fabc f28c 	clz	r2, ip
     416:	3a08      	subs	r2, #8
     418:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
     41c:	db10      	blt.n	440 <CONFIG_LOG_BUFFER_SIZE+0x40>
     41e:	fa01 fc02 	lsl.w	ip, r1, r2
     422:	4463      	add	r3, ip
     424:	fa00 fc02 	lsl.w	ip, r0, r2
     428:	f1c2 0220 	rsb	r2, r2, #32
     42c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
     430:	fa20 f202 	lsr.w	r2, r0, r2
     434:	eb43 0002 	adc.w	r0, r3, r2
     438:	bf08      	it	eq
     43a:	f020 0001 	biceq.w	r0, r0, #1
     43e:	4770      	bx	lr
     440:	f102 0220 	add.w	r2, r2, #32
     444:	fa01 fc02 	lsl.w	ip, r1, r2
     448:	f1c2 0220 	rsb	r2, r2, #32
     44c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
     450:	fa21 f202 	lsr.w	r2, r1, r2
     454:	eb43 0002 	adc.w	r0, r3, r2
     458:	bf08      	it	eq
     45a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
     45e:	4770      	bx	lr

00000460 <__aeabi_uldivmod>:
     460:	b953      	cbnz	r3, 478 <__aeabi_uldivmod+0x18>
     462:	b94a      	cbnz	r2, 478 <__aeabi_uldivmod+0x18>
     464:	2900      	cmp	r1, #0
     466:	bf08      	it	eq
     468:	2800      	cmpeq	r0, #0
     46a:	bf1c      	itt	ne
     46c:	f04f 31ff 	movne.w	r1, #4294967295
     470:	f04f 30ff 	movne.w	r0, #4294967295
     474:	f000 b96c 	b.w	750 <__aeabi_idiv0>
     478:	f1ad 0c08 	sub.w	ip, sp, #8
     47c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     480:	f000 f806 	bl	490 <__udivmoddi4>
     484:	f8dd e004 	ldr.w	lr, [sp, #4]
     488:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     48c:	b004      	add	sp, #16
     48e:	4770      	bx	lr

00000490 <__udivmoddi4>:
     490:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     494:	9e08      	ldr	r6, [sp, #32]
     496:	460d      	mov	r5, r1
     498:	4604      	mov	r4, r0
     49a:	468e      	mov	lr, r1
     49c:	2b00      	cmp	r3, #0
     49e:	f040 8082 	bne.w	5a6 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xbe>
     4a2:	428a      	cmp	r2, r1
     4a4:	4617      	mov	r7, r2
     4a6:	d946      	bls.n	536 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x4e>
     4a8:	fab2 f282 	clz	r2, r2
     4ac:	b14a      	cbz	r2, 4c2 <__udivmoddi4+0x32>
     4ae:	f1c2 0120 	rsb	r1, r2, #32
     4b2:	fa05 f302 	lsl.w	r3, r5, r2
     4b6:	fa20 f101 	lsr.w	r1, r0, r1
     4ba:	4097      	lsls	r7, r2
     4bc:	ea41 0e03 	orr.w	lr, r1, r3
     4c0:	4094      	lsls	r4, r2
     4c2:	ea4f 4817 	mov.w	r8, r7, lsr #16
     4c6:	0c23      	lsrs	r3, r4, #16
     4c8:	fbbe fcf8 	udiv	ip, lr, r8
     4cc:	b2b9      	uxth	r1, r7
     4ce:	fb08 ee1c 	mls	lr, r8, ip, lr
     4d2:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
     4d6:	fb0c f001 	mul.w	r0, ip, r1
     4da:	4298      	cmp	r0, r3
     4dc:	d90a      	bls.n	4f4 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xc>
     4de:	18fb      	adds	r3, r7, r3
     4e0:	f10c 35ff 	add.w	r5, ip, #4294967295
     4e4:	f080 8116 	bcs.w	714 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x22c>
     4e8:	4298      	cmp	r0, r3
     4ea:	f240 8113 	bls.w	714 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x22c>
     4ee:	f1ac 0c02 	sub.w	ip, ip, #2
     4f2:	443b      	add	r3, r7
     4f4:	1a1b      	subs	r3, r3, r0
     4f6:	b2a4      	uxth	r4, r4
     4f8:	fbb3 f0f8 	udiv	r0, r3, r8
     4fc:	fb08 3310 	mls	r3, r8, r0, r3
     500:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     504:	fb00 f101 	mul.w	r1, r0, r1
     508:	42a1      	cmp	r1, r4
     50a:	d909      	bls.n	520 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x38>
     50c:	193c      	adds	r4, r7, r4
     50e:	f100 33ff 	add.w	r3, r0, #4294967295
     512:	f080 8101 	bcs.w	718 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x230>
     516:	42a1      	cmp	r1, r4
     518:	f240 80fe 	bls.w	718 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x230>
     51c:	3802      	subs	r0, #2
     51e:	443c      	add	r4, r7
     520:	1a64      	subs	r4, r4, r1
     522:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     526:	2100      	movs	r1, #0
     528:	b11e      	cbz	r6, 532 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x4a>
     52a:	40d4      	lsrs	r4, r2
     52c:	2300      	movs	r3, #0
     52e:	e9c6 4300 	strd	r4, r3, [r6]
     532:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     536:	b902      	cbnz	r2, 53a <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x52>
     538:	deff      	udf	#255	; 0xff
     53a:	fab2 f282 	clz	r2, r2
     53e:	2a00      	cmp	r2, #0
     540:	d14f      	bne.n	5e2 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xfa>
     542:	1bcb      	subs	r3, r1, r7
     544:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     548:	fa1f f887 	uxth.w	r8, r7
     54c:	2101      	movs	r1, #1
     54e:	fbb3 fcfe 	udiv	ip, r3, lr
     552:	0c25      	lsrs	r5, r4, #16
     554:	fb0e 331c 	mls	r3, lr, ip, r3
     558:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     55c:	fb08 f30c 	mul.w	r3, r8, ip
     560:	42ab      	cmp	r3, r5
     562:	d907      	bls.n	574 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x8c>
     564:	197d      	adds	r5, r7, r5
     566:	f10c 30ff 	add.w	r0, ip, #4294967295
     56a:	d202      	bcs.n	572 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x8a>
     56c:	42ab      	cmp	r3, r5
     56e:	f200 80e7 	bhi.w	740 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x258>
     572:	4684      	mov	ip, r0
     574:	1aed      	subs	r5, r5, r3
     576:	b2a3      	uxth	r3, r4
     578:	fbb5 f0fe 	udiv	r0, r5, lr
     57c:	fb0e 5510 	mls	r5, lr, r0, r5
     580:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
     584:	fb08 f800 	mul.w	r8, r8, r0
     588:	45a0      	cmp	r8, r4
     58a:	d907      	bls.n	59c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xb4>
     58c:	193c      	adds	r4, r7, r4
     58e:	f100 33ff 	add.w	r3, r0, #4294967295
     592:	d202      	bcs.n	59a <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xb2>
     594:	45a0      	cmp	r8, r4
     596:	f200 80d7 	bhi.w	748 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x260>
     59a:	4618      	mov	r0, r3
     59c:	eba4 0408 	sub.w	r4, r4, r8
     5a0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     5a4:	e7c0      	b.n	528 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x40>
     5a6:	428b      	cmp	r3, r1
     5a8:	d908      	bls.n	5bc <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xd4>
     5aa:	2e00      	cmp	r6, #0
     5ac:	f000 80af 	beq.w	70e <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x226>
     5b0:	2100      	movs	r1, #0
     5b2:	e9c6 0500 	strd	r0, r5, [r6]
     5b6:	4608      	mov	r0, r1
     5b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     5bc:	fab3 f183 	clz	r1, r3
     5c0:	2900      	cmp	r1, #0
     5c2:	d14b      	bne.n	65c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x174>
     5c4:	42ab      	cmp	r3, r5
     5c6:	d302      	bcc.n	5ce <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xe6>
     5c8:	4282      	cmp	r2, r0
     5ca:	f200 80b7 	bhi.w	73c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x254>
     5ce:	1a84      	subs	r4, r0, r2
     5d0:	eb65 0303 	sbc.w	r3, r5, r3
     5d4:	2001      	movs	r0, #1
     5d6:	469e      	mov	lr, r3
     5d8:	2e00      	cmp	r6, #0
     5da:	d0aa      	beq.n	532 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x4a>
     5dc:	e9c6 4e00 	strd	r4, lr, [r6]
     5e0:	e7a7      	b.n	532 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x4a>
     5e2:	f1c2 0c20 	rsb	ip, r2, #32
     5e6:	fa01 f302 	lsl.w	r3, r1, r2
     5ea:	4097      	lsls	r7, r2
     5ec:	fa20 f00c 	lsr.w	r0, r0, ip
     5f0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     5f4:	fa21 fc0c 	lsr.w	ip, r1, ip
     5f8:	4318      	orrs	r0, r3
     5fa:	fbbc f1fe 	udiv	r1, ip, lr
     5fe:	0c05      	lsrs	r5, r0, #16
     600:	fb0e cc11 	mls	ip, lr, r1, ip
     604:	fa1f f887 	uxth.w	r8, r7
     608:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
     60c:	fb01 f308 	mul.w	r3, r1, r8
     610:	42ab      	cmp	r3, r5
     612:	fa04 f402 	lsl.w	r4, r4, r2
     616:	d909      	bls.n	62c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x144>
     618:	197d      	adds	r5, r7, r5
     61a:	f101 3cff 	add.w	ip, r1, #4294967295
     61e:	f080 808b 	bcs.w	738 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x250>
     622:	42ab      	cmp	r3, r5
     624:	f240 8088 	bls.w	738 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x250>
     628:	3902      	subs	r1, #2
     62a:	443d      	add	r5, r7
     62c:	1aeb      	subs	r3, r5, r3
     62e:	b285      	uxth	r5, r0
     630:	fbb3 f0fe 	udiv	r0, r3, lr
     634:	fb0e 3310 	mls	r3, lr, r0, r3
     638:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     63c:	fb00 f308 	mul.w	r3, r0, r8
     640:	42ab      	cmp	r3, r5
     642:	d907      	bls.n	654 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x16c>
     644:	197d      	adds	r5, r7, r5
     646:	f100 3cff 	add.w	ip, r0, #4294967295
     64a:	d271      	bcs.n	730 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x248>
     64c:	42ab      	cmp	r3, r5
     64e:	d96f      	bls.n	730 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x248>
     650:	3802      	subs	r0, #2
     652:	443d      	add	r5, r7
     654:	1aeb      	subs	r3, r5, r3
     656:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
     65a:	e778      	b.n	54e <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x66>
     65c:	f1c1 0c20 	rsb	ip, r1, #32
     660:	408b      	lsls	r3, r1
     662:	fa22 f70c 	lsr.w	r7, r2, ip
     666:	431f      	orrs	r7, r3
     668:	fa20 f40c 	lsr.w	r4, r0, ip
     66c:	fa05 f301 	lsl.w	r3, r5, r1
     670:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     674:	fa25 f50c 	lsr.w	r5, r5, ip
     678:	431c      	orrs	r4, r3
     67a:	0c23      	lsrs	r3, r4, #16
     67c:	fbb5 f9fe 	udiv	r9, r5, lr
     680:	fa1f f887 	uxth.w	r8, r7
     684:	fb0e 5519 	mls	r5, lr, r9, r5
     688:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
     68c:	fb09 fa08 	mul.w	sl, r9, r8
     690:	45aa      	cmp	sl, r5
     692:	fa02 f201 	lsl.w	r2, r2, r1
     696:	fa00 f301 	lsl.w	r3, r0, r1
     69a:	d908      	bls.n	6ae <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x1c6>
     69c:	197d      	adds	r5, r7, r5
     69e:	f109 30ff 	add.w	r0, r9, #4294967295
     6a2:	d247      	bcs.n	734 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x24c>
     6a4:	45aa      	cmp	sl, r5
     6a6:	d945      	bls.n	734 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x24c>
     6a8:	f1a9 0902 	sub.w	r9, r9, #2
     6ac:	443d      	add	r5, r7
     6ae:	eba5 050a 	sub.w	r5, r5, sl
     6b2:	b2a4      	uxth	r4, r4
     6b4:	fbb5 f0fe 	udiv	r0, r5, lr
     6b8:	fb0e 5510 	mls	r5, lr, r0, r5
     6bc:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
     6c0:	fb00 f808 	mul.w	r8, r0, r8
     6c4:	45a0      	cmp	r8, r4
     6c6:	d907      	bls.n	6d8 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x1f0>
     6c8:	193c      	adds	r4, r7, r4
     6ca:	f100 35ff 	add.w	r5, r0, #4294967295
     6ce:	d22d      	bcs.n	72c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x244>
     6d0:	45a0      	cmp	r8, r4
     6d2:	d92b      	bls.n	72c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x244>
     6d4:	3802      	subs	r0, #2
     6d6:	443c      	add	r4, r7
     6d8:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
     6dc:	eba4 0408 	sub.w	r4, r4, r8
     6e0:	fba0 8902 	umull	r8, r9, r0, r2
     6e4:	454c      	cmp	r4, r9
     6e6:	46c6      	mov	lr, r8
     6e8:	464d      	mov	r5, r9
     6ea:	d319      	bcc.n	720 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x238>
     6ec:	d016      	beq.n	71c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x234>
     6ee:	b15e      	cbz	r6, 708 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x220>
     6f0:	ebb3 020e 	subs.w	r2, r3, lr
     6f4:	eb64 0405 	sbc.w	r4, r4, r5
     6f8:	fa04 fc0c 	lsl.w	ip, r4, ip
     6fc:	40ca      	lsrs	r2, r1
     6fe:	ea4c 0202 	orr.w	r2, ip, r2
     702:	40cc      	lsrs	r4, r1
     704:	e9c6 2400 	strd	r2, r4, [r6]
     708:	2100      	movs	r1, #0
     70a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     70e:	4631      	mov	r1, r6
     710:	4630      	mov	r0, r6
     712:	e70e      	b.n	532 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x4a>
     714:	46ac      	mov	ip, r5
     716:	e6ed      	b.n	4f4 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xc>
     718:	4618      	mov	r0, r3
     71a:	e701      	b.n	520 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x38>
     71c:	4543      	cmp	r3, r8
     71e:	d2e6      	bcs.n	6ee <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x206>
     720:	ebb8 0e02 	subs.w	lr, r8, r2
     724:	eb69 0507 	sbc.w	r5, r9, r7
     728:	3801      	subs	r0, #1
     72a:	e7e0      	b.n	6ee <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x206>
     72c:	4628      	mov	r0, r5
     72e:	e7d3      	b.n	6d8 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x1f0>
     730:	4660      	mov	r0, ip
     732:	e78f      	b.n	654 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x16c>
     734:	4681      	mov	r9, r0
     736:	e7ba      	b.n	6ae <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x1c6>
     738:	4661      	mov	r1, ip
     73a:	e777      	b.n	62c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x144>
     73c:	4608      	mov	r0, r1
     73e:	e74b      	b.n	5d8 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xf0>
     740:	f1ac 0c02 	sub.w	ip, ip, #2
     744:	443d      	add	r5, r7
     746:	e715      	b.n	574 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x8c>
     748:	3802      	subs	r0, #2
     74a:	443c      	add	r4, r7
     74c:	e726      	b.n	59c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0xb4>
     74e:	bf00      	nop

00000750 <__aeabi_idiv0>:
     750:	4770      	bx	lr
     752:	bf00      	nop

00000754 <main>:


LOG_MODULE_REGISTER(app, CONFIG_LOG_DEFAULT_LEVEL);

void main(void)
{
     754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	printk("Hello World! %s\n", CONFIG_BOARD);
     756:	4932      	ldr	r1, [pc, #200]	; (820 <CONFIG_HEAP_MEM_POOL_SIZE+0x20>)
     758:	4832      	ldr	r0, [pc, #200]	; (824 <CONFIG_HEAP_MEM_POOL_SIZE+0x24>)
     75a:	f006 fd10 	bl	717e <printk>
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     75e:	4832      	ldr	r0, [pc, #200]	; (828 <CONFIG_HEAP_MEM_POOL_SIZE+0x28>)
     760:	f005 f952 	bl	5a08 <z_impl_device_get_binding>

	bmxIMU_spi.gpio0_dev= device_get_binding("GPIO_0");
     764:	4d31      	ldr	r5, [pc, #196]	; (82c <CONFIG_HEAP_MEM_POOL_SIZE+0x2c>)
     766:	6168      	str	r0, [r5, #20]
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((const uint8_t *)data - (uint8_t *)__log_const_start)/
     768:	4c31      	ldr	r4, [pc, #196]	; (830 <CONFIG_HEAP_MEM_POOL_SIZE+0x30>)
     76a:	4b32      	ldr	r3, [pc, #200]	; (834 <CONFIG_HEAP_MEM_POOL_SIZE+0x34>)
     76c:	1ae4      	subs	r4, r4, r3
     76e:	08e4      	lsrs	r4, r4, #3

	
	LOG_ERR("This is a error message!");
     770:	2601      	movs	r6, #1
     772:	f04f 0100 	mov.w	r1, #0
     776:	f366 0102 	bfi	r1, r6, #0, #3
     77a:	f36f 01c5 	bfc	r1, #3, #3
     77e:	f364 118f 	bfi	r1, r4, #6, #10
     782:	482d      	ldr	r0, [pc, #180]	; (838 <CONFIG_HEAP_MEM_POOL_SIZE+0x38>)
     784:	f001 fa28 	bl	1bd8 <log_0>
	LOG_WRN("This is a warning message!");
     788:	f04f 0100 	mov.w	r1, #0
     78c:	2302      	movs	r3, #2
     78e:	f363 0102 	bfi	r1, r3, #0, #3
     792:	f36f 01c5 	bfc	r1, #3, #3
     796:	f364 118f 	bfi	r1, r4, #6, #10
     79a:	4828      	ldr	r0, [pc, #160]	; (83c <CONFIG_HEAP_MEM_POOL_SIZE+0x3c>)
     79c:	f001 fa1c 	bl	1bd8 <log_0>
	LOG_INF("This is a information message!");
     7a0:	f04f 0100 	mov.w	r1, #0
     7a4:	2303      	movs	r3, #3
     7a6:	f363 0102 	bfi	r1, r3, #0, #3
     7aa:	f36f 01c5 	bfc	r1, #3, #3
     7ae:	f364 118f 	bfi	r1, r4, #6, #10
     7b2:	4823      	ldr	r0, [pc, #140]	; (840 <CONFIG_HEAP_MEM_POOL_SIZE+0x40>)
     7b4:	f001 fa10 	bl	1bd8 <log_0>
	LOG_DBG("This is a debugging message!");
     7b8:	f04f 0200 	mov.w	r2, #0
     7bc:	2304      	movs	r3, #4
     7be:	f363 0202 	bfi	r2, r3, #0, #3
     7c2:	f36f 02c5 	bfc	r2, #3, #3
     7c6:	f364 128f 	bfi	r2, r4, #6, #10
     7ca:	491e      	ldr	r1, [pc, #120]	; (844 <CONFIG_HEAP_MEM_POOL_SIZE+0x44>)
     7cc:	481e      	ldr	r0, [pc, #120]	; (848 <CONFIG_HEAP_MEM_POOL_SIZE+0x48>)
     7ce:	f001 f991 	bl	1af4 <log_1>

	gpio_pin_configure(bmxIMU_spi.gpio0_dev, bmxIMU_spi.spi_cs_pin, GPIO_OUTPUT | GPIO_ACTIVE_LOW);
     7d2:	6968      	ldr	r0, [r5, #20]
     7d4:	7c29      	ldrb	r1, [r5, #16]

static inline int z_impl_gpio_pin_configure(const struct device *port,
					    gpio_pin_t pin,
					    gpio_flags_t flags)
{
	const struct gpio_driver_api *api =
     7d6:	6887      	ldr	r7, [r0, #8]
		(const struct gpio_driver_api *)port->api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config;
	struct gpio_driver_data *data =
     7d8:	6904      	ldr	r4, [r0, #16]
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
     7da:	fa06 f301 	lsl.w	r3, r6, r1
     7de:	6822      	ldr	r2, [r4, #0]
     7e0:	4313      	orrs	r3, r2
     7e2:	6023      	str	r3, [r4, #0]
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
	}

	return api->pin_configure(port, pin, flags);
     7e4:	683b      	ldr	r3, [r7, #0]
     7e6:	f240 2201 	movw	r2, #513	; 0x201
     7ea:	4798      	blx	r3
     7ec:	4817      	ldr	r0, [pc, #92]	; (84c <CONFIG_HEAP_MEM_POOL_SIZE+0x4c>)
     7ee:	f005 f90b 	bl	5a08 <z_impl_device_get_binding>


	const char* const spiName0 = "SPI_0";
	bmxIMU_spi.spi_dev = device_get_binding(spiName0);
     7f2:	60e8      	str	r0, [r5, #12]

	if (bmxIMU_spi.spi_dev == NULL) {
     7f4:	b170      	cbz	r0, 814 <CONFIG_HEAP_MEM_POOL_SIZE+0x14>
		printk("Could not get %s device\n", spiName0);
		return;
	}
	else
		printk("Got SPI device\n");
     7f6:	4816      	ldr	r0, [pc, #88]	; (850 <CONFIG_HEAP_MEM_POOL_SIZE+0x50>)
     7f8:	f006 fcc1 	bl	717e <printk>



	begin_bmx160(&bmxIMU_spi);
     7fc:	480b      	ldr	r0, [pc, #44]	; (82c <CONFIG_HEAP_MEM_POOL_SIZE+0x2c>)
     7fe:	f006 fc4b 	bl	7098 <begin_bmx160>

	for (;;) {
    // Main entry point after IMU sensors and BLE init 

    // Read filtered BMX160 IMU data at 200MHZ and store it to the struct
	getData_bmx160(&bmxIMU_spi, &bmx160_data);
     802:	4914      	ldr	r1, [pc, #80]	; (854 <CONFIG_HEAP_MEM_POOL_SIZE+0x54>)
     804:	4809      	ldr	r0, [pc, #36]	; (82c <CONFIG_HEAP_MEM_POOL_SIZE+0x2c>)
     806:	f000 f889 	bl	91c <getData_bmx160>
		/* coverity[OVERRUN] */
		return (int32_t) arch_syscall_invoke2(parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
     80a:	2000      	movs	r0, #0
     80c:	2100      	movs	r1, #0
     80e:	f006 f8c3 	bl	6998 <z_impl_k_sleep>
	for (;;) {
     812:	e7f6      	b.n	802 <CONFIG_HEAP_MEM_POOL_SIZE+0x2>
		printk("Could not get %s device\n", spiName0);
     814:	490d      	ldr	r1, [pc, #52]	; (84c <CONFIG_HEAP_MEM_POOL_SIZE+0x4c>)
     816:	4810      	ldr	r0, [pc, #64]	; (858 <CONFIG_HEAP_MEM_POOL_SIZE+0x58>)
     818:	f006 fcb1 	bl	717e <printk>

    // Sleep and wait for next cycle
	k_sleep(K_MSEC(SENSOR_READ_MS_THREAD));
	}
}
     81c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     81e:	bf00      	nop
     820:	00008ef8 	.word	0x00008ef8
     824:	00008f04 	.word	0x00008f04
     828:	00008f18 	.word	0x00008f18
     82c:	20000000 	.word	0x20000000
     830:	00008e48 	.word	0x00008e48
     834:	00008e48 	.word	0x00008e48
     838:	00008f20 	.word	0x00008f20
     83c:	00008f3c 	.word	0x00008f3c
     840:	00008f58 	.word	0x00008f58
     844:	00008fd4 	.word	0x00008fd4
     848:	00008f78 	.word	0x00008f78
     84c:	00008f9c 	.word	0x00008f9c
     850:	00008fc0 	.word	0x00008fc0
     854:	20000398 	.word	0x20000398
     858:	00008fa4 	.word	0x00008fa4

0000085c <setAccelRange_bmx160>:
    sentVal = (uint8_t)(passVal_odr | passVal_osr);
    writeReg_bmx160(bmxIMU_spi_p, BMX160_GYR_CONF_REG, sentVal);
}

void setAccelRange_bmx160(bmx160_spi * bmxIMU_spi_p, bmx160_accel_range passVal)
{
     85c:	b510      	push	{r4, lr}
     85e:	460c      	mov	r4, r1
    uint8_t sentVal = 0b0;
    sentVal = (uint8_t)passVal;
    writeReg_bmx160(bmxIMU_spi_p, BMX160_ACC_RANGE_REG, sentVal);
     860:	460a      	mov	r2, r1
     862:	2141      	movs	r1, #65	; 0x41
     864:	f006 fb48 	bl	6ef8 <writeReg_bmx160>
    switch (passVal){
     868:	3c03      	subs	r4, #3
     86a:	2c09      	cmp	r4, #9
     86c:	d816      	bhi.n	89c <setAccelRange_bmx160+0x40>
     86e:	e8df f004 	tbb	[pc, r4]
     872:	1505      	.short	0x1505
     874:	0d151509 	.word	0x0d151509
     878:	11151515 	.word	0x11151515
        case bmx160_accelRange_2g:
            accelRange = BMX160_ACCEL_MG_LSB_2G * G_CONST;
     87c:	4b09      	ldr	r3, [pc, #36]	; (8a4 <setAccelRange_bmx160+0x48>)
     87e:	4a0a      	ldr	r2, [pc, #40]	; (8a8 <setAccelRange_bmx160+0x4c>)
     880:	601a      	str	r2, [r3, #0]
            break;
        default:
            accelRange = BMX160_ACCEL_MG_LSB_2G * G_CONST;
            break;
    }
}
     882:	bd10      	pop	{r4, pc}
            accelRange = BMX160_ACCEL_MG_LSB_4G * G_CONST;
     884:	4b07      	ldr	r3, [pc, #28]	; (8a4 <setAccelRange_bmx160+0x48>)
     886:	4a09      	ldr	r2, [pc, #36]	; (8ac <setAccelRange_bmx160+0x50>)
     888:	601a      	str	r2, [r3, #0]
            break;
     88a:	e7fa      	b.n	882 <setAccelRange_bmx160+0x26>
            accelRange = BMX160_ACCEL_MG_LSB_8G * G_CONST;
     88c:	4b05      	ldr	r3, [pc, #20]	; (8a4 <setAccelRange_bmx160+0x48>)
     88e:	4a08      	ldr	r2, [pc, #32]	; (8b0 <setAccelRange_bmx160+0x54>)
     890:	601a      	str	r2, [r3, #0]
            break;
     892:	e7f6      	b.n	882 <setAccelRange_bmx160+0x26>
            accelRange = BMX160_ACCEL_MG_LSB_16G * G_CONST;
     894:	4b03      	ldr	r3, [pc, #12]	; (8a4 <setAccelRange_bmx160+0x48>)
     896:	4a07      	ldr	r2, [pc, #28]	; (8b4 <setAccelRange_bmx160+0x58>)
     898:	601a      	str	r2, [r3, #0]
            break;
     89a:	e7f2      	b.n	882 <setAccelRange_bmx160+0x26>
            accelRange = BMX160_ACCEL_MG_LSB_2G * G_CONST;
     89c:	4b01      	ldr	r3, [pc, #4]	; (8a4 <setAccelRange_bmx160+0x48>)
     89e:	4a02      	ldr	r2, [pc, #8]	; (8a8 <setAccelRange_bmx160+0x4c>)
     8a0:	601a      	str	r2, [r3, #0]
}
     8a2:	e7ee      	b.n	882 <setAccelRange_bmx160+0x26>
     8a4:	20000018 	.word	0x20000018
     8a8:	3a1cf5a9 	.word	0x3a1cf5a9
     8ac:	3a9cf5a9 	.word	0x3a9cf5a9
     8b0:	3b1cf5d3 	.word	0x3b1cf5d3
     8b4:	3b9cf5bd 	.word	0x3b9cf5bd

000008b8 <setGyroRange_bmx160>:

void setGyroRange_bmx160(bmx160_spi * bmxIMU_spi_p, bmx160_gyro_range passVal)
{
     8b8:	b510      	push	{r4, lr}
     8ba:	460c      	mov	r4, r1
    uint8_t sentVal = 0b0;
    sentVal = (uint8_t)passVal;
    writeReg_bmx160(bmxIMU_spi_p, BMX160_GYR_RANGE_REG, sentVal);
     8bc:	460a      	mov	r2, r1
     8be:	2143      	movs	r1, #67	; 0x43
     8c0:	f006 fb1a 	bl	6ef8 <writeReg_bmx160>
    switch (passVal){
     8c4:	2c04      	cmp	r4, #4
     8c6:	d818      	bhi.n	8fa <setGyroRange_bmx160+0x42>
     8c8:	e8df f004 	tbb	[pc, r4]
     8cc:	070b0f13 	.word	0x070b0f13
     8d0:	03          	.byte	0x03
     8d1:	00          	.byte	0x00
        case bmx160_gyroRange_125dps:
            gyroRange = BMX160_GYRO_SENSITIVITY_125DPS;
     8d2:	4b0c      	ldr	r3, [pc, #48]	; (904 <setGyroRange_bmx160+0x4c>)
     8d4:	4a0c      	ldr	r2, [pc, #48]	; (908 <setGyroRange_bmx160+0x50>)
     8d6:	601a      	str	r2, [r3, #0]
            break;
        default:
            gyroRange = BMX160_GYRO_SENSITIVITY_250DPS;
            break;
    }
}
     8d8:	bd10      	pop	{r4, pc}
            gyroRange = BMX160_GYRO_SENSITIVITY_250DPS;
     8da:	4b0a      	ldr	r3, [pc, #40]	; (904 <setGyroRange_bmx160+0x4c>)
     8dc:	4a0b      	ldr	r2, [pc, #44]	; (90c <setGyroRange_bmx160+0x54>)
     8de:	601a      	str	r2, [r3, #0]
            break;
     8e0:	e7fa      	b.n	8d8 <setGyroRange_bmx160+0x20>
            gyroRange = BMX160_GYRO_SENSITIVITY_500DPS;
     8e2:	4b08      	ldr	r3, [pc, #32]	; (904 <setGyroRange_bmx160+0x4c>)
     8e4:	4a0a      	ldr	r2, [pc, #40]	; (910 <setGyroRange_bmx160+0x58>)
     8e6:	601a      	str	r2, [r3, #0]
            break;
     8e8:	e7f6      	b.n	8d8 <setGyroRange_bmx160+0x20>
            gyroRange = BMX160_GYRO_SENSITIVITY_1000DPS;
     8ea:	4b06      	ldr	r3, [pc, #24]	; (904 <setGyroRange_bmx160+0x4c>)
     8ec:	4a09      	ldr	r2, [pc, #36]	; (914 <setGyroRange_bmx160+0x5c>)
     8ee:	601a      	str	r2, [r3, #0]
            break;
     8f0:	e7f2      	b.n	8d8 <setGyroRange_bmx160+0x20>
            gyroRange = BMX160_GYRO_SENSITIVITY_2000DPS;
     8f2:	4b04      	ldr	r3, [pc, #16]	; (904 <setGyroRange_bmx160+0x4c>)
     8f4:	4a08      	ldr	r2, [pc, #32]	; (918 <setGyroRange_bmx160+0x60>)
     8f6:	601a      	str	r2, [r3, #0]
            break;
     8f8:	e7ee      	b.n	8d8 <setGyroRange_bmx160+0x20>
            gyroRange = BMX160_GYRO_SENSITIVITY_250DPS;
     8fa:	4b02      	ldr	r3, [pc, #8]	; (904 <setGyroRange_bmx160+0x4c>)
     8fc:	4a03      	ldr	r2, [pc, #12]	; (90c <setGyroRange_bmx160+0x54>)
     8fe:	601a      	str	r2, [r3, #0]
}
     900:	e7ea      	b.n	8d8 <setGyroRange_bmx160+0x20>
     902:	bf00      	nop
     904:	2000001c 	.word	0x2000001c
     908:	3b79c1f8 	.word	0x3b79c1f8
     90c:	3bf9c1f8 	.word	0x3bf9c1f8
     910:	3c79c18d 	.word	0x3c79c18d
     914:	3cf9c18d 	.word	0x3cf9c18d
     918:	3d79c18d 	.word	0x3d79c18d

0000091c <getData_bmx160>:
}*/
uint8_t getData_bmx160(bmx160_spi * bmxIMU_spi_p, bmx160_sensor_data * sen_data)
{
    int result;
    int16_t x=0,y=0,z=0; 
    if (sen_data == NULL)
     91c:	2900      	cmp	r1, #0
     91e:	d06d      	beq.n	9fc <getData_bmx160+0xe0>
{
     920:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     924:	b084      	sub	sp, #16
     926:	460d      	mov	r5, r1
    z = (int16_t) (((uint16_t)data[19] << 8) | data[18]);
    sen_data->ax = (float)(x) * accelRange;
    sen_data->ay = (float)(y) * accelRange;
    sen_data->az = (float)(z) * accelRange;
#elif USE_BMI160
    uint8_t data[12] = {0};
     928:	2300      	movs	r3, #0
     92a:	9301      	str	r3, [sp, #4]
     92c:	9302      	str	r3, [sp, #8]
     92e:	9303      	str	r3, [sp, #12]
    result = readReg_bmx160(bmxIMU_spi_p, BMX160_GYR_X_LSB_REG, data, 12);
     930:	230c      	movs	r3, #12
     932:	aa01      	add	r2, sp, #4
     934:	4619      	mov	r1, r3
     936:	f006 fb53 	bl	6fe0 <readReg_bmx160>
     93a:	4606      	mov	r6, r0
    
    x = (int16_t) (((uint16_t)data[1] << 8) | data[0]);
     93c:	f89d 3005 	ldrb.w	r3, [sp, #5]
     940:	021b      	lsls	r3, r3, #8
     942:	b21b      	sxth	r3, r3
     944:	f89d 0004 	ldrb.w	r0, [sp, #4]
    y = (int16_t) (((uint16_t)data[3] << 8) | data[2]);
     948:	f89d 7007 	ldrb.w	r7, [sp, #7]
     94c:	023f      	lsls	r7, r7, #8
     94e:	b23f      	sxth	r7, r7
     950:	f89d 2006 	ldrb.w	r2, [sp, #6]
     954:	4317      	orrs	r7, r2
    z = (int16_t) (((uint16_t)data[5] << 8) | data[4]);
     956:	f89d 4009 	ldrb.w	r4, [sp, #9]
     95a:	0224      	lsls	r4, r4, #8
     95c:	b224      	sxth	r4, r4
     95e:	f89d 2008 	ldrb.w	r2, [sp, #8]
     962:	4314      	orrs	r4, r2
    sen_data->gx = (float)(x) * gyroRange;
     964:	4318      	orrs	r0, r3
     966:	f7ff fd27 	bl	3b8 <__aeabi_i2f>
     96a:	4b25      	ldr	r3, [pc, #148]	; (a00 <getData_bmx160+0xe4>)
     96c:	f8d3 8000 	ldr.w	r8, [r3]
     970:	4641      	mov	r1, r8
     972:	f7ff fbb3 	bl	dc <__aeabi_fmul>
     976:	60e8      	str	r0, [r5, #12]
    sen_data->gy = (float)(y) * gyroRange;
     978:	4638      	mov	r0, r7
     97a:	f7ff fd1d 	bl	3b8 <__aeabi_i2f>
     97e:	4601      	mov	r1, r0
     980:	4640      	mov	r0, r8
     982:	f7ff fbab 	bl	dc <__aeabi_fmul>
     986:	6128      	str	r0, [r5, #16]
    sen_data->gz = (float)(z) * gyroRange;
     988:	4620      	mov	r0, r4
     98a:	f7ff fd15 	bl	3b8 <__aeabi_i2f>
     98e:	4601      	mov	r1, r0
     990:	4640      	mov	r0, r8
     992:	f7ff fba3 	bl	dc <__aeabi_fmul>
     996:	6168      	str	r0, [r5, #20]

    x = (int16_t) (((uint16_t)data[7] << 8) | data[6]);
     998:	f89d 300b 	ldrb.w	r3, [sp, #11]
     99c:	021b      	lsls	r3, r3, #8
     99e:	b21b      	sxth	r3, r3
     9a0:	f89d 000a 	ldrb.w	r0, [sp, #10]
    y = (int16_t) (((uint16_t)data[9] << 8) | data[8]);
     9a4:	f89d 700d 	ldrb.w	r7, [sp, #13]
     9a8:	023f      	lsls	r7, r7, #8
     9aa:	b23f      	sxth	r7, r7
     9ac:	f89d 200c 	ldrb.w	r2, [sp, #12]
     9b0:	4317      	orrs	r7, r2
    z = (int16_t) (((uint16_t)data[11] << 8) | data[10]);
     9b2:	f89d 400f 	ldrb.w	r4, [sp, #15]
     9b6:	0224      	lsls	r4, r4, #8
     9b8:	b224      	sxth	r4, r4
     9ba:	f89d 200e 	ldrb.w	r2, [sp, #14]
     9be:	4314      	orrs	r4, r2
    sen_data->ax = (float)(x) * accelRange;
     9c0:	4318      	orrs	r0, r3
     9c2:	f7ff fcf9 	bl	3b8 <__aeabi_i2f>
     9c6:	4b0f      	ldr	r3, [pc, #60]	; (a04 <getData_bmx160+0xe8>)
     9c8:	f8d3 8000 	ldr.w	r8, [r3]
     9cc:	4641      	mov	r1, r8
     9ce:	f7ff fb85 	bl	dc <__aeabi_fmul>
     9d2:	6028      	str	r0, [r5, #0]
    sen_data->ay = (float)(y) * accelRange;
     9d4:	4638      	mov	r0, r7
     9d6:	f7ff fcef 	bl	3b8 <__aeabi_i2f>
     9da:	4601      	mov	r1, r0
     9dc:	4640      	mov	r0, r8
     9de:	f7ff fb7d 	bl	dc <__aeabi_fmul>
     9e2:	6068      	str	r0, [r5, #4]
    sen_data->az = (float)(z) * accelRange;
     9e4:	4620      	mov	r0, r4
     9e6:	f7ff fce7 	bl	3b8 <__aeabi_i2f>
     9ea:	4601      	mov	r1, r0
     9ec:	4640      	mov	r0, r8
     9ee:	f7ff fb75 	bl	dc <__aeabi_fmul>
     9f2:	60a8      	str	r0, [r5, #8]
#else
    #error Please Select only the sed CHIP in 'bmx160.h'
#endif

    return result;
     9f4:	b2f0      	uxtb	r0, r6
}
     9f6:	b004      	add	sp, #16
     9f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return BMX160_E_NULL_PTR;
     9fc:	20ff      	movs	r0, #255	; 0xff
}
     9fe:	4770      	bx	lr
     a00:	2000001c 	.word	0x2000001c
     a04:	20000018 	.word	0x20000018

00000a08 <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
     a08:	4b01      	ldr	r3, [pc, #4]	; (a10 <__printk_hook_install+0x8>)
     a0a:	6018      	str	r0, [r3, #0]
}
     a0c:	4770      	bx	lr
     a0e:	bf00      	nop
     a10:	20000020 	.word	0x20000020

00000a14 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
     a14:	b510      	push	{r4, lr}
     a16:	b084      	sub	sp, #16
     a18:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
     a1a:	9001      	str	r0, [sp, #4]
     a1c:	9102      	str	r1, [sp, #8]
     a1e:	2100      	movs	r1, #0
     a20:	9103      	str	r1, [sp, #12]

	cbvprintf(str_out, &ctx, fmt, ap);
     a22:	a901      	add	r1, sp, #4
     a24:	4805      	ldr	r0, [pc, #20]	; (a3c <vsnprintk+0x28>)
     a26:	f000 f8b7 	bl	b98 <cbvprintf>

	if (ctx.count < ctx.max) {
     a2a:	9b03      	ldr	r3, [sp, #12]
     a2c:	9a02      	ldr	r2, [sp, #8]
     a2e:	4293      	cmp	r3, r2
     a30:	da01      	bge.n	a36 <vsnprintk+0x22>
		str[ctx.count] = '\0';
     a32:	2200      	movs	r2, #0
     a34:	54e2      	strb	r2, [r4, r3]
	}

	return ctx.count;
}
     a36:	9803      	ldr	r0, [sp, #12]
     a38:	b004      	add	sp, #16
     a3a:	bd10      	pop	{r4, pc}
     a3c:	0000714f 	.word	0x0000714f

00000a40 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     a40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     a44:	b083      	sub	sp, #12
     a46:	4604      	mov	r4, r0
     a48:	4608      	mov	r0, r1
     a4a:	4615      	mov	r5, r2
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     a4c:	8b23      	ldrh	r3, [r4, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     a4e:	f013 0f08 	tst.w	r3, #8
     a52:	d105      	bne.n	a60 <process_event+0x20>
     a54:	f003 0607 	and.w	r6, r3, #7
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
     a58:	2300      	movs	r3, #0
     a5a:	9300      	str	r3, [sp, #0]
	list->tail = NULL;
     a5c:	9301      	str	r3, [sp, #4]
}
     a5e:	e069      	b.n	b34 <process_event+0xf4>
		if (evt == EVT_COMPLETE) {
     a60:	2901      	cmp	r1, #1
     a62:	d009      	beq.n	a78 <process_event+0x38>
			mgr->flags |= ONOFF_FLAG_COMPLETE;
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     a64:	f043 0320 	orr.w	r3, r3, #32
     a68:	8323      	strh	r3, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     a6a:	f385 8811 	msr	BASEPRI, r5
     a6e:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     a72:	b003      	add	sp, #12
     a74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     a78:	f043 0310 	orr.w	r3, r3, #16
     a7c:	8323      	strh	r3, [r4, #24]
     a7e:	e7f4      	b.n	a6a <process_event+0x2a>
			evt = process_recheck(mgr);
     a80:	4620      	mov	r0, r4
     a82:	f006 fbbf 	bl	7204 <process_recheck>
     a86:	e057      	b.n	b38 <process_event+0xf8>
			res = mgr->last_res;
     a88:	f8d4 9014 	ldr.w	r9, [r4, #20]
			process_complete(mgr, &clients, res);
     a8c:	464a      	mov	r2, r9
     a8e:	4669      	mov	r1, sp
     a90:	4620      	mov	r0, r4
     a92:	f006 fbd0 	bl	7236 <process_complete>
		onoff_transition_fn transit = NULL;
     a96:	2700      	movs	r7, #0
     a98:	e05a      	b.n	b50 <process_event+0x110>
			transit = mgr->transitions->start;
     a9a:	6923      	ldr	r3, [r4, #16]
     a9c:	681f      	ldr	r7, [r3, #0]
			set_state(mgr, ONOFF_STATE_TO_ON);
     a9e:	2106      	movs	r1, #6
     aa0:	4620      	mov	r0, r4
     aa2:	f006 fb88 	bl	71b6 <set_state>
		res = 0;
     aa6:	f04f 0900 	mov.w	r9, #0
     aaa:	e051      	b.n	b50 <process_event+0x110>
			transit = mgr->transitions->stop;
     aac:	6923      	ldr	r3, [r4, #16]
     aae:	685f      	ldr	r7, [r3, #4]
			set_state(mgr, ONOFF_STATE_TO_OFF);
     ab0:	2104      	movs	r1, #4
     ab2:	4620      	mov	r0, r4
     ab4:	f006 fb7f 	bl	71b6 <set_state>
		res = 0;
     ab8:	f04f 0900 	mov.w	r9, #0
     abc:	e048      	b.n	b50 <process_event+0x110>
			transit = mgr->transitions->reset;
     abe:	6923      	ldr	r3, [r4, #16]
     ac0:	689f      	ldr	r7, [r3, #8]
			set_state(mgr, ONOFF_STATE_RESETTING);
     ac2:	2105      	movs	r1, #5
     ac4:	4620      	mov	r0, r4
     ac6:	f006 fb76 	bl	71b6 <set_state>
		res = 0;
     aca:	f04f 0900 	mov.w	r9, #0
     ace:	e03f      	b.n	b50 <process_event+0x110>
				   && !sys_slist_is_empty(&mgr->monitors);
     ad0:	2200      	movs	r2, #0
     ad2:	e046      	b.n	b62 <process_event+0x122>
     ad4:	2200      	movs	r2, #0
     ad6:	e044      	b.n	b62 <process_event+0x122>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     ad8:	f043 0308 	orr.w	r3, r3, #8
			mgr->flags = flags;
     adc:	8323      	strh	r3, [r4, #24]
     ade:	f385 8811 	msr	BASEPRI, r5
     ae2:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
     ae6:	2900      	cmp	r1, #0
     ae8:	d144      	bne.n	b74 <process_event+0x134>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
     aea:	9b00      	ldr	r3, [sp, #0]
			if (!sys_slist_is_empty(&clients)) {
     aec:	b12b      	cbz	r3, afa <process_event+0xba>
				notify_all(mgr, &clients, state, res);
     aee:	464b      	mov	r3, r9
     af0:	4642      	mov	r2, r8
     af2:	4669      	mov	r1, sp
     af4:	4620      	mov	r0, r4
     af6:	f006 fc14 	bl	7322 <notify_all>
			if (transit != NULL) {
     afa:	b117      	cbz	r7, b02 <process_event+0xc2>
				transit(mgr, transition_complete);
     afc:	4925      	ldr	r1, [pc, #148]	; (b94 <process_event+0x154>)
     afe:	4620      	mov	r0, r4
     b00:	47b8      	blx	r7
	__asm__ volatile(
     b02:	f04f 0320 	mov.w	r3, #32
     b06:	f3ef 8511 	mrs	r5, BASEPRI
     b0a:	f383 8812 	msr	BASEPRI_MAX, r3
     b0e:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     b12:	8b23      	ldrh	r3, [r4, #24]
     b14:	f023 0308 	bic.w	r3, r3, #8
     b18:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     b1a:	8b23      	ldrh	r3, [r4, #24]
     b1c:	f013 0f10 	tst.w	r3, #16
     b20:	d02e      	beq.n	b80 <process_event+0x140>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     b22:	f023 0310 	bic.w	r3, r3, #16
     b26:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
     b28:	2001      	movs	r0, #1
		state = mgr->flags & ONOFF_STATE_MASK;
     b2a:	8b26      	ldrh	r6, [r4, #24]
     b2c:	f006 0607 	and.w	r6, r6, #7
	} while (evt != EVT_NOP);
     b30:	2800      	cmp	r0, #0
     b32:	d09a      	beq.n	a6a <process_event+0x2a>
		if (evt == EVT_RECHECK) {
     b34:	2802      	cmp	r0, #2
     b36:	d0a3      	beq.n	a80 <process_event+0x40>
		if (evt == EVT_NOP) {
     b38:	2800      	cmp	r0, #0
     b3a:	d096      	beq.n	a6a <process_event+0x2a>
		if (evt == EVT_COMPLETE) {
     b3c:	2801      	cmp	r0, #1
     b3e:	d0a3      	beq.n	a88 <process_event+0x48>
		} else if (evt == EVT_START) {
     b40:	2803      	cmp	r0, #3
     b42:	d0aa      	beq.n	a9a <process_event+0x5a>
		} else if (evt == EVT_STOP) {
     b44:	2804      	cmp	r0, #4
     b46:	d0b1      	beq.n	aac <process_event+0x6c>
		} else if (evt == EVT_RESET) {
     b48:	2805      	cmp	r0, #5
     b4a:	d0b8      	beq.n	abe <process_event+0x7e>
		onoff_transition_fn transit = NULL;
     b4c:	2700      	movs	r7, #0
		res = 0;
     b4e:	46b9      	mov	r9, r7
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     b50:	8b23      	ldrh	r3, [r4, #24]
     b52:	f003 0807 	and.w	r8, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
     b56:	45b0      	cmp	r8, r6
     b58:	d0ba      	beq.n	ad0 <process_event+0x90>
     b5a:	68a2      	ldr	r2, [r4, #8]
     b5c:	2a00      	cmp	r2, #0
     b5e:	d0b9      	beq.n	ad4 <process_event+0x94>
     b60:	2201      	movs	r2, #1
		if (do_monitors
     b62:	4611      	mov	r1, r2
     b64:	2a00      	cmp	r2, #0
     b66:	d1b7      	bne.n	ad8 <process_event+0x98>
     b68:	9a00      	ldr	r2, [sp, #0]
		    || !sys_slist_is_empty(&clients)
     b6a:	2a00      	cmp	r2, #0
     b6c:	d1b4      	bne.n	ad8 <process_event+0x98>
		    || (transit != NULL)) {
     b6e:	2f00      	cmp	r7, #0
     b70:	d1b2      	bne.n	ad8 <process_event+0x98>
     b72:	e7d2      	b.n	b1a <process_event+0xda>
				notify_monitors(mgr, state, res);
     b74:	464a      	mov	r2, r9
     b76:	4641      	mov	r1, r8
     b78:	4620      	mov	r0, r4
     b7a:	f006 fb24 	bl	71c6 <notify_monitors>
     b7e:	e7b4      	b.n	aea <process_event+0xaa>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     b80:	f013 0f20 	tst.w	r3, #32
     b84:	d004      	beq.n	b90 <process_event+0x150>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     b86:	f023 0320 	bic.w	r3, r3, #32
     b8a:	8323      	strh	r3, [r4, #24]
			evt = EVT_RECHECK;
     b8c:	2002      	movs	r0, #2
     b8e:	e7cc      	b.n	b2a <process_event+0xea>
		evt = EVT_NOP;
     b90:	2000      	movs	r0, #0
     b92:	e7ca      	b.n	b2a <process_event+0xea>
     b94:	00007351 	.word	0x00007351

00000b98 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
     b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     b9c:	b093      	sub	sp, #76	; 0x4c
     b9e:	4606      	mov	r6, r0
     ba0:	460d      	mov	r5, r1
     ba2:	4692      	mov	sl, r2
     ba4:	9303      	str	r3, [sp, #12]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
     ba6:	2400      	movs	r4, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
     ba8:	f89a 0000 	ldrb.w	r0, [sl]
     bac:	2800      	cmp	r0, #0
     bae:	f000 84d6 	beq.w	155e <CONFIG_FPROTECT_BLOCK_SIZE+0x55e>
		if (*fp != '%') {
     bb2:	2825      	cmp	r0, #37	; 0x25
     bb4:	d008      	beq.n	bc8 <cbvprintf+0x30>
			OUTC(*fp++);
     bb6:	f10a 0a01 	add.w	sl, sl, #1
     bba:	4629      	mov	r1, r5
     bbc:	47b0      	blx	r6
     bbe:	2800      	cmp	r0, #0
     bc0:	f2c0 84ce 	blt.w	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
     bc4:	3401      	adds	r4, #1
			continue;
     bc6:	e7ef      	b.n	ba8 <cbvprintf+0x10>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
     bc8:	2300      	movs	r3, #0
     bca:	9306      	str	r3, [sp, #24]
     bcc:	9307      	str	r3, [sp, #28]
     bce:	930b      	str	r3, [sp, #44]	; 0x2c
	*conv = (struct conversion) {
     bd0:	9308      	str	r3, [sp, #32]
     bd2:	9309      	str	r3, [sp, #36]	; 0x24
     bd4:	930a      	str	r3, [sp, #40]	; 0x28
	++sp;
     bd6:	f10a 0801 	add.w	r8, sl, #1
	if (*sp == '%') {
     bda:	f89a 3001 	ldrb.w	r3, [sl, #1]
     bde:	2b25      	cmp	r3, #37	; 0x25
     be0:	d001      	beq.n	be6 <cbvprintf+0x4e>
	bool loop = true;
     be2:	2701      	movs	r7, #1
     be4:	e02c      	b.n	c40 <cbvprintf+0xa8>
		conv->specifier = *sp++;
     be6:	f10a 0802 	add.w	r8, sl, #2
     bea:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
		return sp;
     bee:	e1a8      	b.n	f42 <cbvprintf+0x3aa>
			conv->flag_dash = true;
     bf0:	f89d 3020 	ldrb.w	r3, [sp, #32]
     bf4:	f043 0304 	orr.w	r3, r3, #4
     bf8:	f88d 3020 	strb.w	r3, [sp, #32]
		if (loop) {
     bfc:	b1ff      	cbz	r7, c3e <cbvprintf+0xa6>
			++sp;
     bfe:	f108 0801 	add.w	r8, r8, #1
     c02:	e01c      	b.n	c3e <cbvprintf+0xa6>
			conv->flag_plus = true;
     c04:	f89d 3020 	ldrb.w	r3, [sp, #32]
     c08:	f043 0308 	orr.w	r3, r3, #8
     c0c:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     c10:	e7f4      	b.n	bfc <cbvprintf+0x64>
			conv->flag_space = true;
     c12:	f89d 3020 	ldrb.w	r3, [sp, #32]
     c16:	f043 0310 	orr.w	r3, r3, #16
     c1a:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     c1e:	e7ed      	b.n	bfc <cbvprintf+0x64>
			conv->flag_hash = true;
     c20:	f89d 3020 	ldrb.w	r3, [sp, #32]
     c24:	f043 0320 	orr.w	r3, r3, #32
     c28:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     c2c:	e7e6      	b.n	bfc <cbvprintf+0x64>
			conv->flag_zero = true;
     c2e:	f89d 3020 	ldrb.w	r3, [sp, #32]
     c32:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     c36:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     c3a:	e7df      	b.n	bfc <cbvprintf+0x64>
		switch (*sp) {
     c3c:	2700      	movs	r7, #0
	} while (loop);
     c3e:	b34f      	cbz	r7, c94 <cbvprintf+0xfc>
		switch (*sp) {
     c40:	f898 3000 	ldrb.w	r3, [r8]
     c44:	3b20      	subs	r3, #32
     c46:	2b10      	cmp	r3, #16
     c48:	d8f8      	bhi.n	c3c <cbvprintf+0xa4>
     c4a:	a201      	add	r2, pc, #4	; (adr r2, c50 <cbvprintf+0xb8>)
     c4c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     c50:	00000c13 	.word	0x00000c13
     c54:	00000c3d 	.word	0x00000c3d
     c58:	00000c3d 	.word	0x00000c3d
     c5c:	00000c21 	.word	0x00000c21
     c60:	00000c3d 	.word	0x00000c3d
     c64:	00000c3d 	.word	0x00000c3d
     c68:	00000c3d 	.word	0x00000c3d
     c6c:	00000c3d 	.word	0x00000c3d
     c70:	00000c3d 	.word	0x00000c3d
     c74:	00000c3d 	.word	0x00000c3d
     c78:	00000c3d 	.word	0x00000c3d
     c7c:	00000c05 	.word	0x00000c05
     c80:	00000c3d 	.word	0x00000c3d
     c84:	00000bf1 	.word	0x00000bf1
     c88:	00000c3d 	.word	0x00000c3d
     c8c:	00000c3d 	.word	0x00000c3d
     c90:	00000c2f 	.word	0x00000c2f
	if (conv->flag_zero && conv->flag_dash) {
     c94:	f89d 3020 	ldrb.w	r3, [sp, #32]
     c98:	f003 0344 	and.w	r3, r3, #68	; 0x44
     c9c:	2b44      	cmp	r3, #68	; 0x44
     c9e:	d06d      	beq.n	d7c <cbvprintf+0x1e4>
	sp = extract_width(conv, sp);
     ca0:	f8cd 8014 	str.w	r8, [sp, #20]
	conv->width_present = true;
     ca4:	f89d 3020 	ldrb.w	r3, [sp, #32]
     ca8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
     cac:	f88d 3020 	strb.w	r3, [sp, #32]
	if (*sp == '*') {
     cb0:	f898 3000 	ldrb.w	r3, [r8]
     cb4:	2b2a      	cmp	r3, #42	; 0x2a
     cb6:	d068      	beq.n	d8a <cbvprintf+0x1f2>
	size_t width = extract_decimal(&sp);
     cb8:	a805      	add	r0, sp, #20
     cba:	f006 fbd9 	bl	7470 <extract_decimal>
	if (sp != wp) {
     cbe:	9b05      	ldr	r3, [sp, #20]
     cc0:	4598      	cmp	r8, r3
     cc2:	d012      	beq.n	cea <cbvprintf+0x152>
		conv->width_present = true;
     cc4:	f89d 3020 	ldrb.w	r3, [sp, #32]
     cc8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
     ccc:	f88d 3020 	strb.w	r3, [sp, #32]
		conv->width_value = width;
     cd0:	9009      	str	r0, [sp, #36]	; 0x24
		conv->unsupported |= ((conv->width_value < 0)
     cd2:	f3c3 0340 	ubfx	r3, r3, #1, #1
				      || (width != (size_t)conv->width_value));
     cd6:	2800      	cmp	r0, #0
     cd8:	db60      	blt.n	d9c <cbvprintf+0x204>
     cda:	2200      	movs	r2, #0
		conv->unsupported |= ((conv->width_value < 0)
     cdc:	4313      	orrs	r3, r2
     cde:	f89d 2020 	ldrb.w	r2, [sp, #32]
     ce2:	f363 0241 	bfi	r2, r3, #1, #1
     ce6:	f88d 2020 	strb.w	r2, [sp, #32]
	return sp;
     cea:	9b05      	ldr	r3, [sp, #20]
	sp = extract_prec(conv, sp);
     cec:	9305      	str	r3, [sp, #20]
	conv->prec_present = (*sp == '.');
     cee:	781b      	ldrb	r3, [r3, #0]
     cf0:	2b2e      	cmp	r3, #46	; 0x2e
     cf2:	bf14      	ite	ne
     cf4:	2300      	movne	r3, #0
     cf6:	2301      	moveq	r3, #1
     cf8:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
     cfc:	f363 0241 	bfi	r2, r3, #1, #1
     d00:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
	if (!conv->prec_present) {
     d04:	2b00      	cmp	r3, #0
     d06:	d04b      	beq.n	da0 <cbvprintf+0x208>
	++sp;
     d08:	9b05      	ldr	r3, [sp, #20]
     d0a:	1c5a      	adds	r2, r3, #1
     d0c:	9205      	str	r2, [sp, #20]
	if (*sp == '*') {
     d0e:	785b      	ldrb	r3, [r3, #1]
     d10:	2b2a      	cmp	r3, #42	; 0x2a
     d12:	d048      	beq.n	da6 <cbvprintf+0x20e>
	size_t prec = extract_decimal(&sp);
     d14:	a805      	add	r0, sp, #20
     d16:	f006 fbab 	bl	7470 <extract_decimal>
	conv->prec_value = prec;
     d1a:	900a      	str	r0, [sp, #40]	; 0x28
	conv->unsupported |= ((conv->prec_value < 0)
     d1c:	f89d 3020 	ldrb.w	r3, [sp, #32]
     d20:	f3c3 0340 	ubfx	r3, r3, #1, #1
			      || (prec != (size_t)conv->prec_value));
     d24:	2800      	cmp	r0, #0
     d26:	db47      	blt.n	db8 <cbvprintf+0x220>
     d28:	2200      	movs	r2, #0
	conv->unsupported |= ((conv->prec_value < 0)
     d2a:	4313      	orrs	r3, r2
     d2c:	f89d 2020 	ldrb.w	r2, [sp, #32]
     d30:	f363 0241 	bfi	r2, r3, #1, #1
     d34:	f88d 2020 	strb.w	r2, [sp, #32]
	return sp;
     d38:	f8dd 8014 	ldr.w	r8, [sp, #20]
	switch (*sp) {
     d3c:	f898 3000 	ldrb.w	r3, [r8]
     d40:	3b4c      	subs	r3, #76	; 0x4c
     d42:	2b2e      	cmp	r3, #46	; 0x2e
     d44:	f200 80dc 	bhi.w	f00 <cbvprintf+0x368>
     d48:	e8df f003 	tbb	[pc, r3]
     d4c:	dadadaca 	.word	0xdadadaca
     d50:	dadadada 	.word	0xdadadada
     d54:	dadadada 	.word	0xdadadada
     d58:	dadadada 	.word	0xdadadada
     d5c:	dadadada 	.word	0xdadadada
     d60:	dadadada 	.word	0xdadadada
     d64:	dadadada 	.word	0xdadadada
     d68:	da6ada38 	.word	0xda6ada38
     d6c:	dadada51 	.word	0xdadada51
     d70:	dadadada 	.word	0xdadadada
     d74:	dadadac0 	.word	0xdadadac0
     d78:	dada      	.short	0xdada
     d7a:	b6          	.byte	0xb6
     d7b:	00          	.byte	0x00
		conv->flag_zero = false;
     d7c:	f89d 3020 	ldrb.w	r3, [sp, #32]
     d80:	f36f 1386 	bfc	r3, #6, #1
     d84:	f88d 3020 	strb.w	r3, [sp, #32]
     d88:	e78a      	b.n	ca0 <cbvprintf+0x108>
		conv->width_star = true;
     d8a:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     d8e:	f043 0301 	orr.w	r3, r3, #1
     d92:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		return ++sp;
     d96:	4643      	mov	r3, r8
     d98:	3301      	adds	r3, #1
     d9a:	e7a7      	b.n	cec <cbvprintf+0x154>
				      || (width != (size_t)conv->width_value));
     d9c:	2201      	movs	r2, #1
     d9e:	e79d      	b.n	cdc <cbvprintf+0x144>
		return sp;
     da0:	f8dd 8014 	ldr.w	r8, [sp, #20]
     da4:	e7ca      	b.n	d3c <cbvprintf+0x1a4>
		conv->prec_star = true;
     da6:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     daa:	f043 0304 	orr.w	r3, r3, #4
     dae:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		return ++sp;
     db2:	f102 0801 	add.w	r8, r2, #1
     db6:	e7c1      	b.n	d3c <cbvprintf+0x1a4>
			      || (prec != (size_t)conv->prec_value));
     db8:	2201      	movs	r2, #1
     dba:	e7b6      	b.n	d2a <cbvprintf+0x192>
		if (*++sp == 'h') {
     dbc:	f108 0201 	add.w	r2, r8, #1
     dc0:	f898 3001 	ldrb.w	r3, [r8, #1]
     dc4:	2b68      	cmp	r3, #104	; 0x68
     dc6:	d008      	beq.n	dda <cbvprintf+0x242>
			conv->length_mod = LENGTH_H;
     dc8:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     dcc:	2102      	movs	r1, #2
     dce:	f361 03c6 	bfi	r3, r1, #3, #4
     dd2:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		if (*++sp == 'h') {
     dd6:	4690      	mov	r8, r2
     dd8:	e02b      	b.n	e32 <cbvprintf+0x29a>
			conv->length_mod = LENGTH_HH;
     dda:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     dde:	2201      	movs	r2, #1
     de0:	f362 03c6 	bfi	r3, r2, #3, #4
     de4:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
			++sp;
     de8:	f108 0802 	add.w	r8, r8, #2
     dec:	e021      	b.n	e32 <cbvprintf+0x29a>
		if (*++sp == 'l') {
     dee:	f108 0201 	add.w	r2, r8, #1
     df2:	f898 3001 	ldrb.w	r3, [r8, #1]
     df6:	2b6c      	cmp	r3, #108	; 0x6c
     df8:	d008      	beq.n	e0c <cbvprintf+0x274>
			conv->length_mod = LENGTH_L;
     dfa:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     dfe:	2103      	movs	r1, #3
     e00:	f361 03c6 	bfi	r3, r1, #3, #4
     e04:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		if (*++sp == 'l') {
     e08:	4690      	mov	r8, r2
     e0a:	e012      	b.n	e32 <cbvprintf+0x29a>
			conv->length_mod = LENGTH_LL;
     e0c:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     e10:	2204      	movs	r2, #4
     e12:	f362 03c6 	bfi	r3, r2, #3, #4
     e16:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
			++sp;
     e1a:	f108 0802 	add.w	r8, r8, #2
     e1e:	e008      	b.n	e32 <cbvprintf+0x29a>
		conv->length_mod = LENGTH_J;
     e20:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     e24:	2205      	movs	r2, #5
     e26:	f362 03c6 	bfi	r3, r2, #3, #4
     e2a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     e2e:	f108 0801 	add.w	r8, r8, #1
	conv->specifier = *sp++;
     e32:	f818 3b01 	ldrb.w	r3, [r8], #1
     e36:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
	switch (conv->specifier) {
     e3a:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
     e3e:	2a37      	cmp	r2, #55	; 0x37
     e40:	f200 8150 	bhi.w	10e4 <CONFIG_FPROTECT_BLOCK_SIZE+0xe4>
     e44:	e8df f012 	tbh	[pc, r2, lsl #1]
     e48:	014e0126 	.word	0x014e0126
     e4c:	014e014e 	.word	0x014e014e
     e50:	01260126 	.word	0x01260126
     e54:	014e0126 	.word	0x014e0126
     e58:	014e014e 	.word	0x014e014e
     e5c:	014e014e 	.word	0x014e014e
     e60:	014e014e 	.word	0x014e014e
     e64:	014e014e 	.word	0x014e014e
     e68:	014e014e 	.word	0x014e014e
     e6c:	014e014e 	.word	0x014e014e
     e70:	014e014e 	.word	0x014e014e
     e74:	0113014e 	.word	0x0113014e
     e78:	014e014e 	.word	0x014e014e
     e7c:	014e014e 	.word	0x014e014e
     e80:	014e014e 	.word	0x014e014e
     e84:	014e014e 	.word	0x014e014e
     e88:	014e0126 	.word	0x014e0126
     e8c:	00630113 	.word	0x00630113
     e90:	01260126 	.word	0x01260126
     e94:	014e0126 	.word	0x014e0126
     e98:	014e0063 	.word	0x014e0063
     e9c:	014e014e 	.word	0x014e014e
     ea0:	012f014e 	.word	0x012f014e
     ea4:	013f0113 	.word	0x013f0113
     ea8:	014e014e 	.word	0x014e014e
     eac:	014e013f 	.word	0x014e013f
     eb0:	014e0113 	.word	0x014e0113
     eb4:	0113014e 	.word	0x0113014e
		conv->length_mod = LENGTH_Z;
     eb8:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     ebc:	2206      	movs	r2, #6
     ebe:	f362 03c6 	bfi	r3, r2, #3, #4
     ec2:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     ec6:	f108 0801 	add.w	r8, r8, #1
		break;
     eca:	e7b2      	b.n	e32 <cbvprintf+0x29a>
		conv->length_mod = LENGTH_T;
     ecc:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     ed0:	2207      	movs	r2, #7
     ed2:	f362 03c6 	bfi	r3, r2, #3, #4
     ed6:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     eda:	f108 0801 	add.w	r8, r8, #1
		break;
     ede:	e7a8      	b.n	e32 <cbvprintf+0x29a>
		conv->length_mod = LENGTH_UPPER_L;
     ee0:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     ee4:	2208      	movs	r2, #8
     ee6:	f362 03c6 	bfi	r3, r2, #3, #4
     eea:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     eee:	f108 0801 	add.w	r8, r8, #1
		conv->unsupported = true;
     ef2:	f89d 3020 	ldrb.w	r3, [sp, #32]
     ef6:	f043 0302 	orr.w	r3, r3, #2
     efa:	f88d 3020 	strb.w	r3, [sp, #32]
		break;
     efe:	e798      	b.n	e32 <cbvprintf+0x29a>
		conv->length_mod = LENGTH_NONE;
     f00:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     f04:	f36f 03c6 	bfc	r3, #3, #4
     f08:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		break;
     f0c:	e791      	b.n	e32 <cbvprintf+0x29a>
		conv->specifier_cat = SPECIFIER_SINT;
     f0e:	f89d 2022 	ldrb.w	r2, [sp, #34]	; 0x22
     f12:	2101      	movs	r1, #1
     f14:	f361 0202 	bfi	r2, r1, #0, #3
     f18:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
		if (conv->length_mod == LENGTH_UPPER_L) {
     f1c:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
     f20:	f002 0278 	and.w	r2, r2, #120	; 0x78
     f24:	2a40      	cmp	r2, #64	; 0x40
     f26:	f000 80aa 	beq.w	107e <CONFIG_FPROTECT_BLOCK_SIZE+0x7e>
		if (conv->specifier == 'c') {
     f2a:	2b63      	cmp	r3, #99	; 0x63
     f2c:	f000 80ae 	beq.w	108c <CONFIG_FPROTECT_BLOCK_SIZE+0x8c>
	conv->unsupported |= unsupported;
     f30:	f89d 3020 	ldrb.w	r3, [sp, #32]
     f34:	f3c3 0240 	ubfx	r2, r3, #1, #1
     f38:	4317      	orrs	r7, r2
     f3a:	f367 0341 	bfi	r3, r7, #1, #1
     f3e:	f88d 3020 	strb.w	r3, [sp, #32]
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
     f42:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     f46:	f013 0f01 	tst.w	r3, #1
     f4a:	f000 80da 	beq.w	1102 <CONFIG_FPROTECT_BLOCK_SIZE+0x102>
			width = va_arg(ap, int);
     f4e:	9b03      	ldr	r3, [sp, #12]
     f50:	1d1a      	adds	r2, r3, #4
     f52:	9203      	str	r2, [sp, #12]
     f54:	681f      	ldr	r7, [r3, #0]

			if (width < 0) {
     f56:	2f00      	cmp	r7, #0
     f58:	f2c0 80cb 	blt.w	10f2 <CONFIG_FPROTECT_BLOCK_SIZE+0xf2>

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
     f5c:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     f60:	f013 0f04 	tst.w	r3, #4
     f64:	f000 80df 	beq.w	1126 <CONFIG_FPROTECT_BLOCK_SIZE+0x126>
			int arg = va_arg(ap, int);
     f68:	9b03      	ldr	r3, [sp, #12]
     f6a:	1d1a      	adds	r2, r3, #4
     f6c:	9203      	str	r2, [sp, #12]
     f6e:	f8d3 b000 	ldr.w	fp, [r3]

			if (arg < 0) {
     f72:	f1bb 0f00 	cmp.w	fp, #0
     f76:	f2c0 80cd 	blt.w	1114 <CONFIG_FPROTECT_BLOCK_SIZE+0x114>
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv->pad0_value = 0;
     f7a:	2300      	movs	r3, #0
     f7c:	9309      	str	r3, [sp, #36]	; 0x24
		conv->pad0_pre_exp = 0;
     f7e:	930a      	str	r3, [sp, #40]	; 0x28
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
     f80:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
     f84:	f003 0307 	and.w	r3, r3, #7
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
     f88:	f89d 1021 	ldrb.w	r1, [sp, #33]	; 0x21
     f8c:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
     f90:	2b01      	cmp	r3, #1
     f92:	f000 80d1 	beq.w	1138 <CONFIG_FPROTECT_BLOCK_SIZE+0x138>
			if (length_mod == LENGTH_HH) {
				value->sint = (char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
     f96:	2b02      	cmp	r3, #2
     f98:	f000 8116 	beq.w	11c8 <CONFIG_FPROTECT_BLOCK_SIZE+0x1c8>
			if (length_mod == LENGTH_HH) {
				value->uint = (unsigned char)value->uint;
			} else if (length_mod == LENGTH_H) {
				value->uint = (unsigned short)value->uint;
			}
		} else if (specifier_cat == SPECIFIER_FP) {
     f9c:	2b04      	cmp	r3, #4
     f9e:	f000 8167 	beq.w	1270 <CONFIG_FPROTECT_BLOCK_SIZE+0x270>
			if (length_mod == LENGTH_UPPER_L) {
				value->ldbl = va_arg(ap, long double);
			} else {
				value->dbl = va_arg(ap, double);
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
     fa2:	2b03      	cmp	r3, #3
     fa4:	f000 817e 	beq.w	12a4 <CONFIG_FPROTECT_BLOCK_SIZE+0x2a4>
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
     fa8:	f89d 9020 	ldrb.w	r9, [sp, #32]
     fac:	f019 0303 	ands.w	r3, r9, #3
     fb0:	9302      	str	r3, [sp, #8]
     fb2:	f040 817d 	bne.w	12b0 <CONFIG_FPROTECT_BLOCK_SIZE+0x2b0>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
     fb6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
     fba:	3b25      	subs	r3, #37	; 0x25
     fbc:	2b53      	cmp	r3, #83	; 0x53
     fbe:	f200 8233 	bhi.w	1428 <CONFIG_FPROTECT_BLOCK_SIZE+0x428>
     fc2:	e8df f013 	tbh	[pc, r3, lsl #1]
     fc6:	0181      	.short	0x0181
     fc8:	02310231 	.word	0x02310231
     fcc:	02310231 	.word	0x02310231
     fd0:	02310231 	.word	0x02310231
     fd4:	02310231 	.word	0x02310231
     fd8:	02310231 	.word	0x02310231
     fdc:	02310231 	.word	0x02310231
     fe0:	02310231 	.word	0x02310231
     fe4:	02310231 	.word	0x02310231
     fe8:	02310231 	.word	0x02310231
     fec:	02310231 	.word	0x02310231
     ff0:	02310231 	.word	0x02310231
     ff4:	02310231 	.word	0x02310231
     ff8:	02310231 	.word	0x02310231
     ffc:	02310231 	.word	0x02310231
    1000:	02310231 	.word	0x02310231
    1004:	02310231 	.word	0x02310231
    1008:	02310231 	.word	0x02310231
    100c:	02310231 	.word	0x02310231
    1010:	02310231 	.word	0x02310231
    1014:	02310231 	.word	0x02310231
    1018:	02310231 	.word	0x02310231
    101c:	02310231 	.word	0x02310231
    1020:	02310231 	.word	0x02310231
    1024:	02310231 	.word	0x02310231
    1028:	02310231 	.word	0x02310231
    102c:	023101c7 	.word	0x023101c7
    1030:	02310231 	.word	0x02310231
    1034:	02310231 	.word	0x02310231
    1038:	02310231 	.word	0x02310231
    103c:	02310231 	.word	0x02310231
    1040:	01a10231 	.word	0x01a10231
    1044:	023101ab 	.word	0x023101ab
    1048:	02310231 	.word	0x02310231
    104c:	01ab0231 	.word	0x01ab0231
    1050:	02310231 	.word	0x02310231
    1054:	02310231 	.word	0x02310231
    1058:	01c70208 	.word	0x01c70208
    105c:	023101ea 	.word	0x023101ea
    1060:	018f0231 	.word	0x018f0231
    1064:	01c70231 	.word	0x01c70231
    1068:	02310231 	.word	0x02310231
    106c:	01c7      	.short	0x01c7
		conv->specifier_cat = SPECIFIER_UINT;
    106e:	f89d 2022 	ldrb.w	r2, [sp, #34]	; 0x22
    1072:	2102      	movs	r1, #2
    1074:	f361 0202 	bfi	r2, r1, #0, #3
    1078:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
    107c:	e74e      	b.n	f1c <cbvprintf+0x384>
			conv->invalid = true;
    107e:	f89d 1020 	ldrb.w	r1, [sp, #32]
    1082:	f041 0101 	orr.w	r1, r1, #1
    1086:	f88d 1020 	strb.w	r1, [sp, #32]
    108a:	e74e      	b.n	f2a <cbvprintf+0x392>
			unsupported = (conv->length_mod != LENGTH_NONE);
    108c:	1e17      	subs	r7, r2, #0
    108e:	bf18      	it	ne
    1090:	2701      	movne	r7, #1
    1092:	e74d      	b.n	f30 <cbvprintf+0x398>
		conv->specifier_cat = SPECIFIER_FP;
    1094:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    1098:	2204      	movs	r2, #4
    109a:	f362 0302 	bfi	r3, r2, #0, #3
    109e:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
			unsupported = true;
    10a2:	2701      	movs	r7, #1
			break;
    10a4:	e744      	b.n	f30 <cbvprintf+0x398>
		conv->specifier_cat = SPECIFIER_PTR;
    10a6:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    10aa:	2203      	movs	r2, #3
    10ac:	f362 0302 	bfi	r3, r2, #0, #3
    10b0:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
		if (conv->length_mod == LENGTH_UPPER_L) {
    10b4:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    10b8:	f003 0378 	and.w	r3, r3, #120	; 0x78
    10bc:	2b40      	cmp	r3, #64	; 0x40
    10be:	f47f af37 	bne.w	f30 <cbvprintf+0x398>
			unsupported = true;
    10c2:	2701      	movs	r7, #1
    10c4:	e734      	b.n	f30 <cbvprintf+0x398>
		conv->specifier_cat = SPECIFIER_PTR;
    10c6:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    10ca:	2203      	movs	r2, #3
    10cc:	f362 0302 	bfi	r3, r2, #0, #3
    10d0:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
		if (conv->length_mod != LENGTH_NONE) {
    10d4:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    10d8:	f013 0f78 	tst.w	r3, #120	; 0x78
    10dc:	f43f af28 	beq.w	f30 <cbvprintf+0x398>
			unsupported = true;
    10e0:	2701      	movs	r7, #1
    10e2:	e725      	b.n	f30 <cbvprintf+0x398>
		conv->invalid = true;
    10e4:	f89d 3020 	ldrb.w	r3, [sp, #32]
    10e8:	f043 0301 	orr.w	r3, r3, #1
    10ec:	f88d 3020 	strb.w	r3, [sp, #32]
		break;
    10f0:	e71e      	b.n	f30 <cbvprintf+0x398>
				conv->flag_dash = true;
    10f2:	f89d 3020 	ldrb.w	r3, [sp, #32]
    10f6:	f043 0304 	orr.w	r3, r3, #4
    10fa:	f88d 3020 	strb.w	r3, [sp, #32]
				width = -width;
    10fe:	427f      	negs	r7, r7
    1100:	e72c      	b.n	f5c <cbvprintf+0x3c4>
		} else if (conv->width_present) {
    1102:	f99d 3020 	ldrsb.w	r3, [sp, #32]
    1106:	2b00      	cmp	r3, #0
    1108:	db02      	blt.n	1110 <CONFIG_FPROTECT_BLOCK_SIZE+0x110>
		int width = -1;
    110a:	f04f 37ff 	mov.w	r7, #4294967295
    110e:	e725      	b.n	f5c <cbvprintf+0x3c4>
			width = conv->width_value;
    1110:	9f09      	ldr	r7, [sp, #36]	; 0x24
    1112:	e723      	b.n	f5c <cbvprintf+0x3c4>
				conv->prec_present = false;
    1114:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    1118:	f36f 0341 	bfc	r3, #1, #1
    111c:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		int precision = -1;
    1120:	f04f 3bff 	mov.w	fp, #4294967295
    1124:	e729      	b.n	f7a <cbvprintf+0x3e2>
		} else if (conv->prec_present) {
    1126:	f013 0f02 	tst.w	r3, #2
    112a:	d002      	beq.n	1132 <CONFIG_FPROTECT_BLOCK_SIZE+0x132>
			precision = conv->prec_value;
    112c:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    1130:	e723      	b.n	f7a <cbvprintf+0x3e2>
		int precision = -1;
    1132:	f04f 3bff 	mov.w	fp, #4294967295
    1136:	e720      	b.n	f7a <cbvprintf+0x3e2>
			switch (length_mod) {
    1138:	1ecb      	subs	r3, r1, #3
    113a:	2b04      	cmp	r3, #4
    113c:	d804      	bhi.n	1148 <CONFIG_FPROTECT_BLOCK_SIZE+0x148>
    113e:	e8df f003 	tbb	[pc, r3]
    1142:	1d0b      	.short	0x1d0b
    1144:	3529      	.short	0x3529
    1146:	35          	.byte	0x35
    1147:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
    1148:	9b03      	ldr	r3, [sp, #12]
    114a:	1d1a      	adds	r2, r3, #4
    114c:	9203      	str	r2, [sp, #12]
    114e:	681a      	ldr	r2, [r3, #0]
    1150:	17d3      	asrs	r3, r2, #31
    1152:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
    1156:	e006      	b.n	1166 <CONFIG_FPROTECT_BLOCK_SIZE+0x166>
					value->sint = va_arg(ap, long);
    1158:	9b03      	ldr	r3, [sp, #12]
    115a:	1d1a      	adds	r2, r3, #4
    115c:	9203      	str	r2, [sp, #12]
    115e:	681a      	ldr	r2, [r3, #0]
    1160:	17d3      	asrs	r3, r2, #31
    1162:	e9cd 2306 	strd	r2, r3, [sp, #24]
			if (length_mod == LENGTH_HH) {
    1166:	2901      	cmp	r1, #1
    1168:	d028      	beq.n	11bc <CONFIG_FPROTECT_BLOCK_SIZE+0x1bc>
			} else if (length_mod == LENGTH_H) {
    116a:	2902      	cmp	r1, #2
    116c:	f47f af1c 	bne.w	fa8 <cbvprintf+0x410>
				value->sint = (short)value->sint;
    1170:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
    1174:	17d3      	asrs	r3, r2, #31
    1176:	e9cd 2306 	strd	r2, r3, [sp, #24]
    117a:	e715      	b.n	fa8 <cbvprintf+0x410>
					(sint_value_type)va_arg(ap, long long);
    117c:	9b03      	ldr	r3, [sp, #12]
    117e:	3307      	adds	r3, #7
    1180:	f023 0307 	bic.w	r3, r3, #7
    1184:	f103 0208 	add.w	r2, r3, #8
    1188:	9203      	str	r2, [sp, #12]
    118a:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
    118e:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
    1192:	e7e8      	b.n	1166 <CONFIG_FPROTECT_BLOCK_SIZE+0x166>
					(sint_value_type)va_arg(ap, intmax_t);
    1194:	9b03      	ldr	r3, [sp, #12]
    1196:	3307      	adds	r3, #7
    1198:	f023 0307 	bic.w	r3, r3, #7
    119c:	f103 0208 	add.w	r2, r3, #8
    11a0:	9203      	str	r2, [sp, #12]
    11a2:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
    11a6:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
    11aa:	e7dc      	b.n	1166 <CONFIG_FPROTECT_BLOCK_SIZE+0x166>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    11ac:	9b03      	ldr	r3, [sp, #12]
    11ae:	1d1a      	adds	r2, r3, #4
    11b0:	9203      	str	r2, [sp, #12]
    11b2:	681a      	ldr	r2, [r3, #0]
    11b4:	17d3      	asrs	r3, r2, #31
				value->sint =
    11b6:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
    11ba:	e7d4      	b.n	1166 <CONFIG_FPROTECT_BLOCK_SIZE+0x166>
				value->sint = (char)value->sint;
    11bc:	f89d 3018 	ldrb.w	r3, [sp, #24]
    11c0:	9306      	str	r3, [sp, #24]
    11c2:	2300      	movs	r3, #0
    11c4:	9307      	str	r3, [sp, #28]
    11c6:	e6ef      	b.n	fa8 <cbvprintf+0x410>
			switch (length_mod) {
    11c8:	1ecb      	subs	r3, r1, #3
    11ca:	2b04      	cmp	r3, #4
    11cc:	d804      	bhi.n	11d8 <CONFIG_FPROTECT_BLOCK_SIZE+0x1d8>
    11ce:	e8df f003 	tbb	[pc, r3]
    11d2:	1f0b      	.short	0x1f0b
    11d4:	4135      	.short	0x4135
    11d6:	41          	.byte	0x41
    11d7:	00          	.byte	0x00
				value->uint = va_arg(ap, unsigned int);
    11d8:	9b03      	ldr	r3, [sp, #12]
    11da:	1d1a      	adds	r2, r3, #4
    11dc:	9203      	str	r2, [sp, #12]
    11de:	681b      	ldr	r3, [r3, #0]
    11e0:	9306      	str	r3, [sp, #24]
    11e2:	2300      	movs	r3, #0
    11e4:	9307      	str	r3, [sp, #28]
				break;
    11e6:	e01e      	b.n	1226 <CONFIG_FPROTECT_BLOCK_SIZE+0x226>
				    && (conv->specifier == 'c')) {
    11e8:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
				if ((!WCHAR_IS_SIGNED)
    11ec:	2b63      	cmp	r3, #99	; 0x63
    11ee:	d007      	beq.n	1200 <CONFIG_FPROTECT_BLOCK_SIZE+0x200>
					value->uint = va_arg(ap, unsigned long);
    11f0:	9b03      	ldr	r3, [sp, #12]
    11f2:	1d1a      	adds	r2, r3, #4
    11f4:	9203      	str	r2, [sp, #12]
    11f6:	681b      	ldr	r3, [r3, #0]
    11f8:	9306      	str	r3, [sp, #24]
    11fa:	2300      	movs	r3, #0
    11fc:	9307      	str	r3, [sp, #28]
    11fe:	e012      	b.n	1226 <CONFIG_FPROTECT_BLOCK_SIZE+0x226>
					value->uint = (wchar_t)va_arg(ap,
    1200:	9b03      	ldr	r3, [sp, #12]
    1202:	1d1a      	adds	r2, r3, #4
    1204:	9203      	str	r2, [sp, #12]
    1206:	681b      	ldr	r3, [r3, #0]
    1208:	9306      	str	r3, [sp, #24]
    120a:	2300      	movs	r3, #0
    120c:	9307      	str	r3, [sp, #28]
    120e:	e00a      	b.n	1226 <CONFIG_FPROTECT_BLOCK_SIZE+0x226>
					(uint_value_type)va_arg(ap,
    1210:	9b03      	ldr	r3, [sp, #12]
    1212:	3307      	adds	r3, #7
    1214:	f023 0307 	bic.w	r3, r3, #7
    1218:	f103 0208 	add.w	r2, r3, #8
    121c:	9203      	str	r2, [sp, #12]
    121e:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
    1222:	e9cd 2306 	strd	r2, r3, [sp, #24]
			if (length_mod == LENGTH_HH) {
    1226:	2901      	cmp	r1, #1
    1228:	d01c      	beq.n	1264 <CONFIG_FPROTECT_BLOCK_SIZE+0x264>
			} else if (length_mod == LENGTH_H) {
    122a:	2902      	cmp	r1, #2
    122c:	f47f aebc 	bne.w	fa8 <cbvprintf+0x410>
				value->uint = (unsigned short)value->uint;
    1230:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    1234:	9306      	str	r3, [sp, #24]
    1236:	2300      	movs	r3, #0
    1238:	9307      	str	r3, [sp, #28]
    123a:	e6b5      	b.n	fa8 <cbvprintf+0x410>
					(uint_value_type)va_arg(ap,
    123c:	9b03      	ldr	r3, [sp, #12]
    123e:	3307      	adds	r3, #7
    1240:	f023 0307 	bic.w	r3, r3, #7
    1244:	f103 0208 	add.w	r2, r3, #8
    1248:	9203      	str	r2, [sp, #12]
    124a:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
    124e:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
    1252:	e7e8      	b.n	1226 <CONFIG_FPROTECT_BLOCK_SIZE+0x226>
					(uint_value_type)va_arg(ap, size_t);
    1254:	9b03      	ldr	r3, [sp, #12]
    1256:	1d1a      	adds	r2, r3, #4
    1258:	9203      	str	r2, [sp, #12]
    125a:	681b      	ldr	r3, [r3, #0]
				value->uint =
    125c:	9306      	str	r3, [sp, #24]
    125e:	2300      	movs	r3, #0
    1260:	9307      	str	r3, [sp, #28]
				break;
    1262:	e7e0      	b.n	1226 <CONFIG_FPROTECT_BLOCK_SIZE+0x226>
				value->uint = (unsigned char)value->uint;
    1264:	f89d 3018 	ldrb.w	r3, [sp, #24]
    1268:	9306      	str	r3, [sp, #24]
    126a:	2300      	movs	r3, #0
    126c:	9307      	str	r3, [sp, #28]
    126e:	e69b      	b.n	fa8 <cbvprintf+0x410>
			if (length_mod == LENGTH_UPPER_L) {
    1270:	2908      	cmp	r1, #8
    1272:	d00b      	beq.n	128c <CONFIG_FPROTECT_BLOCK_SIZE+0x28c>
				value->dbl = va_arg(ap, double);
    1274:	9b03      	ldr	r3, [sp, #12]
    1276:	3307      	adds	r3, #7
    1278:	f023 0307 	bic.w	r3, r3, #7
    127c:	f103 0208 	add.w	r2, r3, #8
    1280:	9203      	str	r2, [sp, #12]
    1282:	e9d3 2300 	ldrd	r2, r3, [r3]
    1286:	e9cd 2306 	strd	r2, r3, [sp, #24]
    128a:	e68d      	b.n	fa8 <cbvprintf+0x410>
				value->ldbl = va_arg(ap, long double);
    128c:	9b03      	ldr	r3, [sp, #12]
    128e:	3307      	adds	r3, #7
    1290:	f023 0307 	bic.w	r3, r3, #7
    1294:	f103 0208 	add.w	r2, r3, #8
    1298:	9203      	str	r2, [sp, #12]
    129a:	e9d3 2300 	ldrd	r2, r3, [r3]
    129e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    12a2:	e681      	b.n	fa8 <cbvprintf+0x410>
			value->ptr = va_arg(ap, void *);
    12a4:	9b03      	ldr	r3, [sp, #12]
    12a6:	1d1a      	adds	r2, r3, #4
    12a8:	9203      	str	r2, [sp, #12]
    12aa:	681b      	ldr	r3, [r3, #0]
    12ac:	9306      	str	r3, [sp, #24]
    12ae:	e67b      	b.n	fa8 <cbvprintf+0x410>
			OUTS(sp, fp);
    12b0:	4643      	mov	r3, r8
    12b2:	4652      	mov	r2, sl
    12b4:	4629      	mov	r1, r5
    12b6:	4630      	mov	r0, r6
    12b8:	f006 f957 	bl	756a <outs>
    12bc:	2800      	cmp	r0, #0
    12be:	f2c0 814f 	blt.w	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    12c2:	4404      	add	r4, r0
		fp = extract_conversion(conv, sp);
    12c4:	46c2      	mov	sl, r8
			continue;
    12c6:	e46f      	b.n	ba8 <cbvprintf+0x10>
		case '%':
			OUTC('%');
    12c8:	4629      	mov	r1, r5
    12ca:	2025      	movs	r0, #37	; 0x25
    12cc:	47b0      	blx	r6
    12ce:	2800      	cmp	r0, #0
    12d0:	f2c0 8146 	blt.w	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    12d4:	3401      	adds	r4, #1
		char sign = 0;
    12d6:	f8dd 9008 	ldr.w	r9, [sp, #8]
		const char *bpe = buf + sizeof(buf);
    12da:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
		const char *bps = NULL;
    12de:	f04f 0a00 	mov.w	sl, #0
			break;
    12e2:	e0a7      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
		case 's': {
			bps = (const char *)value->ptr;
    12e4:	f8dd a018 	ldr.w	sl, [sp, #24]

			size_t len;

			if (precision >= 0) {
    12e8:	f1bb 0f00 	cmp.w	fp, #0
    12ec:	db08      	blt.n	1300 <CONFIG_FPROTECT_BLOCK_SIZE+0x300>
				len = strnlen(bps, precision);
    12ee:	4659      	mov	r1, fp
    12f0:	4650      	mov	r0, sl
    12f2:	f006 fd35 	bl	7d60 <strnlen>
			} else {
				len = strlen(bps);
			}

			bpe = bps + len;
    12f6:	eb0a 0b00 	add.w	fp, sl, r0
		char sign = 0;
    12fa:	f8dd 9008 	ldr.w	r9, [sp, #8]
			precision = -1;

			break;
    12fe:	e099      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
				len = strlen(bps);
    1300:	4650      	mov	r0, sl
    1302:	f006 fd25 	bl	7d50 <strlen>
    1306:	e7f6      	b.n	12f6 <CONFIG_FPROTECT_BLOCK_SIZE+0x2f6>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    1308:	9b06      	ldr	r3, [sp, #24]
    130a:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		char sign = 0;
    130e:	f8dd 9008 	ldr.w	r9, [sp, #8]
			bpe = buf + 1;
    1312:	f10d 0b31 	add.w	fp, sp, #49	; 0x31
			bps = buf;
    1316:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
			break;
    131a:	e08b      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
    131c:	f019 0f08 	tst.w	r9, #8
    1320:	d105      	bne.n	132e <CONFIG_FPROTECT_BLOCK_SIZE+0x32e>
				sign = '+';
			} else if (conv->flag_space) {
    1322:	f019 0910 	ands.w	r9, r9, #16
    1326:	d004      	beq.n	1332 <CONFIG_FPROTECT_BLOCK_SIZE+0x332>
				sign = ' ';
    1328:	f04f 0920 	mov.w	r9, #32
    132c:	e001      	b.n	1332 <CONFIG_FPROTECT_BLOCK_SIZE+0x332>
				sign = '+';
    132e:	f04f 092b 	mov.w	r9, #43	; 0x2b

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
    1332:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
			if (sint < 0) {
    1336:	2a00      	cmp	r2, #0
    1338:	f173 0100 	sbcs.w	r1, r3, #0
    133c:	db02      	blt.n	1344 <CONFIG_FPROTECT_BLOCK_SIZE+0x344>
				sign = '-';
				value->uint = (uint_value_type)-sint;
			} else {
				value->uint = (uint_value_type)sint;
    133e:	e9cd 2306 	strd	r2, r3, [sp, #24]
    1342:	e009      	b.n	1358 <CONFIG_FPROTECT_BLOCK_SIZE+0x358>
				value->uint = (uint_value_type)-sint;
    1344:	4252      	negs	r2, r2
    1346:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    134a:	e9cd 2306 	strd	r2, r3, [sp, #24]
				sign = '-';
    134e:	f04f 092d 	mov.w	r9, #45	; 0x2d
    1352:	e001      	b.n	1358 <CONFIG_FPROTECT_BLOCK_SIZE+0x358>
		switch (conv->specifier) {
    1354:	f8dd 9008 	ldr.w	r9, [sp, #8]
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
    1358:	f10d 0346 	add.w	r3, sp, #70	; 0x46
    135c:	9300      	str	r3, [sp, #0]
    135e:	ab0c      	add	r3, sp, #48	; 0x30
    1360:	aa08      	add	r2, sp, #32
    1362:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
    1366:	f006 f896 	bl	7496 <encode_uint>
    136a:	4682      	mov	sl, r0
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
    136c:	f1bb 0f00 	cmp.w	fp, #0
    1370:	f2c0 8090 	blt.w	1494 <CONFIG_FPROTECT_BLOCK_SIZE+0x494>
				size_t len = bpe - bps;
    1374:	f10d 0346 	add.w	r3, sp, #70	; 0x46
    1378:	eba3 030a 	sub.w	r3, r3, sl

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
    137c:	f89d 2020 	ldrb.w	r2, [sp, #32]
    1380:	f36f 1286 	bfc	r2, #6, #1
    1384:	f88d 2020 	strb.w	r2, [sp, #32]

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
    1388:	459b      	cmp	fp, r3
    138a:	f240 8086 	bls.w	149a <CONFIG_FPROTECT_BLOCK_SIZE+0x49a>
					conv->pad0_value = precision - (int)len;
    138e:	ebab 0303 	sub.w	r3, fp, r3
    1392:	9309      	str	r3, [sp, #36]	; 0x24
		const char *bpe = buf + sizeof(buf);
    1394:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
    1398:	e04c      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
    139a:	9806      	ldr	r0, [sp, #24]
    139c:	b930      	cbnz	r0, 13ac <CONFIG_FPROTECT_BLOCK_SIZE+0x3ac>
		char sign = 0;
    139e:	f8dd 9008 	ldr.w	r9, [sp, #8]

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
    13a2:	f8df b1c4 	ldr.w	fp, [pc, #452]	; 1568 <CONFIG_FPROTECT_BLOCK_SIZE+0x568>
			bps = "(nil)";
    13a6:	f1ab 0a05 	sub.w	sl, fp, #5
    13aa:	e043      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    13ac:	f10d 0346 	add.w	r3, sp, #70	; 0x46
    13b0:	9300      	str	r3, [sp, #0]
    13b2:	ab0c      	add	r3, sp, #48	; 0x30
    13b4:	aa08      	add	r2, sp, #32
    13b6:	2100      	movs	r1, #0
    13b8:	f006 f86d 	bl	7496 <encode_uint>
    13bc:	4682      	mov	sl, r0
				conv->altform_0c = true;
    13be:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    13c2:	f043 0310 	orr.w	r3, r3, #16
    13c6:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
				conv->specifier = 'x';
    13ca:	2378      	movs	r3, #120	; 0x78
    13cc:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
		char sign = 0;
    13d0:	f8dd 9008 	ldr.w	r9, [sp, #8]
				goto prec_int_pad0;
    13d4:	e7ca      	b.n	136c <CONFIG_FPROTECT_BLOCK_SIZE+0x36c>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
    13d6:	9a06      	ldr	r2, [sp, #24]
	switch ((enum length_mod_enum)conv->length_mod) {
    13d8:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    13dc:	f3c3 03c3 	ubfx	r3, r3, #3, #4
    13e0:	2b07      	cmp	r3, #7
    13e2:	d806      	bhi.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
    13e4:	e8df f003 	tbb	[pc, r3]
    13e8:	100e0c04 	.word	0x100e0c04
    13ec:	1e1c1712 	.word	0x1e1c1712
		*(int *)dp = count;
    13f0:	6014      	str	r4, [r2, #0]
		char sign = 0;
    13f2:	f8dd 9008 	ldr.w	r9, [sp, #8]
		const char *bpe = buf + sizeof(buf);
    13f6:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
		const char *bps = NULL;
    13fa:	f04f 0a00 	mov.w	sl, #0
}
    13fe:	e019      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
		*(signed char *)dp = (signed char)count;
    1400:	7014      	strb	r4, [r2, #0]
		break;
    1402:	e7f6      	b.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
		*(short *)dp = (short)count;
    1404:	8014      	strh	r4, [r2, #0]
		break;
    1406:	e7f4      	b.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
		*(long *)dp = (long)count;
    1408:	6014      	str	r4, [r2, #0]
		break;
    140a:	e7f2      	b.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
		*(long long *)dp = (long long)count;
    140c:	4620      	mov	r0, r4
    140e:	17e1      	asrs	r1, r4, #31
    1410:	e9c2 0100 	strd	r0, r1, [r2]
		break;
    1414:	e7ed      	b.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
		*(intmax_t *)dp = (intmax_t)count;
    1416:	4620      	mov	r0, r4
    1418:	17e1      	asrs	r1, r4, #31
    141a:	e9c2 0100 	strd	r0, r1, [r2]
		break;
    141e:	e7e8      	b.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
		*(size_t *)dp = (size_t)count;
    1420:	6014      	str	r4, [r2, #0]
		break;
    1422:	e7e6      	b.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    1424:	6014      	str	r4, [r2, #0]
		break;
    1426:	e7e4      	b.n	13f2 <CONFIG_FPROTECT_BLOCK_SIZE+0x3f2>
		switch (conv->specifier) {
    1428:	f8dd 9008 	ldr.w	r9, [sp, #8]
    142c:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
    1430:	f04f 0a00 	mov.w	sl, #0
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
    1434:	f1ba 0f00 	cmp.w	sl, #0
    1438:	f000 808e 	beq.w	1558 <CONFIG_FPROTECT_BLOCK_SIZE+0x558>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
    143c:	ebab 020a 	sub.w	r2, fp, sl
		int pad_len = 0;

		if (sign != 0) {
    1440:	f1b9 0f00 	cmp.w	r9, #0
    1444:	d000      	beq.n	1448 <CONFIG_FPROTECT_BLOCK_SIZE+0x448>
			nj_len += 1U;
    1446:	3201      	adds	r2, #1
		}

		if (conv->altform_0c) {
    1448:	f89d 1022 	ldrb.w	r1, [sp, #34]	; 0x22
    144c:	f011 0f10 	tst.w	r1, #16
    1450:	d026      	beq.n	14a0 <CONFIG_FPROTECT_BLOCK_SIZE+0x4a0>
			nj_len += 2U;
    1452:	3202      	adds	r2, #2
		} else if (conv->altform_0) {
			nj_len += 1U;
		}

		nj_len += conv->pad0_value;
    1454:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1456:	4413      	add	r3, r2
		if (conv->pad_fp) {
    1458:	f011 0f40 	tst.w	r1, #64	; 0x40
    145c:	d001      	beq.n	1462 <CONFIG_FPROTECT_BLOCK_SIZE+0x462>
			nj_len += conv->pad0_pre_exp;
    145e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    1460:	4413      	add	r3, r2
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
    1462:	2f00      	cmp	r7, #0
    1464:	dd32      	ble.n	14cc <CONFIG_FPROTECT_BLOCK_SIZE+0x4cc>
			width -= (int)nj_len;
    1466:	1aff      	subs	r7, r7, r3

			if (!conv->flag_dash) {
    1468:	f89d 3020 	ldrb.w	r3, [sp, #32]
    146c:	f013 0f04 	tst.w	r3, #4
    1470:	d12c      	bne.n	14cc <CONFIG_FPROTECT_BLOCK_SIZE+0x4cc>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
    1472:	f013 0f40 	tst.w	r3, #64	; 0x40
    1476:	d018      	beq.n	14aa <CONFIG_FPROTECT_BLOCK_SIZE+0x4aa>
					if (sign != 0) {
    1478:	f1b9 0f00 	cmp.w	r9, #0
    147c:	d018      	beq.n	14b0 <CONFIG_FPROTECT_BLOCK_SIZE+0x4b0>
						OUTC(sign);
    147e:	4629      	mov	r1, r5
    1480:	4648      	mov	r0, r9
    1482:	47b0      	blx	r6
    1484:	2800      	cmp	r0, #0
    1486:	db6b      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    1488:	3401      	adds	r4, #1
						sign = 0;
    148a:	f8dd 9008 	ldr.w	r9, [sp, #8]
					}
					pad = '0';
    148e:	2330      	movs	r3, #48	; 0x30
    1490:	9302      	str	r3, [sp, #8]
    1492:	e00f      	b.n	14b4 <CONFIG_FPROTECT_BLOCK_SIZE+0x4b4>
		const char *bpe = buf + sizeof(buf);
    1494:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
    1498:	e7cc      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
    149a:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
    149e:	e7c9      	b.n	1434 <CONFIG_FPROTECT_BLOCK_SIZE+0x434>
		} else if (conv->altform_0) {
    14a0:	f011 0f08 	tst.w	r1, #8
    14a4:	d0d6      	beq.n	1454 <CONFIG_FPROTECT_BLOCK_SIZE+0x454>
			nj_len += 1U;
    14a6:	3201      	adds	r2, #1
    14a8:	e7d4      	b.n	1454 <CONFIG_FPROTECT_BLOCK_SIZE+0x454>
				char pad = ' ';
    14aa:	2320      	movs	r3, #32
    14ac:	9302      	str	r3, [sp, #8]
    14ae:	e001      	b.n	14b4 <CONFIG_FPROTECT_BLOCK_SIZE+0x4b4>
					pad = '0';
    14b0:	2330      	movs	r3, #48	; 0x30
    14b2:	9302      	str	r3, [sp, #8]
    14b4:	463b      	mov	r3, r7
				}

				while (width-- > 0) {
    14b6:	1e5f      	subs	r7, r3, #1
    14b8:	2b00      	cmp	r3, #0
    14ba:	dd07      	ble.n	14cc <CONFIG_FPROTECT_BLOCK_SIZE+0x4cc>
					OUTC(pad);
    14bc:	4629      	mov	r1, r5
    14be:	9802      	ldr	r0, [sp, #8]
    14c0:	47b0      	blx	r6
    14c2:	2800      	cmp	r0, #0
    14c4:	db4c      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    14c6:	3401      	adds	r4, #1
				while (width-- > 0) {
    14c8:	463b      	mov	r3, r7
    14ca:	e7f4      	b.n	14b6 <CONFIG_FPROTECT_BLOCK_SIZE+0x4b6>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    14cc:	f1b9 0f00 	cmp.w	r9, #0
    14d0:	d005      	beq.n	14de <CONFIG_FPROTECT_BLOCK_SIZE+0x4de>
			OUTC(sign);
    14d2:	4629      	mov	r1, r5
    14d4:	4648      	mov	r0, r9
    14d6:	47b0      	blx	r6
    14d8:	2800      	cmp	r0, #0
    14da:	db41      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    14dc:	3401      	adds	r4, #1
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    14de:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    14e2:	f3c3 1200 	ubfx	r2, r3, #4, #1
    14e6:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    14ea:	4313      	orrs	r3, r2
    14ec:	d005      	beq.n	14fa <CONFIG_FPROTECT_BLOCK_SIZE+0x4fa>
				OUTC('0');
    14ee:	4629      	mov	r1, r5
    14f0:	2030      	movs	r0, #48	; 0x30
    14f2:	47b0      	blx	r6
    14f4:	2800      	cmp	r0, #0
    14f6:	db33      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    14f8:	3401      	adds	r4, #1
			}

			if (conv->altform_0c) {
    14fa:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    14fe:	f013 0f10 	tst.w	r3, #16
    1502:	d006      	beq.n	1512 <CONFIG_FPROTECT_BLOCK_SIZE+0x512>
				OUTC(conv->specifier);
    1504:	4629      	mov	r1, r5
    1506:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    150a:	47b0      	blx	r6
    150c:	2800      	cmp	r0, #0
    150e:	db27      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    1510:	3401      	adds	r4, #1
			}

			pad_len = conv->pad0_value;
    1512:	9b09      	ldr	r3, [sp, #36]	; 0x24
			while (pad_len-- > 0) {
    1514:	f103 39ff 	add.w	r9, r3, #4294967295
    1518:	2b00      	cmp	r3, #0
    151a:	dd07      	ble.n	152c <CONFIG_FPROTECT_BLOCK_SIZE+0x52c>
				OUTC('0');
    151c:	4629      	mov	r1, r5
    151e:	2030      	movs	r0, #48	; 0x30
    1520:	47b0      	blx	r6
    1522:	2800      	cmp	r0, #0
    1524:	db1c      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    1526:	3401      	adds	r4, #1
			while (pad_len-- > 0) {
    1528:	464b      	mov	r3, r9
    152a:	e7f3      	b.n	1514 <CONFIG_FPROTECT_BLOCK_SIZE+0x514>
			}

			OUTS(bps, bpe);
    152c:	465b      	mov	r3, fp
    152e:	4652      	mov	r2, sl
    1530:	4629      	mov	r1, r5
    1532:	4630      	mov	r0, r6
    1534:	f006 f819 	bl	756a <outs>
    1538:	2800      	cmp	r0, #0
    153a:	db11      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    153c:	4404      	add	r4, r0
		}

		/* Finish left justification */
		while (width > 0) {
    153e:	2f00      	cmp	r7, #0
    1540:	dd07      	ble.n	1552 <CONFIG_FPROTECT_BLOCK_SIZE+0x552>
			OUTC(' ');
    1542:	4629      	mov	r1, r5
    1544:	2020      	movs	r0, #32
    1546:	47b0      	blx	r6
    1548:	2800      	cmp	r0, #0
    154a:	db09      	blt.n	1560 <CONFIG_FPROTECT_BLOCK_SIZE+0x560>
    154c:	3401      	adds	r4, #1
			--width;
    154e:	3f01      	subs	r7, #1
    1550:	e7f5      	b.n	153e <CONFIG_FPROTECT_BLOCK_SIZE+0x53e>
		fp = extract_conversion(conv, sp);
    1552:	46c2      	mov	sl, r8
    1554:	f7ff bb28 	b.w	ba8 <cbvprintf+0x10>
    1558:	46c2      	mov	sl, r8
    155a:	f7ff bb25 	b.w	ba8 <cbvprintf+0x10>
		}
	}

	return count;
    155e:	4620      	mov	r0, r4
#undef OUTS
#undef OUTC
}
    1560:	b013      	add	sp, #76	; 0x4c
    1562:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1566:	bf00      	nop
    1568:	00008fe1 	.word	0x00008fe1

0000156c <is_rodata>:
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
    156c:	4b05      	ldr	r3, [pc, #20]	; (1584 <is_rodata+0x18>)
    156e:	4298      	cmp	r0, r3
    1570:	d304      	bcc.n	157c <is_rodata+0x10>
    1572:	4b05      	ldr	r3, [pc, #20]	; (1588 <is_rodata+0x1c>)
    1574:	4298      	cmp	r0, r3
    1576:	d303      	bcc.n	1580 <is_rodata+0x14>
    1578:	2000      	movs	r0, #0
    157a:	4770      	bx	lr
    157c:	2000      	movs	r0, #0
    157e:	4770      	bx	lr
    1580:	2001      	movs	r0, #1
		((const char *)addr < (const char *)RO_END));
}
    1582:	4770      	bx	lr
    1584:	00008c80 	.word	0x00008c80
    1588:	0000999c 	.word	0x0000999c

0000158c <thread_set>:
		}
	}
}

static void thread_set(k_tid_t process_tid)
{
    158c:	b508      	push	{r3, lr}
	proc_tid = process_tid;
    158e:	4b06      	ldr	r3, [pc, #24]	; (15a8 <thread_set+0x1c>)
    1590:	6018      	str	r0, [r3, #0]

	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE)) {
		return;
	}

	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    1592:	b118      	cbz	r0, 159c <thread_set+0x10>
	    process_tid &&
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    1594:	4b05      	ldr	r3, [pc, #20]	; (15ac <thread_set+0x20>)
    1596:	681b      	ldr	r3, [r3, #0]
	    process_tid &&
    1598:	2b09      	cmp	r3, #9
    159a:	dc00      	bgt.n	159e <thread_set+0x12>
		k_sem_give(&log_process_thread_sem);
	}
}
    159c:	bd08      	pop	{r3, pc}
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    159e:	4804      	ldr	r0, [pc, #16]	; (15b0 <thread_set+0x24>)
    15a0:	f004 fe1c 	bl	61dc <z_impl_k_sem_give>
}
    15a4:	e7fa      	b.n	159c <thread_set+0x10>
    15a6:	bf00      	nop
    15a8:	200003e0 	.word	0x200003e0
    15ac:	200003b0 	.word	0x200003b0
    15b0:	20000114 	.word	0x20000114

000015b4 <log_process_thread_timer_expiry_fn>:

	return 0;
}

static void log_process_thread_timer_expiry_fn(struct k_timer *timer)
{
    15b4:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
    15b6:	4802      	ldr	r0, [pc, #8]	; (15c0 <log_process_thread_timer_expiry_fn+0xc>)
    15b8:	f004 fe10 	bl	61dc <z_impl_k_sem_give>
	k_sem_give(&log_process_thread_sem);
}
    15bc:	bd08      	pop	{r3, pc}
    15be:	bf00      	nop
    15c0:	20000114 	.word	0x20000114

000015c4 <next_pending>:
{
    15c4:	b508      	push	{r3, lr}
	return (log_list_head_peek(&list) != NULL);
    15c6:	4803      	ldr	r0, [pc, #12]	; (15d4 <next_pending+0x10>)
    15c8:	f005 fff8 	bl	75bc <log_list_head_peek>
}
    15cc:	3800      	subs	r0, #0
    15ce:	bf18      	it	ne
    15d0:	2001      	movne	r0, #1
    15d2:	bd08      	pop	{r3, pc}
    15d4:	200003bc 	.word	0x200003bc

000015d8 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    15d8:	b530      	push	{r4, r5, lr}
    15da:	b089      	sub	sp, #36	; 0x24
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    15dc:	2200      	movs	r2, #0
    15de:	490f      	ldr	r1, [pc, #60]	; (161c <enable_logger+0x44>)
    15e0:	480f      	ldr	r0, [pc, #60]	; (1620 <enable_logger+0x48>)
    15e2:	f007 fb1f 	bl	8c24 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    15e6:	4d0f      	ldr	r5, [pc, #60]	; (1624 <enable_logger+0x4c>)
    15e8:	2200      	movs	r2, #0
    15ea:	2300      	movs	r3, #0
    15ec:	e9cd 2306 	strd	r2, r3, [sp, #24]
    15f0:	2400      	movs	r4, #0
    15f2:	9404      	str	r4, [sp, #16]
    15f4:	230e      	movs	r3, #14
    15f6:	9303      	str	r3, [sp, #12]
    15f8:	9402      	str	r4, [sp, #8]
    15fa:	9401      	str	r4, [sp, #4]
    15fc:	9400      	str	r4, [sp, #0]
    15fe:	4b0a      	ldr	r3, [pc, #40]	; (1628 <enable_logger+0x50>)
    1600:	f44f 7240 	mov.w	r2, #768	; 0x300
    1604:	4909      	ldr	r1, [pc, #36]	; (162c <enable_logger+0x54>)
    1606:	4628      	mov	r0, r5
    1608:	f007 f90c 	bl	8824 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    160c:	4908      	ldr	r1, [pc, #32]	; (1630 <enable_logger+0x58>)
    160e:	4628      	mov	r0, r5
    1610:	f004 fc28 	bl	5e64 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    1614:	4620      	mov	r0, r4
    1616:	b009      	add	sp, #36	; 0x24
    1618:	bd30      	pop	{r4, r5, pc}
    161a:	bf00      	nop
    161c:	000015b5 	.word	0x000015b5
    1620:	20000128 	.word	0x20000128
    1624:	20000160 	.word	0x20000160
    1628:	00001cf1 	.word	0x00001cf1
    162c:	20000a00 	.word	0x20000a00
    1630:	00008fe4 	.word	0x00008fe4

00001634 <log_init>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    1634:	4b18      	ldr	r3, [pc, #96]	; (1698 <log_init+0x64>)
    1636:	f3bf 8f5b 	dmb	ish
    163a:	e853 2f00 	ldrex	r2, [r3]
    163e:	1c51      	adds	r1, r2, #1
    1640:	e843 1000 	strex	r0, r1, [r3]
    1644:	2800      	cmp	r0, #0
    1646:	d1f8      	bne.n	163a <log_init+0x6>
    1648:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    164c:	bb1a      	cbnz	r2, 1696 <log_init+0x62>
{
    164e:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < log_backend_count_get(); i++) {
    1650:	2400      	movs	r4, #0
    1652:	e009      	b.n	1668 <log_init+0x34>
					   backend->cb->ctx,
    1654:	4b11      	ldr	r3, [pc, #68]	; (169c <log_init+0x68>)
    1656:	eb03 1306 	add.w	r3, r3, r6, lsl #4
    165a:	685b      	ldr	r3, [r3, #4]
			log_backend_enable(backend,
    165c:	2204      	movs	r2, #4
    165e:	6819      	ldr	r1, [r3, #0]
    1660:	4628      	mov	r0, r5
    1662:	f000 fb89 	bl	1d78 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    1666:	3401      	adds	r4, #1
    1668:	4b0d      	ldr	r3, [pc, #52]	; (16a0 <log_init+0x6c>)
    166a:	4a0c      	ldr	r2, [pc, #48]	; (169c <log_init+0x68>)
    166c:	1a9b      	subs	r3, r3, r2
    166e:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1672:	da0f      	bge.n	1694 <log_init+0x60>
		const struct log_backend *backend = log_backend_get(i);
    1674:	4626      	mov	r6, r4
 *
 * @return    Pointer to the backend instance.
 */
static inline const struct log_backend *log_backend_get(uint32_t idx)
{
	return &__log_backends_start[idx];
    1676:	4d09      	ldr	r5, [pc, #36]	; (169c <log_init+0x68>)
    1678:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (backend->autostart) {
    167c:	7b2b      	ldrb	r3, [r5, #12]
    167e:	2b00      	cmp	r3, #0
    1680:	d0f1      	beq.n	1666 <log_init+0x32>
			if (backend->api->init != NULL) {
    1682:	0123      	lsls	r3, r4, #4
    1684:	4a05      	ldr	r2, [pc, #20]	; (169c <log_init+0x68>)
    1686:	58d3      	ldr	r3, [r2, r3]
    1688:	699b      	ldr	r3, [r3, #24]
    168a:	2b00      	cmp	r3, #0
    168c:	d0e2      	beq.n	1654 <log_init+0x20>
				backend->api->init(backend);
    168e:	4628      	mov	r0, r5
    1690:	4798      	blx	r3
    1692:	e7df      	b.n	1654 <log_init+0x20>
}
    1694:	bd70      	pop	{r4, r5, r6, pc}
    1696:	4770      	bx	lr
    1698:	200003b8 	.word	0x200003b8
    169c:	00008e90 	.word	0x00008e90
    16a0:	00008ea0 	.word	0x00008ea0

000016a4 <log_set_timestamp_func>:
	if (timestamp_getter == NULL) {
    16a4:	b138      	cbz	r0, 16b6 <log_set_timestamp_func+0x12>
{
    16a6:	b508      	push	{r3, lr}
	timestamp_func = timestamp_getter;
    16a8:	4a04      	ldr	r2, [pc, #16]	; (16bc <log_set_timestamp_func+0x18>)
    16aa:	6010      	str	r0, [r2, #0]
	log_output_timestamp_freq_set(freq);
    16ac:	4608      	mov	r0, r1
    16ae:	f000 fddb 	bl	2268 <log_output_timestamp_freq_set>
	return 0;
    16b2:	2000      	movs	r0, #0
}
    16b4:	bd08      	pop	{r3, pc}
		return -EINVAL;
    16b6:	f06f 0015 	mvn.w	r0, #21
}
    16ba:	4770      	bx	lr
    16bc:	20000024 	.word	0x20000024

000016c0 <log_core_init>:
{
    16c0:	b508      	push	{r3, lr}
	panic_mode = false;
    16c2:	2300      	movs	r3, #0
    16c4:	4a0a      	ldr	r2, [pc, #40]	; (16f0 <log_core_init+0x30>)
    16c6:	7013      	strb	r3, [r2, #0]
	dropped_cnt = 0;
    16c8:	4a0a      	ldr	r2, [pc, #40]	; (16f4 <log_core_init+0x34>)
    16ca:	6013      	str	r3, [r2, #0]
	log_set_timestamp_func(_timestamp_func, freq);
    16cc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    16d0:	4809      	ldr	r0, [pc, #36]	; (16f8 <log_core_init+0x38>)
    16d2:	f7ff ffe7 	bl	16a4 <log_set_timestamp_func>
		log_msg_pool_init();
    16d6:	f000 fb71 	bl	1dbc <log_msg_pool_init>
		log_list_init(&list);
    16da:	4808      	ldr	r0, [pc, #32]	; (16fc <log_core_init+0x3c>)
    16dc:	f005 ff60 	bl	75a0 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    16e0:	2304      	movs	r3, #4
    16e2:	2228      	movs	r2, #40	; 0x28
    16e4:	4906      	ldr	r1, [pc, #24]	; (1700 <log_core_init+0x40>)
    16e6:	4807      	ldr	r0, [pc, #28]	; (1704 <log_core_init+0x44>)
    16e8:	f007 f839 	bl	875e <k_mem_slab_init>
}
    16ec:	bd08      	pop	{r3, pc}
    16ee:	bf00      	nop
    16f0:	200009f9 	.word	0x200009f9
    16f4:	200003b4 	.word	0x200003b4
    16f8:	000075d5 	.word	0x000075d5
    16fc:	200003bc 	.word	0x200003bc
    1700:	200026c0 	.word	0x200026c0
    1704:	200003c4 	.word	0x200003c4

00001708 <get_msg>:
{
    1708:	b510      	push	{r4, lr}
    170a:	f04f 0320 	mov.w	r3, #32
    170e:	f3ef 8411 	mrs	r4, BASEPRI
    1712:	f383 8812 	msr	BASEPRI_MAX, r3
    1716:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
    171a:	4804      	ldr	r0, [pc, #16]	; (172c <get_msg+0x24>)
    171c:	f005 ff50 	bl	75c0 <log_list_head_get>
	__asm__ volatile(
    1720:	f384 8811 	msr	BASEPRI, r4
    1724:	f3bf 8f6f 	isb	sy
}
    1728:	bd10      	pop	{r4, pc}
    172a:	bf00      	nop
    172c:	200003bc 	.word	0x200003bc

00001730 <z_log_notify_backend_enabled>:
{
    1730:	b508      	push	{r3, lr}
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    1732:	4b05      	ldr	r3, [pc, #20]	; (1748 <z_log_notify_backend_enabled+0x18>)
    1734:	781b      	ldrb	r3, [r3, #0]
    1736:	b11b      	cbz	r3, 1740 <z_log_notify_backend_enabled+0x10>
	backend_attached = true;
    1738:	4b03      	ldr	r3, [pc, #12]	; (1748 <z_log_notify_backend_enabled+0x18>)
    173a:	2201      	movs	r2, #1
    173c:	701a      	strb	r2, [r3, #0]
}
    173e:	bd08      	pop	{r3, pc}
	z_impl_k_sem_give(sem);
    1740:	4802      	ldr	r0, [pc, #8]	; (174c <z_log_notify_backend_enabled+0x1c>)
    1742:	f004 fd4b 	bl	61dc <z_impl_k_sem_give>
}
    1746:	e7f7      	b.n	1738 <z_log_notify_backend_enabled+0x8>
    1748:	200009f8 	.word	0x200009f8
    174c:	20000114 	.word	0x20000114

00001750 <z_log_dropped>:
    1750:	4b0c      	ldr	r3, [pc, #48]	; (1784 <z_log_dropped+0x34>)
    1752:	f3bf 8f5b 	dmb	ish
    1756:	e853 2f00 	ldrex	r2, [r3]
    175a:	3201      	adds	r2, #1
    175c:	e843 2100 	strex	r1, r2, [r3]
    1760:	2900      	cmp	r1, #0
    1762:	d1f8      	bne.n	1756 <z_log_dropped+0x6>
    1764:	f3bf 8f5b 	dmb	ish
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_sub(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    1768:	4b07      	ldr	r3, [pc, #28]	; (1788 <z_log_dropped+0x38>)
    176a:	f3bf 8f5b 	dmb	ish
    176e:	e853 2f00 	ldrex	r2, [r3]
    1772:	3a01      	subs	r2, #1
    1774:	e843 2100 	strex	r1, r2, [r3]
    1778:	2900      	cmp	r1, #0
    177a:	d1f8      	bne.n	176e <z_log_dropped+0x1e>
    177c:	f3bf 8f5b 	dmb	ish
}
    1780:	4770      	bx	lr
    1782:	bf00      	nop
    1784:	200003b4 	.word	0x200003b4
    1788:	200003b0 	.word	0x200003b0

0000178c <z_log_dropped_read_and_clear>:
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    178c:	4b06      	ldr	r3, [pc, #24]	; (17a8 <z_log_dropped_read_and_clear+0x1c>)
}
    178e:	2000      	movs	r0, #0
    1790:	4602      	mov	r2, r0
    1792:	f3bf 8f5b 	dmb	ish
    1796:	e853 0f00 	ldrex	r0, [r3]
    179a:	e843 2100 	strex	r1, r2, [r3]
    179e:	2900      	cmp	r1, #0
    17a0:	d1f9      	bne.n	1796 <z_log_dropped_read_and_clear+0xa>
    17a2:	f3bf 8f5b 	dmb	ish
    17a6:	4770      	bx	lr
    17a8:	200003b4 	.word	0x200003b4

000017ac <dropped_notify>:
{
    17ac:	b538      	push	{r3, r4, r5, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
    17ae:	f7ff ffed 	bl	178c <z_log_dropped_read_and_clear>
    17b2:	4605      	mov	r5, r0
	for (int i = 0; i < log_backend_count_get(); i++) {
    17b4:	2400      	movs	r4, #0
    17b6:	e000      	b.n	17ba <dropped_notify+0xe>
    17b8:	3401      	adds	r4, #1
    17ba:	4b0b      	ldr	r3, [pc, #44]	; (17e8 <dropped_notify+0x3c>)
    17bc:	4a0b      	ldr	r2, [pc, #44]	; (17ec <dropped_notify+0x40>)
    17be:	1a9b      	subs	r3, r3, r2
    17c0:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    17c4:	da0f      	bge.n	17e6 <dropped_notify+0x3a>
    17c6:	4809      	ldr	r0, [pc, #36]	; (17ec <dropped_notify+0x40>)
    17c8:	eb00 1004 	add.w	r0, r0, r4, lsl #4
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    17cc:	6843      	ldr	r3, [r0, #4]
    17ce:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    17d0:	2b00      	cmp	r3, #0
    17d2:	d0f1      	beq.n	17b8 <dropped_notify+0xc>
	if (backend->api->dropped != NULL) {
    17d4:	0123      	lsls	r3, r4, #4
    17d6:	4a05      	ldr	r2, [pc, #20]	; (17ec <dropped_notify+0x40>)
    17d8:	58d3      	ldr	r3, [r2, r3]
    17da:	691b      	ldr	r3, [r3, #16]
    17dc:	2b00      	cmp	r3, #0
    17de:	d0eb      	beq.n	17b8 <dropped_notify+0xc>
		backend->api->dropped(backend, cnt);
    17e0:	4629      	mov	r1, r5
    17e2:	4798      	blx	r3
    17e4:	e7e8      	b.n	17b8 <dropped_notify+0xc>
}
    17e6:	bd38      	pop	{r3, r4, r5, pc}
    17e8:	00008ea0 	.word	0x00008ea0
    17ec:	00008e90 	.word	0x00008e90

000017f0 <z_log_dropped_pending>:
	return dropped_cnt > 0;
    17f0:	4b03      	ldr	r3, [pc, #12]	; (1800 <z_log_dropped_pending+0x10>)
    17f2:	6818      	ldr	r0, [r3, #0]
}
    17f4:	2800      	cmp	r0, #0
    17f6:	bfd4      	ite	le
    17f8:	2000      	movle	r0, #0
    17fa:	2001      	movgt	r0, #1
    17fc:	4770      	bx	lr
    17fe:	bf00      	nop
    1800:	200003b4 	.word	0x200003b4

00001804 <z_log_strdup>:
{
    1804:	b510      	push	{r4, lr}
    1806:	b082      	sub	sp, #8
    1808:	4604      	mov	r4, r0
	    is_rodata(str) || k_is_user_context()) {
    180a:	f7ff feaf 	bl	156c <is_rodata>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    180e:	bb10      	cbnz	r0, 1856 <z_log_strdup+0x52>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    1810:	2200      	movs	r2, #0
    1812:	2300      	movs	r3, #0
    1814:	a901      	add	r1, sp, #4
    1816:	4811      	ldr	r0, [pc, #68]	; (185c <z_log_strdup+0x58>)
    1818:	f004 face 	bl	5db8 <k_mem_slab_alloc>
	if (err != 0) {
    181c:	b108      	cbz	r0, 1822 <z_log_strdup+0x1e>
		return (char *)log_strdup_fail_msg;
    181e:	4c10      	ldr	r4, [pc, #64]	; (1860 <z_log_strdup+0x5c>)
    1820:	e019      	b.n	1856 <z_log_strdup+0x52>
	(void)atomic_set(&dup->refcount, 1);
    1822:	9b01      	ldr	r3, [sp, #4]
    1824:	2201      	movs	r2, #1
    1826:	f3bf 8f5b 	dmb	ish
    182a:	e853 1f00 	ldrex	r1, [r3]
    182e:	e843 2000 	strex	r0, r2, [r3]
    1832:	2800      	cmp	r0, #0
    1834:	d1f9      	bne.n	182a <z_log_strdup+0x26>
    1836:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    183a:	221f      	movs	r2, #31
    183c:	4621      	mov	r1, r4
    183e:	9801      	ldr	r0, [sp, #4]
    1840:	3004      	adds	r0, #4
    1842:	f006 fa6b 	bl	7d1c <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    1846:	9c01      	ldr	r4, [sp, #4]
    1848:	237e      	movs	r3, #126	; 0x7e
    184a:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    184e:	2300      	movs	r3, #0
    1850:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	return dup->buf;
    1854:	3404      	adds	r4, #4
}
    1856:	4620      	mov	r0, r4
    1858:	b002      	add	sp, #8
    185a:	bd10      	pop	{r4, pc}
    185c:	200003c4 	.word	0x200003c4
    1860:	00008fec 	.word	0x00008fec

00001864 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    1864:	b138      	cbz	r0, 1876 <log_is_strdup+0x12>
    1866:	4a07      	ldr	r2, [pc, #28]	; (1884 <log_is_strdup+0x20>)
    1868:	4290      	cmp	r0, r2
    186a:	d306      	bcc.n	187a <log_is_strdup+0x16>
    186c:	32a0      	adds	r2, #160	; 0xa0
    186e:	4290      	cmp	r0, r2
    1870:	d305      	bcc.n	187e <log_is_strdup+0x1a>
    1872:	2000      	movs	r0, #0
    1874:	4770      	bx	lr
    1876:	2000      	movs	r0, #0
    1878:	4770      	bx	lr
    187a:	2000      	movs	r0, #0
    187c:	4770      	bx	lr
    187e:	2001      	movs	r0, #1
}
    1880:	4770      	bx	lr
    1882:	bf00      	nop
    1884:	200026c0 	.word	0x200026c0

00001888 <detect_missed_strdup>:
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    1888:	7a03      	ldrb	r3, [r0, #8]
	if (!log_msg_is_std(msg)) {
    188a:	f013 0f01 	tst.w	r3, #1
    188e:	d000      	beq.n	1892 <detect_missed_strdup+0xa>
    1890:	4770      	bx	lr
{
    1892:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1896:	b083      	sub	sp, #12
    1898:	4606      	mov	r6, r0
	msg_str = log_msg_str_get(msg);
    189a:	f005 ff57 	bl	774c <log_msg_str_get>
    189e:	4607      	mov	r7, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    18a0:	4630      	mov	r0, r6
    18a2:	f005 ff3e 	bl	7722 <log_msg_nargs_get>
    18a6:	4601      	mov	r1, r0
    18a8:	4638      	mov	r0, r7
    18aa:	f005 fe97 	bl	75dc <z_log_get_s_mask>
    18ae:	4605      	mov	r5, r0
	while (mask) {
    18b0:	e004      	b.n	18bc <detect_missed_strdup+0x34>
		mask &= ~BIT(idx);
    18b2:	2301      	movs	r3, #1
    18b4:	fa03 f404 	lsl.w	r4, r3, r4
    18b8:	ea25 0504 	bic.w	r5, r5, r4
	while (mask) {
    18bc:	b36d      	cbz	r5, 191a <detect_missed_strdup+0x92>
		idx = 31 - __builtin_clz(mask);
    18be:	fab5 f485 	clz	r4, r5
    18c2:	f1c4 041f 	rsb	r4, r4, #31
		str = (const char *)log_msg_arg_get(msg, idx);
    18c6:	4621      	mov	r1, r4
    18c8:	4630      	mov	r0, r6
    18ca:	f005 ff2d 	bl	7728 <log_msg_arg_get>
    18ce:	4681      	mov	r9, r0
		if (!is_rodata(str) && !log_is_strdup(str) &&
    18d0:	f7ff fe4c 	bl	156c <is_rodata>
    18d4:	2800      	cmp	r0, #0
    18d6:	d1ec      	bne.n	18b2 <detect_missed_strdup+0x2a>
    18d8:	4648      	mov	r0, r9
    18da:	f7ff ffc3 	bl	1864 <log_is_strdup>
    18de:	2800      	cmp	r0, #0
    18e0:	d1e7      	bne.n	18b2 <detect_missed_strdup+0x2a>
    18e2:	4b0f      	ldr	r3, [pc, #60]	; (1920 <detect_missed_strdup+0x98>)
    18e4:	4599      	cmp	r9, r3
    18e6:	d0e4      	beq.n	18b2 <detect_missed_strdup+0x2a>
	return msg->hdr.ids.source_id;
    18e8:	8971      	ldrh	r1, [r6, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
    18ea:	f3c1 1189 	ubfx	r1, r1, #6, #10
    18ee:	f000 fa33 	bl	1d58 <log_source_name_get>
    18f2:	4602      	mov	r2, r0
    18f4:	4b0b      	ldr	r3, [pc, #44]	; (1924 <detect_missed_strdup+0x9c>)
    18f6:	490c      	ldr	r1, [pc, #48]	; (1928 <detect_missed_strdup+0xa0>)
    18f8:	1a5b      	subs	r3, r3, r1
    18fa:	08db      	lsrs	r3, r3, #3
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    18fc:	2101      	movs	r1, #1
    18fe:	f361 0802 	bfi	r8, r1, #0, #3
    1902:	f36f 08c5 	bfc	r8, #3, #3
    1906:	f363 188f 	bfi	r8, r3, #6, #10
    190a:	f8ad 8000 	strh.w	r8, [sp]
    190e:	463b      	mov	r3, r7
    1910:	4621      	mov	r1, r4
    1912:	4806      	ldr	r0, [pc, #24]	; (192c <detect_missed_strdup+0xa4>)
    1914:	f000 f8b0 	bl	1a78 <log_3>
    1918:	e7cb      	b.n	18b2 <detect_missed_strdup+0x2a>
}
    191a:	b003      	add	sp, #12
    191c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1920:	00008fec 	.word	0x00008fec
    1924:	00008e60 	.word	0x00008e60
    1928:	00008e48 	.word	0x00008e48
    192c:	00009008 	.word	0x00009008

00001930 <msg_process>:
{
    1930:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1932:	4606      	mov	r6, r0
	if (!bypass) {
    1934:	bb19      	cbnz	r1, 197e <msg_process+0x4e>
		    !panic_mode) {
    1936:	4b14      	ldr	r3, [pc, #80]	; (1988 <msg_process+0x58>)
    1938:	781b      	ldrb	r3, [r3, #0]
		if (!IS_ENABLED(CONFIG_LOG2) &&
    193a:	b10b      	cbz	r3, 1940 <msg_process+0x10>
{
    193c:	2400      	movs	r4, #0
    193e:	e003      	b.n	1948 <msg_process+0x18>
			detect_missed_strdup(msg.msg);
    1940:	f7ff ffa2 	bl	1888 <detect_missed_strdup>
    1944:	e7fa      	b.n	193c <msg_process+0xc>
		for (int i = 0; i < log_backend_count_get(); i++) {
    1946:	3401      	adds	r4, #1
    1948:	4b10      	ldr	r3, [pc, #64]	; (198c <msg_process+0x5c>)
    194a:	4a11      	ldr	r2, [pc, #68]	; (1990 <msg_process+0x60>)
    194c:	1a9b      	subs	r3, r3, r2
    194e:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1952:	da14      	bge.n	197e <msg_process+0x4e>
	return &__log_backends_start[idx];
    1954:	4d0e      	ldr	r5, [pc, #56]	; (1990 <msg_process+0x60>)
    1956:	eb05 1504 	add.w	r5, r5, r4, lsl #4
	return backend->cb->active;
    195a:	686b      	ldr	r3, [r5, #4]
    195c:	795b      	ldrb	r3, [r3, #5]
			if (log_backend_is_active(backend) &&
    195e:	2b00      	cmp	r3, #0
    1960:	d0f1      	beq.n	1946 <msg_process+0x16>
			    msg_filter_check(backend, msg)) {
    1962:	4631      	mov	r1, r6
    1964:	4628      	mov	r0, r5
    1966:	f005 fe33 	bl	75d0 <msg_filter_check>
			if (log_backend_is_active(backend) &&
    196a:	2800      	cmp	r0, #0
    196c:	d0eb      	beq.n	1946 <msg_process+0x16>
	backend->api->put(backend, msg);
    196e:	0127      	lsls	r7, r4, #4
    1970:	4b07      	ldr	r3, [pc, #28]	; (1990 <msg_process+0x60>)
    1972:	59db      	ldr	r3, [r3, r7]
    1974:	685b      	ldr	r3, [r3, #4]
    1976:	4631      	mov	r1, r6
    1978:	4628      	mov	r0, r5
    197a:	4798      	blx	r3
}
    197c:	e7e3      	b.n	1946 <msg_process+0x16>
			log_msg_put(msg.msg);
    197e:	4630      	mov	r0, r6
    1980:	f005 fee6 	bl	7750 <log_msg_put>
}
    1984:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1986:	bf00      	nop
    1988:	200009f9 	.word	0x200009f9
    198c:	00008ea0 	.word	0x00008ea0
    1990:	00008e90 	.word	0x00008e90

00001994 <z_impl_log_process>:
{
    1994:	b510      	push	{r4, lr}
    1996:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
    1998:	4b11      	ldr	r3, [pc, #68]	; (19e0 <z_impl_log_process+0x4c>)
    199a:	781b      	ldrb	r3, [r3, #0]
    199c:	b903      	cbnz	r3, 19a0 <z_impl_log_process+0xc>
    199e:	b1d0      	cbz	r0, 19d6 <z_impl_log_process+0x42>
	msg = get_msg();
    19a0:	f7ff feb2 	bl	1708 <get_msg>
	if (msg.msg) {
    19a4:	4603      	mov	r3, r0
    19a6:	b180      	cbz	r0, 19ca <z_impl_log_process+0x36>
		if (!bypass) {
    19a8:	b95c      	cbnz	r4, 19c2 <z_impl_log_process+0x2e>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    19aa:	4a0e      	ldr	r2, [pc, #56]	; (19e4 <z_impl_log_process+0x50>)
    19ac:	f3bf 8f5b 	dmb	ish
    19b0:	e852 1f00 	ldrex	r1, [r2]
    19b4:	3901      	subs	r1, #1
    19b6:	e842 1000 	strex	r0, r1, [r2]
    19ba:	2800      	cmp	r0, #0
    19bc:	d1f8      	bne.n	19b0 <z_impl_log_process+0x1c>
    19be:	f3bf 8f5b 	dmb	ish
		msg_process(msg, bypass);
    19c2:	4621      	mov	r1, r4
    19c4:	4618      	mov	r0, r3
    19c6:	f7ff ffb3 	bl	1930 <msg_process>
	if (!bypass && z_log_dropped_pending()) {
    19ca:	b914      	cbnz	r4, 19d2 <z_impl_log_process+0x3e>
    19cc:	f7ff ff10 	bl	17f0 <z_log_dropped_pending>
    19d0:	b910      	cbnz	r0, 19d8 <z_impl_log_process+0x44>
	return next_pending();
    19d2:	f7ff fdf7 	bl	15c4 <next_pending>
}
    19d6:	bd10      	pop	{r4, pc}
		dropped_notify();
    19d8:	f7ff fee8 	bl	17ac <dropped_notify>
    19dc:	e7f9      	b.n	19d2 <z_impl_log_process+0x3e>
    19de:	bf00      	nop
    19e0:	200009f8 	.word	0x200009f8
    19e4:	200003b0 	.word	0x200003b0

000019e8 <z_log_msg_post_finalize>:
{
    19e8:	b510      	push	{r4, lr}
    19ea:	b082      	sub	sp, #8
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    19ec:	4b1d      	ldr	r3, [pc, #116]	; (1a64 <z_log_msg_post_finalize+0x7c>)
    19ee:	f3bf 8f5b 	dmb	ish
    19f2:	e853 2f00 	ldrex	r2, [r3]
    19f6:	1c51      	adds	r1, r2, #1
    19f8:	e843 1000 	strex	r0, r1, [r3]
    19fc:	2800      	cmp	r0, #0
    19fe:	d1f8      	bne.n	19f2 <z_log_msg_post_finalize+0xa>
    1a00:	f3bf 8f5b 	dmb	ish
	if (panic_mode) {
    1a04:	4b18      	ldr	r3, [pc, #96]	; (1a68 <z_log_msg_post_finalize+0x80>)
    1a06:	781b      	ldrb	r3, [r3, #0]
    1a08:	b93b      	cbnz	r3, 1a1a <z_log_msg_post_finalize+0x32>
	} else if (proc_tid != NULL && cnt == 0) {
    1a0a:	4b18      	ldr	r3, [pc, #96]	; (1a6c <z_log_msg_post_finalize+0x84>)
    1a0c:	681b      	ldr	r3, [r3, #0]
    1a0e:	b103      	cbz	r3, 1a12 <z_log_msg_post_finalize+0x2a>
    1a10:	b19a      	cbz	r2, 1a3a <z_log_msg_post_finalize+0x52>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1a12:	2a0a      	cmp	r2, #10
    1a14:	d01c      	beq.n	1a50 <z_log_msg_post_finalize+0x68>
}
    1a16:	b002      	add	sp, #8
    1a18:	bd10      	pop	{r4, pc}
	__asm__ volatile(
    1a1a:	f04f 0320 	mov.w	r3, #32
    1a1e:	f3ef 8411 	mrs	r4, BASEPRI
    1a22:	f383 8812 	msr	BASEPRI_MAX, r3
    1a26:	f3bf 8f6f 	isb	sy
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    1a2a:	2000      	movs	r0, #0
    1a2c:	f7ff ffb2 	bl	1994 <z_impl_log_process>
	__asm__ volatile(
    1a30:	f384 8811 	msr	BASEPRI, r4
    1a34:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    1a38:	e7ed      	b.n	1a16 <z_log_msg_post_finalize+0x2e>
	z_impl_k_timer_start(timer, duration, period);
    1a3a:	2200      	movs	r2, #0
    1a3c:	2300      	movs	r3, #0
    1a3e:	e9cd 2300 	strd	r2, r3, [sp]
    1a42:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    1a46:	2300      	movs	r3, #0
    1a48:	4809      	ldr	r0, [pc, #36]	; (1a70 <z_log_msg_post_finalize+0x88>)
    1a4a:	f005 f9d7 	bl	6dfc <z_impl_k_timer_start>
	} else if (proc_tid != NULL && cnt == 0) {
    1a4e:	e7e2      	b.n	1a16 <z_log_msg_post_finalize+0x2e>
		if ((cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    1a50:	2b00      	cmp	r3, #0
    1a52:	d0e0      	beq.n	1a16 <z_log_msg_post_finalize+0x2e>
	z_impl_k_timer_stop(timer);
    1a54:	4806      	ldr	r0, [pc, #24]	; (1a70 <z_log_msg_post_finalize+0x88>)
    1a56:	f007 f8f1 	bl	8c3c <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    1a5a:	4806      	ldr	r0, [pc, #24]	; (1a74 <z_log_msg_post_finalize+0x8c>)
    1a5c:	f004 fbbe 	bl	61dc <z_impl_k_sem_give>
}
    1a60:	e7d9      	b.n	1a16 <z_log_msg_post_finalize+0x2e>
    1a62:	bf00      	nop
    1a64:	200003b0 	.word	0x200003b0
    1a68:	200009f9 	.word	0x200009f9
    1a6c:	200003e0 	.word	0x200003e0
    1a70:	20000128 	.word	0x20000128
    1a74:	20000114 	.word	0x20000114

00001a78 <log_3>:
{
    1a78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1a7c:	4680      	mov	r8, r0
    1a7e:	460f      	mov	r7, r1
    1a80:	4616      	mov	r6, r2
    1a82:	461d      	mov	r5, r3
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1a84:	f000 f9be 	bl	1e04 <log_msg_chunk_alloc>

	if (msg != NULL) {
    1a88:	4604      	mov	r4, r0
    1a8a:	b140      	cbz	r0, 1a9e <log_3+0x26>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    1a8c:	2301      	movs	r3, #1
    1a8e:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1a90:	2200      	movs	r2, #0
    1a92:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1a94:	f04f 0300 	mov.w	r3, #0
    1a98:	f362 0300 	bfi	r3, r2, #0, #1
    1a9c:	7203      	strb	r3, [r0, #8]
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();

	if (msg != NULL) {
    1a9e:	b14c      	cbz	r4, 1ab4 <log_3+0x3c>
		msg->str = str;
    1aa0:	f8c4 8010 	str.w	r8, [r4, #16]
		msg->hdr.params.std.nargs = 3U;
    1aa4:	7a63      	ldrb	r3, [r4, #9]
    1aa6:	2203      	movs	r2, #3
    1aa8:	f362 1307 	bfi	r3, r2, #4, #4
    1aac:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    1aae:	6167      	str	r7, [r4, #20]
		msg->payload.single.args[1] = arg2;
    1ab0:	61a6      	str	r6, [r4, #24]
		msg->payload.single.args[2] = arg3;
    1ab2:	61e5      	str	r5, [r4, #28]
		if (msg == NULL) {
    1ab4:	b1c4      	cbz	r4, 1ae8 <log_3+0x70>
	msg->hdr.ids = src_level;
    1ab6:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    1aba:	8163      	strh	r3, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1abc:	4b0b      	ldr	r3, [pc, #44]	; (1aec <log_3+0x74>)
    1abe:	681b      	ldr	r3, [r3, #0]
    1ac0:	4798      	blx	r3
    1ac2:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    1ac4:	f04f 0320 	mov.w	r3, #32
    1ac8:	f3ef 8511 	mrs	r5, BASEPRI
    1acc:	f383 8812 	msr	BASEPRI_MAX, r3
    1ad0:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1ad4:	4621      	mov	r1, r4
    1ad6:	4806      	ldr	r0, [pc, #24]	; (1af0 <log_3+0x78>)
    1ad8:	f005 fd66 	bl	75a8 <log_list_add_tail>
	__asm__ volatile(
    1adc:	f385 8811 	msr	BASEPRI, r5
    1ae0:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    1ae4:	f7ff ff80 	bl	19e8 <z_log_msg_post_finalize>
}
    1ae8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1aec:	20000024 	.word	0x20000024
    1af0:	200003bc 	.word	0x200003bc

00001af4 <log_1>:
{
    1af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1af6:	4606      	mov	r6, r0
    1af8:	460d      	mov	r5, r1
    1afa:	4617      	mov	r7, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1afc:	f000 f982 	bl	1e04 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1b00:	4604      	mov	r4, r0
    1b02:	b140      	cbz	r0, 1b16 <log_1+0x22>
		msg->hdr.ref_cnt = 1;
    1b04:	2301      	movs	r3, #1
    1b06:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1b08:	2100      	movs	r1, #0
    1b0a:	8101      	strh	r1, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1b0c:	f04f 0300 	mov.w	r3, #0
    1b10:	f361 0300 	bfi	r3, r1, #0, #1
    1b14:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    1b16:	b134      	cbz	r4, 1b26 <log_1+0x32>
		msg->str = str;
    1b18:	6126      	str	r6, [r4, #16]
		msg->hdr.params.std.nargs = 1U;
    1b1a:	7a63      	ldrb	r3, [r4, #9]
    1b1c:	2201      	movs	r2, #1
    1b1e:	f362 1307 	bfi	r3, r2, #4, #4
    1b22:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    1b24:	6165      	str	r5, [r4, #20]
		if (msg == NULL) {
    1b26:	b1b4      	cbz	r4, 1b56 <log_1+0x62>
	msg->hdr.ids = src_level;
    1b28:	8167      	strh	r7, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1b2a:	4b0b      	ldr	r3, [pc, #44]	; (1b58 <log_1+0x64>)
    1b2c:	681b      	ldr	r3, [r3, #0]
    1b2e:	4798      	blx	r3
    1b30:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    1b32:	f04f 0320 	mov.w	r3, #32
    1b36:	f3ef 8511 	mrs	r5, BASEPRI
    1b3a:	f383 8812 	msr	BASEPRI_MAX, r3
    1b3e:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1b42:	4621      	mov	r1, r4
    1b44:	4805      	ldr	r0, [pc, #20]	; (1b5c <log_1+0x68>)
    1b46:	f005 fd2f 	bl	75a8 <log_list_add_tail>
	__asm__ volatile(
    1b4a:	f385 8811 	msr	BASEPRI, r5
    1b4e:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    1b52:	f7ff ff49 	bl	19e8 <z_log_msg_post_finalize>
}
    1b56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1b58:	20000024 	.word	0x20000024
    1b5c:	200003bc 	.word	0x200003bc

00001b60 <log_2>:
{
    1b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1b64:	4607      	mov	r7, r0
    1b66:	460e      	mov	r6, r1
    1b68:	4615      	mov	r5, r2
    1b6a:	4698      	mov	r8, r3
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1b6c:	f000 f94a 	bl	1e04 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1b70:	4604      	mov	r4, r0
    1b72:	b140      	cbz	r0, 1b86 <log_2+0x26>
		msg->hdr.ref_cnt = 1;
    1b74:	2301      	movs	r3, #1
    1b76:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1b78:	2200      	movs	r2, #0
    1b7a:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1b7c:	f04f 0300 	mov.w	r3, #0
    1b80:	f362 0300 	bfi	r3, r2, #0, #1
    1b84:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    1b86:	b13c      	cbz	r4, 1b98 <log_2+0x38>
		msg->str = str;
    1b88:	6127      	str	r7, [r4, #16]
		msg->hdr.params.std.nargs = 2U;
    1b8a:	7a63      	ldrb	r3, [r4, #9]
    1b8c:	2202      	movs	r2, #2
    1b8e:	f362 1307 	bfi	r3, r2, #4, #4
    1b92:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    1b94:	6166      	str	r6, [r4, #20]
		msg->payload.single.args[1] = arg2;
    1b96:	61a5      	str	r5, [r4, #24]
		if (msg == NULL) {
    1b98:	b1bc      	cbz	r4, 1bca <log_2+0x6a>
	msg->hdr.ids = src_level;
    1b9a:	f8a4 800a 	strh.w	r8, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1b9e:	4b0c      	ldr	r3, [pc, #48]	; (1bd0 <log_2+0x70>)
    1ba0:	681b      	ldr	r3, [r3, #0]
    1ba2:	4798      	blx	r3
    1ba4:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    1ba6:	f04f 0320 	mov.w	r3, #32
    1baa:	f3ef 8511 	mrs	r5, BASEPRI
    1bae:	f383 8812 	msr	BASEPRI_MAX, r3
    1bb2:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1bb6:	4621      	mov	r1, r4
    1bb8:	4806      	ldr	r0, [pc, #24]	; (1bd4 <log_2+0x74>)
    1bba:	f005 fcf5 	bl	75a8 <log_list_add_tail>
	__asm__ volatile(
    1bbe:	f385 8811 	msr	BASEPRI, r5
    1bc2:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    1bc6:	f7ff ff0f 	bl	19e8 <z_log_msg_post_finalize>
}
    1bca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1bce:	bf00      	nop
    1bd0:	20000024 	.word	0x20000024
    1bd4:	200003bc 	.word	0x200003bc

00001bd8 <log_0>:
{
    1bd8:	b570      	push	{r4, r5, r6, lr}
    1bda:	4605      	mov	r5, r0
    1bdc:	460e      	mov	r6, r1
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1bde:	f000 f911 	bl	1e04 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1be2:	4604      	mov	r4, r0
    1be4:	b140      	cbz	r0, 1bf8 <log_0+0x20>
		msg->hdr.ref_cnt = 1;
    1be6:	2301      	movs	r3, #1
    1be8:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1bea:	2200      	movs	r2, #0
    1bec:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1bee:	f04f 0300 	mov.w	r3, #0
    1bf2:	f362 0300 	bfi	r3, r2, #0, #1
    1bf6:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    1bf8:	b104      	cbz	r4, 1bfc <log_0+0x24>
		msg->str = str;
    1bfa:	6125      	str	r5, [r4, #16]
		if (msg == NULL) {
    1bfc:	b1b4      	cbz	r4, 1c2c <log_0+0x54>
	msg->hdr.ids = src_level;
    1bfe:	8166      	strh	r6, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1c00:	4b0b      	ldr	r3, [pc, #44]	; (1c30 <log_0+0x58>)
    1c02:	681b      	ldr	r3, [r3, #0]
    1c04:	4798      	blx	r3
    1c06:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    1c08:	f04f 0320 	mov.w	r3, #32
    1c0c:	f3ef 8511 	mrs	r5, BASEPRI
    1c10:	f383 8812 	msr	BASEPRI_MAX, r3
    1c14:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1c18:	4621      	mov	r1, r4
    1c1a:	4806      	ldr	r0, [pc, #24]	; (1c34 <log_0+0x5c>)
    1c1c:	f005 fcc4 	bl	75a8 <log_list_add_tail>
	__asm__ volatile(
    1c20:	f385 8811 	msr	BASEPRI, r5
    1c24:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    1c28:	f7ff fede 	bl	19e8 <z_log_msg_post_finalize>
}
    1c2c:	bd70      	pop	{r4, r5, r6, pc}
    1c2e:	bf00      	nop
    1c30:	20000024 	.word	0x20000024
    1c34:	200003bc 	.word	0x200003bc

00001c38 <z_log_printk>:
{
    1c38:	b530      	push	{r4, r5, lr}
    1c3a:	b0a3      	sub	sp, #140	; 0x8c
    1c3c:	4602      	mov	r2, r0
    1c3e:	460b      	mov	r3, r1
		} src_level_union = {
    1c40:	2500      	movs	r5, #0
			length = vsnprintk(str, sizeof(str), fmt, ap);
    1c42:	2181      	movs	r1, #129	; 0x81
    1c44:	a801      	add	r0, sp, #4
    1c46:	f7fe fee5 	bl	a14 <vsnprintk>
			msg = log_msg_hexdump_create(NULL, str, length);
    1c4a:	4602      	mov	r2, r0
    1c4c:	2881      	cmp	r0, #129	; 0x81
    1c4e:	bf28      	it	cs
    1c50:	2281      	movcs	r2, #129	; 0x81
    1c52:	a901      	add	r1, sp, #4
    1c54:	4628      	mov	r0, r5
    1c56:	f005 fd8e 	bl	7776 <log_msg_hexdump_create>
			if (msg == NULL) {
    1c5a:	b1b8      	cbz	r0, 1c8c <z_log_printk+0x54>
    1c5c:	4604      	mov	r4, r0
	msg->hdr.ids = src_level;
    1c5e:	8145      	strh	r5, [r0, #10]
	msg->hdr.timestamp = timestamp_func();
    1c60:	4b0b      	ldr	r3, [pc, #44]	; (1c90 <z_log_printk+0x58>)
    1c62:	681b      	ldr	r3, [r3, #0]
    1c64:	4798      	blx	r3
    1c66:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    1c68:	f04f 0320 	mov.w	r3, #32
    1c6c:	f3ef 8511 	mrs	r5, BASEPRI
    1c70:	f383 8812 	msr	BASEPRI_MAX, r3
    1c74:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1c78:	4621      	mov	r1, r4
    1c7a:	4806      	ldr	r0, [pc, #24]	; (1c94 <z_log_printk+0x5c>)
    1c7c:	f005 fc94 	bl	75a8 <log_list_add_tail>
	__asm__ volatile(
    1c80:	f385 8811 	msr	BASEPRI, r5
    1c84:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    1c88:	f7ff feae 	bl	19e8 <z_log_msg_post_finalize>
}
    1c8c:	b023      	add	sp, #140	; 0x8c
    1c8e:	bd30      	pop	{r4, r5, pc}
    1c90:	20000024 	.word	0x20000024
    1c94:	200003bc 	.word	0x200003bc

00001c98 <z_impl_log_panic>:
	if (panic_mode) {
    1c98:	4b12      	ldr	r3, [pc, #72]	; (1ce4 <z_impl_log_panic+0x4c>)
    1c9a:	781b      	ldrb	r3, [r3, #0]
    1c9c:	b103      	cbz	r3, 1ca0 <z_impl_log_panic+0x8>
    1c9e:	4770      	bx	lr
{
    1ca0:	b510      	push	{r4, lr}
	log_init();
    1ca2:	f7ff fcc7 	bl	1634 <log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
    1ca6:	2400      	movs	r4, #0
    1ca8:	e000      	b.n	1cac <z_impl_log_panic+0x14>
    1caa:	3401      	adds	r4, #1
    1cac:	4b0e      	ldr	r3, [pc, #56]	; (1ce8 <z_impl_log_panic+0x50>)
    1cae:	4a0f      	ldr	r2, [pc, #60]	; (1cec <z_impl_log_panic+0x54>)
    1cb0:	1a9b      	subs	r3, r3, r2
    1cb2:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1cb6:	da0c      	bge.n	1cd2 <z_impl_log_panic+0x3a>
	return &__log_backends_start[idx];
    1cb8:	480c      	ldr	r0, [pc, #48]	; (1cec <z_impl_log_panic+0x54>)
    1cba:	eb00 1004 	add.w	r0, r0, r4, lsl #4
	return backend->cb->active;
    1cbe:	6843      	ldr	r3, [r0, #4]
    1cc0:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    1cc2:	2b00      	cmp	r3, #0
    1cc4:	d0f1      	beq.n	1caa <z_impl_log_panic+0x12>
	backend->api->panic(backend);
    1cc6:	0123      	lsls	r3, r4, #4
    1cc8:	4a08      	ldr	r2, [pc, #32]	; (1cec <z_impl_log_panic+0x54>)
    1cca:	58d3      	ldr	r3, [r2, r3]
    1ccc:	695b      	ldr	r3, [r3, #20]
    1cce:	4798      	blx	r3
}
    1cd0:	e7eb      	b.n	1caa <z_impl_log_panic+0x12>
    1cd2:	2000      	movs	r0, #0
    1cd4:	f7ff fe5e 	bl	1994 <z_impl_log_process>
		while (log_process(false) == true) {
    1cd8:	2800      	cmp	r0, #0
    1cda:	d1fa      	bne.n	1cd2 <z_impl_log_panic+0x3a>
	panic_mode = true;
    1cdc:	4b01      	ldr	r3, [pc, #4]	; (1ce4 <z_impl_log_panic+0x4c>)
    1cde:	2201      	movs	r2, #1
    1ce0:	701a      	strb	r2, [r3, #0]
}
    1ce2:	bd10      	pop	{r4, pc}
    1ce4:	200009f9 	.word	0x200009f9
    1ce8:	00008ea0 	.word	0x00008ea0
    1cec:	00008e90 	.word	0x00008e90

00001cf0 <log_process_thread_func>:
{
    1cf0:	b508      	push	{r3, lr}
	log_init();
    1cf2:	f7ff fc9f 	bl	1634 <log_init>
	return z_impl_z_current_get();
    1cf6:	f004 fe7b 	bl	69f0 <z_impl_z_current_get>
	thread_set(k_current_get());
    1cfa:	f7ff fc47 	bl	158c <thread_set>
    1cfe:	e006      	b.n	1d0e <log_process_thread_func+0x1e>
	return z_impl_k_sem_take(sem, timeout);
    1d00:	f04f 32ff 	mov.w	r2, #4294967295
    1d04:	f04f 33ff 	mov.w	r3, #4294967295
    1d08:	4804      	ldr	r0, [pc, #16]	; (1d1c <log_process_thread_func+0x2c>)
    1d0a:	f004 fa8b 	bl	6224 <z_impl_k_sem_take>
    1d0e:	2000      	movs	r0, #0
    1d10:	f7ff fe40 	bl	1994 <z_impl_log_process>
		if (log_process(false) == false) {
    1d14:	2800      	cmp	r0, #0
    1d16:	d1fa      	bne.n	1d0e <log_process_thread_func+0x1e>
    1d18:	e7f2      	b.n	1d00 <log_process_thread_func+0x10>
    1d1a:	bf00      	nop
    1d1c:	20000114 	.word	0x20000114

00001d20 <z_log_free>:
{
    1d20:	b500      	push	{lr}
    1d22:	b083      	sub	sp, #12
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    1d24:	3804      	subs	r0, #4
    1d26:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    1d28:	f3bf 8f5b 	dmb	ish
    1d2c:	e850 3f00 	ldrex	r3, [r0]
    1d30:	1e5a      	subs	r2, r3, #1
    1d32:	e840 2100 	strex	r1, r2, [r0]
    1d36:	2900      	cmp	r1, #0
    1d38:	d1f8      	bne.n	1d2c <z_log_free+0xc>
    1d3a:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    1d3e:	2b01      	cmp	r3, #1
    1d40:	d002      	beq.n	1d48 <z_log_free+0x28>
}
    1d42:	b003      	add	sp, #12
    1d44:	f85d fb04 	ldr.w	pc, [sp], #4
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    1d48:	a901      	add	r1, sp, #4
    1d4a:	4802      	ldr	r0, [pc, #8]	; (1d54 <z_log_free+0x34>)
    1d4c:	f006 fd15 	bl	877a <k_mem_slab_free>
}
    1d50:	e7f7      	b.n	1d42 <z_log_free+0x22>
    1d52:	bf00      	nop
    1d54:	200003c4 	.word	0x200003c4

00001d58 <log_source_name_get>:
	return __log_const_start[source_id].name;
}

const char *log_source_name_get(uint32_t domain_id, uint32_t src_id)
{
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    1d58:	4b05      	ldr	r3, [pc, #20]	; (1d70 <log_source_name_get+0x18>)
    1d5a:	4a06      	ldr	r2, [pc, #24]	; (1d74 <log_source_name_get+0x1c>)
    1d5c:	1a9b      	subs	r3, r3, r2
    1d5e:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
    1d62:	d202      	bcs.n	1d6a <log_source_name_get+0x12>
	return __log_const_start[source_id].name;
    1d64:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
    1d68:	4770      	bx	lr
	return src_id < z_log_sources_count() ? log_name_get(src_id) : NULL;
    1d6a:	2000      	movs	r0, #0
}
    1d6c:	4770      	bx	lr
    1d6e:	bf00      	nop
    1d70:	00008e90 	.word	0x00008e90
    1d74:	00008e48 	.word	0x00008e48

00001d78 <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			uint32_t level)
{
    1d78:	b508      	push	{r3, lr}
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
    1d7a:	4b07      	ldr	r3, [pc, #28]	; (1d98 <log_backend_enable+0x20>)
    1d7c:	1ac3      	subs	r3, r0, r3
    1d7e:	111b      	asrs	r3, r3, #4
    1d80:	3301      	adds	r3, #1
	backend->cb->id = id;
    1d82:	6842      	ldr	r2, [r0, #4]
    1d84:	7113      	strb	r3, [r2, #4]
	backend->cb->ctx = ctx;
    1d86:	6843      	ldr	r3, [r0, #4]
    1d88:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    1d8a:	6843      	ldr	r3, [r0, #4]
    1d8c:	2201      	movs	r2, #1
    1d8e:	715a      	strb	r2, [r3, #5]

	log_backend_id_set(backend, id);
	backend_filter_set(backend, level);
	log_backend_activate(backend, ctx);

	z_log_notify_backend_enabled();
    1d90:	f7ff fcce 	bl	1730 <z_log_notify_backend_enabled>
}
    1d94:	bd08      	pop	{r3, pc}
    1d96:	bf00      	nop
    1d98:	00008e90 	.word	0x00008e90

00001d9c <cont_free>:
{
	atomic_inc(&msg->hdr.ref_cnt);
}

static void cont_free(struct log_msg_cont *cont)
{
    1d9c:	b510      	push	{r4, lr}
    1d9e:	b082      	sub	sp, #8
    1da0:	9001      	str	r0, [sp, #4]
	struct log_msg_cont *next;

	while (cont != NULL) {
    1da2:	9b01      	ldr	r3, [sp, #4]
    1da4:	b133      	cbz	r3, 1db4 <cont_free+0x18>
		next = cont->next;
    1da6:	681c      	ldr	r4, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    1da8:	a901      	add	r1, sp, #4
    1daa:	4803      	ldr	r0, [pc, #12]	; (1db8 <cont_free+0x1c>)
    1dac:	f006 fce5 	bl	877a <k_mem_slab_free>
		cont = next;
    1db0:	9401      	str	r4, [sp, #4]
    1db2:	e7f6      	b.n	1da2 <cont_free+0x6>
	}
}
    1db4:	b002      	add	sp, #8
    1db6:	bd10      	pop	{r4, pc}
    1db8:	200003e4 	.word	0x200003e4

00001dbc <log_msg_pool_init>:
{
    1dbc:	b508      	push	{r3, lr}
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    1dbe:	2320      	movs	r3, #32
    1dc0:	461a      	mov	r2, r3
    1dc2:	4902      	ldr	r1, [pc, #8]	; (1dcc <log_msg_pool_init+0x10>)
    1dc4:	4802      	ldr	r0, [pc, #8]	; (1dd0 <log_msg_pool_init+0x14>)
    1dc6:	f006 fcca 	bl	875e <k_mem_slab_init>
}
    1dca:	bd08      	pop	{r3, pc}
    1dcc:	20002760 	.word	0x20002760
    1dd0:	200003e4 	.word	0x200003e4

00001dd4 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    1dd4:	b510      	push	{r4, lr}
    1dd6:	b082      	sub	sp, #8
	union log_msg_chunk *msg = NULL;
    1dd8:	2300      	movs	r3, #0
    1dda:	9301      	str	r3, [sp, #4]
    1ddc:	2001      	movs	r0, #1
    1dde:	f7ff fdd9 	bl	1994 <z_impl_log_process>
    1de2:	4604      	mov	r4, r0
	int err;

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
    1de4:	f7ff fcb4 	bl	1750 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    1de8:	2200      	movs	r2, #0
    1dea:	2300      	movs	r3, #0
    1dec:	a901      	add	r1, sp, #4
    1dee:	4804      	ldr	r0, [pc, #16]	; (1e00 <log_msg_no_space_handle+0x2c>)
    1df0:	f003 ffe2 	bl	5db8 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    1df4:	b108      	cbz	r0, 1dfa <log_msg_no_space_handle+0x26>
    1df6:	2c00      	cmp	r4, #0
    1df8:	d1f0      	bne.n	1ddc <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
    1dfa:	9801      	ldr	r0, [sp, #4]
    1dfc:	b002      	add	sp, #8
    1dfe:	bd10      	pop	{r4, pc}
    1e00:	200003e4 	.word	0x200003e4

00001e04 <log_msg_chunk_alloc>:
{
    1e04:	b500      	push	{lr}
    1e06:	b083      	sub	sp, #12
	union log_msg_chunk *msg = NULL;
    1e08:	2300      	movs	r3, #0
    1e0a:	9301      	str	r3, [sp, #4]
		   block_on_alloc()
    1e0c:	f005 fc09 	bl	7622 <block_on_alloc>
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    1e10:	b150      	cbz	r0, 1e28 <log_msg_chunk_alloc+0x24>
    1e12:	2200      	movs	r2, #0
    1e14:	2300      	movs	r3, #0
    1e16:	a901      	add	r1, sp, #4
    1e18:	4807      	ldr	r0, [pc, #28]	; (1e38 <log_msg_chunk_alloc+0x34>)
    1e1a:	f003 ffcd 	bl	5db8 <k_mem_slab_alloc>
	if (err != 0) {
    1e1e:	b930      	cbnz	r0, 1e2e <log_msg_chunk_alloc+0x2a>
}
    1e20:	9801      	ldr	r0, [sp, #4]
    1e22:	b003      	add	sp, #12
    1e24:	f85d fb04 	ldr.w	pc, [sp], #4
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    1e28:	2200      	movs	r2, #0
    1e2a:	2300      	movs	r3, #0
    1e2c:	e7f3      	b.n	1e16 <log_msg_chunk_alloc+0x12>
		msg = log_msg_no_space_handle();
    1e2e:	f7ff ffd1 	bl	1dd4 <log_msg_no_space_handle>
    1e32:	9001      	str	r0, [sp, #4]
    1e34:	e7f4      	b.n	1e20 <log_msg_chunk_alloc+0x1c>
    1e36:	bf00      	nop
    1e38:	200003e4 	.word	0x200003e4

00001e3c <msg_free>:
{
    1e3c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1e3e:	b083      	sub	sp, #12
    1e40:	9001      	str	r0, [sp, #4]
	uint32_t nargs = log_msg_nargs_get(msg);
    1e42:	4604      	mov	r4, r0
    1e44:	f005 fc6d 	bl	7722 <log_msg_nargs_get>
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    1e48:	7a23      	ldrb	r3, [r4, #8]
	if (log_msg_is_std(msg) && nargs) {
    1e4a:	f013 0f01 	tst.w	r3, #1
    1e4e:	d101      	bne.n	1e54 <msg_free+0x18>
    1e50:	4606      	mov	r6, r0
    1e52:	bb50      	cbnz	r0, 1eaa <msg_free+0x6e>
	if (msg->hdr.params.generic.ext == 1) {
    1e54:	9b01      	ldr	r3, [sp, #4]
    1e56:	7a1a      	ldrb	r2, [r3, #8]
    1e58:	f012 0f02 	tst.w	r2, #2
    1e5c:	d128      	bne.n	1eb0 <msg_free+0x74>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    1e5e:	a901      	add	r1, sp, #4
    1e60:	4815      	ldr	r0, [pc, #84]	; (1eb8 <msg_free+0x7c>)
    1e62:	f006 fc8a 	bl	877a <k_mem_slab_free>
}
    1e66:	b003      	add	sp, #12
    1e68:	bdf0      	pop	{r4, r5, r6, r7, pc}
					smask = z_log_get_s_mask(
    1e6a:	9801      	ldr	r0, [sp, #4]
    1e6c:	f005 fc6e 	bl	774c <log_msg_str_get>
    1e70:	4631      	mov	r1, r6
    1e72:	f005 fbb3 	bl	75dc <z_log_get_s_mask>
					if (smask == 0U) {
    1e76:	4607      	mov	r7, r0
    1e78:	b988      	cbnz	r0, 1e9e <msg_free+0x62>
    1e7a:	e7eb      	b.n	1e54 <msg_free+0x18>
					z_log_free(buf);
    1e7c:	4628      	mov	r0, r5
    1e7e:	f7ff ff4f 	bl	1d20 <z_log_free>
		for (i = 0U; i < nargs; i++) {
    1e82:	3401      	adds	r4, #1
    1e84:	42b4      	cmp	r4, r6
    1e86:	d2e5      	bcs.n	1e54 <msg_free+0x18>
			void *buf = (void *)log_msg_arg_get(msg, i);
    1e88:	4621      	mov	r1, r4
    1e8a:	9801      	ldr	r0, [sp, #4]
    1e8c:	f005 fc4c 	bl	7728 <log_msg_arg_get>
    1e90:	4605      	mov	r5, r0
			if (log_is_strdup(buf)) {
    1e92:	f7ff fce7 	bl	1864 <log_is_strdup>
    1e96:	2800      	cmp	r0, #0
    1e98:	d0f3      	beq.n	1e82 <msg_free+0x46>
				if (smask == 0U) {
    1e9a:	2f00      	cmp	r7, #0
    1e9c:	d0e5      	beq.n	1e6a <msg_free+0x2e>
				if (smask & BIT(i)) {
    1e9e:	fa27 f304 	lsr.w	r3, r7, r4
    1ea2:	f013 0f01 	tst.w	r3, #1
    1ea6:	d0ec      	beq.n	1e82 <msg_free+0x46>
    1ea8:	e7e8      	b.n	1e7c <msg_free+0x40>
		uint32_t smask = 0U;
    1eaa:	2700      	movs	r7, #0
		for (i = 0U; i < nargs; i++) {
    1eac:	463c      	mov	r4, r7
    1eae:	e7e9      	b.n	1e84 <msg_free+0x48>
		cont_free(msg->payload.ext.next);
    1eb0:	6958      	ldr	r0, [r3, #20]
    1eb2:	f7ff ff73 	bl	1d9c <cont_free>
    1eb6:	e7d2      	b.n	1e5e <msg_free+0x22>
    1eb8:	200003e4 	.word	0x200003e4

00001ebc <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
    1ebc:	b40e      	push	{r1, r2, r3}
    1ebe:	b500      	push	{lr}
    1ec0:	b082      	sub	sp, #8
    1ec2:	4601      	mov	r1, r0
    1ec4:	ab03      	add	r3, sp, #12
    1ec6:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list args;
	int length = 0;

	va_start(args, fmt);
    1eca:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    1ecc:	4803      	ldr	r0, [pc, #12]	; (1edc <print_formatted+0x20>)
    1ece:	f7fe fe63 	bl	b98 <cbvprintf>
	va_end(args);

	return length;
}
    1ed2:	b002      	add	sp, #8
    1ed4:	f85d eb04 	ldr.w	lr, [sp], #4
    1ed8:	b003      	add	sp, #12
    1eda:	4770      	bx	lr
    1edc:	00007b51 	.word	0x00007b51

00001ee0 <timestamp_print>:
	output->control_block->offset = 0;
}

static int timestamp_print(const struct log_output *output,
			   uint32_t flags, uint32_t timestamp)
{
    1ee0:	b5f0      	push	{r4, r5, r6, r7, lr}
    1ee2:	b085      	sub	sp, #20
	bool format =
		(flags & LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP) |
		(flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG);


	if (!format) {
    1ee4:	f011 0f44 	tst.w	r1, #68	; 0x44
    1ee8:	d005      	beq.n	1ef6 <timestamp_print+0x16>
		length = print_formatted(output, "[%08lu] ", timestamp);
	} else if (freq != 0U) {
    1eea:	4b1a      	ldr	r3, [pc, #104]	; (1f54 <timestamp_print+0x74>)
    1eec:	681c      	ldr	r4, [r3, #0]
    1eee:	b934      	cbnz	r4, 1efe <timestamp_print+0x1e>
			length = print_formatted(output,
						 "[%02u:%02u:%02u.%03u,%03u] ",
						 hours, mins, seconds, ms, us);
		}
	} else {
		length = 0;
    1ef0:	2000      	movs	r0, #0
	}

	return length;
}
    1ef2:	b005      	add	sp, #20
    1ef4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		length = print_formatted(output, "[%08lu] ", timestamp);
    1ef6:	4918      	ldr	r1, [pc, #96]	; (1f58 <timestamp_print+0x78>)
    1ef8:	f7ff ffe0 	bl	1ebc <print_formatted>
    1efc:	e7f9      	b.n	1ef2 <timestamp_print+0x12>
		timestamp /= timestamp_div;
    1efe:	4b17      	ldr	r3, [pc, #92]	; (1f5c <timestamp_print+0x7c>)
    1f00:	6819      	ldr	r1, [r3, #0]
    1f02:	fbb2 f1f1 	udiv	r1, r2, r1
		total_seconds = timestamp / freq;
    1f06:	fbb1 f5f4 	udiv	r5, r1, r4
		hours = seconds / 3600U;
    1f0a:	4a15      	ldr	r2, [pc, #84]	; (1f60 <timestamp_print+0x80>)
    1f0c:	fba2 3205 	umull	r3, r2, r2, r5
    1f10:	0ad2      	lsrs	r2, r2, #11
		seconds -= hours * 3600U;
    1f12:	f44f 6661 	mov.w	r6, #3600	; 0xe10
    1f16:	fb06 5612 	mls	r6, r6, r2, r5
		mins = seconds / 60U;
    1f1a:	4b12      	ldr	r3, [pc, #72]	; (1f64 <timestamp_print+0x84>)
    1f1c:	fba3 7306 	umull	r7, r3, r3, r6
    1f20:	095b      	lsrs	r3, r3, #5
		remainder = timestamp % freq;
    1f22:	fb04 1115 	mls	r1, r4, r5, r1
		ms = (remainder * 1000U) / freq;
    1f26:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    1f2a:	fb05 f101 	mul.w	r1, r5, r1
    1f2e:	fbb1 f7f4 	udiv	r7, r1, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    1f32:	fb07 1114 	mls	r1, r7, r4, r1
    1f36:	fb05 f101 	mul.w	r1, r5, r1
    1f3a:	fbb1 f4f4 	udiv	r4, r1, r4
			length = print_formatted(output,
    1f3e:	9402      	str	r4, [sp, #8]
    1f40:	9701      	str	r7, [sp, #4]
    1f42:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
    1f46:	eba6 0181 	sub.w	r1, r6, r1, lsl #2
    1f4a:	9100      	str	r1, [sp, #0]
    1f4c:	4906      	ldr	r1, [pc, #24]	; (1f68 <timestamp_print+0x88>)
    1f4e:	f7ff ffb5 	bl	1ebc <print_formatted>
    1f52:	e7ce      	b.n	1ef2 <timestamp_print+0x12>
    1f54:	20000400 	.word	0x20000400
    1f58:	0000904c 	.word	0x0000904c
    1f5c:	20000404 	.word	0x20000404
    1f60:	91a2b3c5 	.word	0x91a2b3c5
    1f64:	88888889 	.word	0x88888889
    1f68:	00009058 	.word	0x00009058

00001f6c <color_print>:

static void color_print(const struct log_output *output,
			bool color, bool start, uint32_t level)
{
	if (color) {
    1f6c:	b161      	cbz	r1, 1f88 <color_print+0x1c>
{
    1f6e:	b508      	push	{r3, lr}
		const char *log_color = start && (colors[level] != NULL) ?
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    1f70:	b12a      	cbz	r2, 1f7e <color_print+0x12>
		const char *log_color = start && (colors[level] != NULL) ?
    1f72:	4a06      	ldr	r2, [pc, #24]	; (1f8c <color_print+0x20>)
    1f74:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1f78:	b912      	cbnz	r2, 1f80 <color_print+0x14>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    1f7a:	4a05      	ldr	r2, [pc, #20]	; (1f90 <color_print+0x24>)
    1f7c:	e000      	b.n	1f80 <color_print+0x14>
    1f7e:	4a04      	ldr	r2, [pc, #16]	; (1f90 <color_print+0x24>)
		print_formatted(output, "%s", log_color);
    1f80:	4904      	ldr	r1, [pc, #16]	; (1f94 <color_print+0x28>)
    1f82:	f7ff ff9b 	bl	1ebc <print_formatted>
	}
}
    1f86:	bd08      	pop	{r3, pc}
    1f88:	4770      	bx	lr
    1f8a:	bf00      	nop
    1f8c:	000090d8 	.word	0x000090d8
    1f90:	00009074 	.word	0x00009074
    1f94:	0000907c 	.word	0x0000907c

00001f98 <newline_print>:
	if (IS_ENABLED(CONFIG_LOG_BACKEND_NET) &&
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG) {
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    1f98:	f011 0f10 	tst.w	r1, #16
    1f9c:	d10b      	bne.n	1fb6 <newline_print+0x1e>
{
    1f9e:	b508      	push	{r3, lr}
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    1fa0:	f011 0f20 	tst.w	r1, #32
    1fa4:	d003      	beq.n	1fae <newline_print+0x16>
		print_formatted(ctx, "\n");
    1fa6:	4904      	ldr	r1, [pc, #16]	; (1fb8 <newline_print+0x20>)
    1fa8:	f7ff ff88 	bl	1ebc <print_formatted>
	} else {
		print_formatted(ctx, "\r\n");
	}
}
    1fac:	bd08      	pop	{r3, pc}
		print_formatted(ctx, "\r\n");
    1fae:	4903      	ldr	r1, [pc, #12]	; (1fbc <newline_print+0x24>)
    1fb0:	f7ff ff84 	bl	1ebc <print_formatted>
    1fb4:	e7fa      	b.n	1fac <newline_print+0x14>
    1fb6:	4770      	bx	lr
    1fb8:	000095a8 	.word	0x000095a8
    1fbc:	00009080 	.word	0x00009080

00001fc0 <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
    1fc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1fc4:	4605      	mov	r5, r0
    1fc6:	460f      	mov	r7, r1
    1fc8:	4616      	mov	r6, r2
    1fca:	4698      	mov	r8, r3
	newline_print(output, flags);
    1fcc:	9906      	ldr	r1, [sp, #24]
    1fce:	f7ff ffe3 	bl	1f98 <newline_print>

	for (int i = 0; i < prefix_offset; i++) {
    1fd2:	2400      	movs	r4, #0
    1fd4:	4544      	cmp	r4, r8
    1fd6:	da05      	bge.n	1fe4 <hexdump_line_print+0x24>
		print_formatted(output, " ");
    1fd8:	4923      	ldr	r1, [pc, #140]	; (2068 <hexdump_line_print+0xa8>)
    1fda:	4628      	mov	r0, r5
    1fdc:	f7ff ff6e 	bl	1ebc <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    1fe0:	3401      	adds	r4, #1
    1fe2:	e7f7      	b.n	1fd4 <hexdump_line_print+0x14>
	}

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    1fe4:	2400      	movs	r4, #0
    1fe6:	e009      	b.n	1ffc <hexdump_line_print+0x3c>
		if (i > 0 && !(i % 8)) {
			print_formatted(output, " ");
    1fe8:	491f      	ldr	r1, [pc, #124]	; (2068 <hexdump_line_print+0xa8>)
    1fea:	4628      	mov	r0, r5
    1fec:	f7ff ff66 	bl	1ebc <print_formatted>
    1ff0:	e00b      	b.n	200a <hexdump_line_print+0x4a>
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
    1ff2:	491e      	ldr	r1, [pc, #120]	; (206c <hexdump_line_print+0xac>)
    1ff4:	4628      	mov	r0, r5
    1ff6:	f7ff ff61 	bl	1ebc <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    1ffa:	3401      	adds	r4, #1
    1ffc:	2c0f      	cmp	r4, #15
    1ffe:	dc0c      	bgt.n	201a <hexdump_line_print+0x5a>
		if (i > 0 && !(i % 8)) {
    2000:	2c00      	cmp	r4, #0
    2002:	dd02      	ble.n	200a <hexdump_line_print+0x4a>
    2004:	f014 0f07 	tst.w	r4, #7
    2008:	d0ee      	beq.n	1fe8 <hexdump_line_print+0x28>
		if (i < length) {
    200a:	42b4      	cmp	r4, r6
    200c:	d2f1      	bcs.n	1ff2 <hexdump_line_print+0x32>
			print_formatted(output, "%02x ", data[i]);
    200e:	5d3a      	ldrb	r2, [r7, r4]
    2010:	4917      	ldr	r1, [pc, #92]	; (2070 <hexdump_line_print+0xb0>)
    2012:	4628      	mov	r0, r5
    2014:	f7ff ff52 	bl	1ebc <print_formatted>
    2018:	e7ef      	b.n	1ffa <hexdump_line_print+0x3a>
		}
	}

	print_formatted(output, "|");
    201a:	4916      	ldr	r1, [pc, #88]	; (2074 <hexdump_line_print+0xb4>)
    201c:	4628      	mov	r0, r5
    201e:	f7ff ff4d 	bl	1ebc <print_formatted>

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2022:	2400      	movs	r4, #0
    2024:	e009      	b.n	203a <hexdump_line_print+0x7a>
		if (i > 0 && !(i % 8)) {
			print_formatted(output, " ");
    2026:	4910      	ldr	r1, [pc, #64]	; (2068 <hexdump_line_print+0xa8>)
    2028:	4628      	mov	r0, r5
    202a:	f7ff ff47 	bl	1ebc <print_formatted>
    202e:	e00b      	b.n	2048 <hexdump_line_print+0x88>
		}

		if (i < length) {
			char c = (char)data[i];

			print_formatted(output, "%c",
    2030:	4911      	ldr	r1, [pc, #68]	; (2078 <hexdump_line_print+0xb8>)
    2032:	4628      	mov	r0, r5
    2034:	f7ff ff42 	bl	1ebc <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    2038:	3401      	adds	r4, #1
    203a:	2c0f      	cmp	r4, #15
    203c:	dc12      	bgt.n	2064 <hexdump_line_print+0xa4>
		if (i > 0 && !(i % 8)) {
    203e:	2c00      	cmp	r4, #0
    2040:	dd02      	ble.n	2048 <hexdump_line_print+0x88>
    2042:	f014 0f07 	tst.w	r4, #7
    2046:	d0ee      	beq.n	2026 <hexdump_line_print+0x66>
		if (i < length) {
    2048:	42b4      	cmp	r4, r6
    204a:	d206      	bcs.n	205a <hexdump_line_print+0x9a>
			char c = (char)data[i];
    204c:	5d3a      	ldrb	r2, [r7, r4]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
    204e:	f1a2 0320 	sub.w	r3, r2, #32
			print_formatted(output, "%c",
    2052:	2b5e      	cmp	r3, #94	; 0x5e
    2054:	d9ec      	bls.n	2030 <hexdump_line_print+0x70>
    2056:	222e      	movs	r2, #46	; 0x2e
    2058:	e7ea      	b.n	2030 <hexdump_line_print+0x70>
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
    205a:	4903      	ldr	r1, [pc, #12]	; (2068 <hexdump_line_print+0xa8>)
    205c:	4628      	mov	r0, r5
    205e:	f7ff ff2d 	bl	1ebc <print_formatted>
    2062:	e7e9      	b.n	2038 <hexdump_line_print+0x78>
		}
	}
}
    2064:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2068:	000090a8 	.word	0x000090a8
    206c:	0000908c 	.word	0x0000908c
    2070:	00009084 	.word	0x00009084
    2074:	00009090 	.word	0x00009090
    2078:	00009094 	.word	0x00009094

0000207c <ids_print>:
{
    207c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2080:	4680      	mov	r8, r0
    2082:	4616      	mov	r6, r2
    2084:	461d      	mov	r5, r3
    2086:	f9bd 7018 	ldrsh.w	r7, [sp, #24]
	if (level_on) {
    208a:	b959      	cbnz	r1, 20a4 <ids_print+0x28>
	int total = 0;
    208c:	2400      	movs	r4, #0
	if (source_id >= 0) {
    208e:	2f00      	cmp	r7, #0
    2090:	db1c      	blt.n	20cc <ids_print+0x50>
		total += print_formatted(output,
    2092:	b186      	cbz	r6, 20b6 <ids_print+0x3a>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    2094:	2301      	movs	r3, #1
    2096:	9a07      	ldr	r2, [sp, #28]
    2098:	4093      	lsls	r3, r2
				(func_on &&
    209a:	f013 0f10 	tst.w	r3, #16
    209e:	d118      	bne.n	20d2 <ids_print+0x56>
		total += print_formatted(output,
    20a0:	4e0d      	ldr	r6, [pc, #52]	; (20d8 <ids_print+0x5c>)
    20a2:	e009      	b.n	20b8 <ids_print+0x3c>
		total += print_formatted(output, "<%s> ", severity[level]);
    20a4:	4b0d      	ldr	r3, [pc, #52]	; (20dc <ids_print+0x60>)
    20a6:	9a07      	ldr	r2, [sp, #28]
    20a8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    20ac:	490c      	ldr	r1, [pc, #48]	; (20e0 <ids_print+0x64>)
    20ae:	f7ff ff05 	bl	1ebc <print_formatted>
    20b2:	4604      	mov	r4, r0
    20b4:	e7eb      	b.n	208e <ids_print+0x12>
		total += print_formatted(output,
    20b6:	4e08      	ldr	r6, [pc, #32]	; (20d8 <ids_print+0x5c>)
    20b8:	4639      	mov	r1, r7
    20ba:	4628      	mov	r0, r5
    20bc:	f7ff fe4c 	bl	1d58 <log_source_name_get>
    20c0:	4602      	mov	r2, r0
    20c2:	4631      	mov	r1, r6
    20c4:	4640      	mov	r0, r8
    20c6:	f7ff fef9 	bl	1ebc <print_formatted>
    20ca:	4404      	add	r4, r0
}
    20cc:	4620      	mov	r0, r4
    20ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		total += print_formatted(output,
    20d2:	4e04      	ldr	r6, [pc, #16]	; (20e4 <ids_print+0x68>)
    20d4:	e7f0      	b.n	20b8 <ids_print+0x3c>
    20d6:	bf00      	nop
    20d8:	00009098 	.word	0x00009098
    20dc:	00009114 	.word	0x00009114
    20e0:	000090a4 	.word	0x000090a4
    20e4:	000090a0 	.word	0x000090a0

000020e8 <prefix_print>:
}

static uint32_t prefix_print(const struct log_output *output,
			 uint32_t flags, bool func_on, uint32_t timestamp, uint8_t level,
			 uint8_t domain_id, int16_t source_id)
{
    20e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    20ec:	b085      	sub	sp, #20
    20ee:	4605      	mov	r5, r0
    20f0:	460c      	mov	r4, r1
    20f2:	4616      	mov	r6, r2
    20f4:	9303      	str	r3, [sp, #12]
    20f6:	f89d 8038 	ldrb.w	r8, [sp, #56]	; 0x38
	uint32_t length = 0U;

	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
    20fa:	f001 0b02 	and.w	fp, r1, #2
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    20fe:	f001 0a01 	and.w	sl, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    2102:	f3c1 09c0 	ubfx	r9, r1, #3, #1
	const char *tag = z_log_get_tag();
    2106:	f005 fa8a 	bl	761e <z_log_get_tag>
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (tag) {
    210a:	b1e8      	cbz	r0, 2148 <prefix_print+0x60>
    210c:	4602      	mov	r2, r0
		length += print_formatted(output, "%s ", tag);
    210e:	4913      	ldr	r1, [pc, #76]	; (215c <prefix_print+0x74>)
    2110:	4628      	mov	r0, r5
    2112:	f7ff fed3 	bl	1ebc <print_formatted>
    2116:	4607      	mov	r7, r0
	}

	if (stamp) {
    2118:	f1bb 0f00 	cmp.w	fp, #0
    211c:	d116      	bne.n	214c <prefix_print+0x64>
			output, "%s - - - - ",
			output->control_block->hostname ?
			output->control_block->hostname :
			"zephyr");
	} else {
		color_prefix(output, colors_on, level);
    211e:	4642      	mov	r2, r8
    2120:	4651      	mov	r1, sl
    2122:	4628      	mov	r0, r5
    2124:	f005 fb94 	bl	7850 <color_prefix>
	}

	length += ids_print(output, level_on, func_on,
    2128:	f8cd 8004 	str.w	r8, [sp, #4]
    212c:	f9bd 3040 	ldrsh.w	r3, [sp, #64]	; 0x40
    2130:	9300      	str	r3, [sp, #0]
    2132:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
    2136:	4632      	mov	r2, r6
    2138:	4649      	mov	r1, r9
    213a:	4628      	mov	r0, r5
    213c:	f7ff ff9e 	bl	207c <ids_print>
			domain_id, source_id, level);


	return length;
}
    2140:	4438      	add	r0, r7
    2142:	b005      	add	sp, #20
    2144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t length = 0U;
    2148:	2700      	movs	r7, #0
    214a:	e7e5      	b.n	2118 <prefix_print+0x30>
		length += timestamp_print(output, flags, timestamp);
    214c:	9a03      	ldr	r2, [sp, #12]
    214e:	4621      	mov	r1, r4
    2150:	4628      	mov	r0, r5
    2152:	f7ff fec5 	bl	1ee0 <timestamp_print>
    2156:	4407      	add	r7, r0
    2158:	e7e1      	b.n	211e <prefix_print+0x36>
    215a:	bf00      	nop
    215c:	000090ac 	.word	0x000090ac

00002160 <hexdump_print>:
{
    2160:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2164:	b089      	sub	sp, #36	; 0x24
    2166:	4607      	mov	r7, r0
    2168:	460e      	mov	r6, r1
    216a:	4691      	mov	r9, r2
    216c:	4698      	mov	r8, r3
	print_formatted(output, "%s", log_msg_str_get(msg));
    216e:	f005 faed 	bl	774c <log_msg_str_get>
    2172:	4602      	mov	r2, r0
    2174:	490e      	ldr	r1, [pc, #56]	; (21b0 <hexdump_print+0x50>)
    2176:	4630      	mov	r0, r6
    2178:	f7ff fea0 	bl	1ebc <print_formatted>
	uint32_t offset = 0U;
    217c:	2400      	movs	r4, #0
		length = sizeof(buf);
    217e:	2510      	movs	r5, #16
    2180:	9503      	str	r5, [sp, #12]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    2182:	4623      	mov	r3, r4
    2184:	aa03      	add	r2, sp, #12
    2186:	eb0d 0105 	add.w	r1, sp, r5
    218a:	4638      	mov	r0, r7
    218c:	f005 fb4b 	bl	7826 <log_msg_hexdump_data_get>
		if (length) {
    2190:	9a03      	ldr	r2, [sp, #12]
    2192:	b152      	cbz	r2, 21aa <hexdump_print+0x4a>
			hexdump_line_print(output, buf, length,
    2194:	f8cd 8000 	str.w	r8, [sp]
    2198:	464b      	mov	r3, r9
    219a:	eb0d 0105 	add.w	r1, sp, r5
    219e:	4630      	mov	r0, r6
    21a0:	f7ff ff0e 	bl	1fc0 <hexdump_line_print>
			offset += length;
    21a4:	9d03      	ldr	r5, [sp, #12]
    21a6:	442c      	add	r4, r5
		length = sizeof(buf);
    21a8:	e7e9      	b.n	217e <hexdump_print+0x1e>
}
    21aa:	b009      	add	sp, #36	; 0x24
    21ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    21b0:	0000907c 	.word	0x0000907c

000021b4 <raw_string_print>:
{
    21b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    21b6:	b083      	sub	sp, #12
    21b8:	4606      	mov	r6, r0
    21ba:	460c      	mov	r4, r1
	bool eol = false;
    21bc:	2700      	movs	r7, #0
	size_t offset = 0;
    21be:	463d      	mov	r5, r7
    21c0:	e00d      	b.n	21de <raw_string_print+0x2a>
			eol = (output->buf[length - 1] == '\n');
    21c2:	68a2      	ldr	r2, [r4, #8]
    21c4:	4413      	add	r3, r2
    21c6:	f813 7c01 	ldrb.w	r7, [r3, #-1]
    21ca:	2f0a      	cmp	r7, #10
    21cc:	bf14      	ite	ne
    21ce:	2700      	movne	r7, #0
    21d0:	2701      	moveq	r7, #1
		log_output_flush(output);
    21d2:	4620      	mov	r0, r4
    21d4:	f005 fcaf 	bl	7b36 <log_output_flush>
		offset += length;
    21d8:	9b01      	ldr	r3, [sp, #4]
    21da:	441d      	add	r5, r3
	} while (length > 0);
    21dc:	b173      	cbz	r3, 21fc <raw_string_print+0x48>
		length = output->size;
    21de:	68e3      	ldr	r3, [r4, #12]
    21e0:	9301      	str	r3, [sp, #4]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
    21e2:	462b      	mov	r3, r5
    21e4:	aa01      	add	r2, sp, #4
    21e6:	68a1      	ldr	r1, [r4, #8]
    21e8:	4630      	mov	r0, r6
    21ea:	f005 fb1c 	bl	7826 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
    21ee:	6863      	ldr	r3, [r4, #4]
    21f0:	9a01      	ldr	r2, [sp, #4]
    21f2:	601a      	str	r2, [r3, #0]
		if (length != 0) {
    21f4:	9b01      	ldr	r3, [sp, #4]
    21f6:	2b00      	cmp	r3, #0
    21f8:	d0eb      	beq.n	21d2 <raw_string_print+0x1e>
    21fa:	e7e2      	b.n	21c2 <raw_string_print+0xe>
	if (eol) {
    21fc:	b90f      	cbnz	r7, 2202 <raw_string_print+0x4e>
}
    21fe:	b003      	add	sp, #12
    2200:	bdf0      	pop	{r4, r5, r6, r7, pc}
		print_formatted(output, "\r");
    2202:	4902      	ldr	r1, [pc, #8]	; (220c <raw_string_print+0x58>)
    2204:	4620      	mov	r0, r4
    2206:	f7ff fe59 	bl	1ebc <print_formatted>
}
    220a:	e7f8      	b.n	21fe <raw_string_print+0x4a>
    220c:	000090b0 	.word	0x000090b0

00002210 <log_output_dropped_process>:
	postfix_print(output, flags, level);
	log_output_flush(output);
}

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
    2210:	b570      	push	{r4, r5, r6, lr}
    2212:	b082      	sub	sp, #8
    2214:	4604      	mov	r4, r0
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;
    2216:	6805      	ldr	r5, [r0, #0]

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    2218:	f242 730f 	movw	r3, #9999	; 0x270f
    221c:	428b      	cmp	r3, r1
    221e:	bf28      	it	cs
    2220:	460b      	movcs	r3, r1
    2222:	4a0e      	ldr	r2, [pc, #56]	; (225c <log_output_dropped_process+0x4c>)
    2224:	2105      	movs	r1, #5
    2226:	4668      	mov	r0, sp
    2228:	f004 ffb7 	bl	719a <snprintk>
    222c:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
		     output->control_block->ctx);
    222e:	6863      	ldr	r3, [r4, #4]
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    2230:	685b      	ldr	r3, [r3, #4]
    2232:	220b      	movs	r2, #11
    2234:	490a      	ldr	r1, [pc, #40]	; (2260 <log_output_dropped_process+0x50>)
    2236:	4628      	mov	r0, r5
    2238:	f005 fafd 	bl	7836 <buffer_write>
	buffer_write(outf, buf, len, output->control_block->ctx);
    223c:	6863      	ldr	r3, [r4, #4]
    223e:	685b      	ldr	r3, [r3, #4]
    2240:	4632      	mov	r2, r6
    2242:	4669      	mov	r1, sp
    2244:	4628      	mov	r0, r5
    2246:	f005 faf6 	bl	7836 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
		     output->control_block->ctx);
    224a:	6863      	ldr	r3, [r4, #4]
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    224c:	685b      	ldr	r3, [r3, #4]
    224e:	221b      	movs	r2, #27
    2250:	4904      	ldr	r1, [pc, #16]	; (2264 <log_output_dropped_process+0x54>)
    2252:	4628      	mov	r0, r5
    2254:	f005 faef 	bl	7836 <buffer_write>
}
    2258:	b002      	add	sp, #8
    225a:	bd70      	pop	{r4, r5, r6, pc}
    225c:	000090b4 	.word	0x000090b4
    2260:	00009108 	.word	0x00009108
    2264:	000090ec 	.word	0x000090ec

00002268 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    2268:	4b07      	ldr	r3, [pc, #28]	; (2288 <log_output_timestamp_freq_set+0x20>)
    226a:	2201      	movs	r2, #1
    226c:	601a      	str	r2, [r3, #0]
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    226e:	4b07      	ldr	r3, [pc, #28]	; (228c <log_output_timestamp_freq_set+0x24>)
    2270:	4298      	cmp	r0, r3
    2272:	d905      	bls.n	2280 <log_output_timestamp_freq_set+0x18>
		frequency /= 2U;
    2274:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    2276:	4a04      	ldr	r2, [pc, #16]	; (2288 <log_output_timestamp_freq_set+0x20>)
    2278:	6813      	ldr	r3, [r2, #0]
    227a:	005b      	lsls	r3, r3, #1
    227c:	6013      	str	r3, [r2, #0]
    227e:	e7f6      	b.n	226e <log_output_timestamp_freq_set+0x6>
	}

	freq = frequency;
    2280:	4b03      	ldr	r3, [pc, #12]	; (2290 <log_output_timestamp_freq_set+0x28>)
    2282:	6018      	str	r0, [r3, #0]
}
    2284:	4770      	bx	lr
    2286:	bf00      	nop
    2288:	20000404 	.word	0x20000404
    228c:	000f4240 	.word	0x000f4240
    2290:	20000400 	.word	0x20000400

00002294 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    2294:	4b01      	ldr	r3, [pc, #4]	; (229c <log_backend_rtt_init+0x8>)
    2296:	2201      	movs	r2, #1
    2298:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    229a:	4770      	bx	lr
    229c:	200009fa 	.word	0x200009fa

000022a0 <on_failed_write>:
{
    22a0:	b508      	push	{r3, lr}
	if (retry_cnt == 0) {
    22a2:	b918      	cbnz	r0, 22ac <on_failed_write+0xc>
		host_present = false;
    22a4:	4b08      	ldr	r3, [pc, #32]	; (22c8 <on_failed_write+0x28>)
    22a6:	2200      	movs	r2, #0
    22a8:	701a      	strb	r2, [r3, #0]
}
    22aa:	bd08      	pop	{r3, pc}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    22ac:	4b07      	ldr	r3, [pc, #28]	; (22cc <on_failed_write+0x2c>)
    22ae:	781b      	ldrb	r3, [r3, #0]
	} else if (is_sync_mode()) {
    22b0:	b123      	cbz	r3, 22bc <on_failed_write+0x1c>
	z_impl_k_busy_wait(usec_to_wait);
    22b2:	f241 3088 	movw	r0, #5000	; 0x1388
    22b6:	f006 fcaf 	bl	8c18 <z_impl_k_busy_wait>
}
    22ba:	e7f6      	b.n	22aa <on_failed_write+0xa>
	return z_impl_k_sleep(timeout);
    22bc:	20a4      	movs	r0, #164	; 0xa4
    22be:	2100      	movs	r1, #0
    22c0:	f004 fb6a 	bl	6998 <z_impl_k_sleep>
}
    22c4:	e7f1      	b.n	22aa <on_failed_write+0xa>
    22c6:	bf00      	nop
    22c8:	200009fa 	.word	0x200009fa
    22cc:	200009fb 	.word	0x200009fb

000022d0 <on_write>:
{
    22d0:	b538      	push	{r3, r4, r5, lr}
    22d2:	4604      	mov	r4, r0
	host_present = true;
    22d4:	4b0a      	ldr	r3, [pc, #40]	; (2300 <on_write+0x30>)
    22d6:	2201      	movs	r2, #1
    22d8:	701a      	strb	r2, [r3, #0]
	return panic_mode;
    22da:	4b0a      	ldr	r3, [pc, #40]	; (2304 <on_write+0x34>)
    22dc:	781b      	ldrb	r3, [r3, #0]
	if (is_panic_mode()) {
    22de:	b903      	cbnz	r3, 22e2 <on_write+0x12>
}
    22e0:	bd38      	pop	{r3, r4, r5, pc}
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    22e2:	2000      	movs	r0, #0
    22e4:	f003 fb4c 	bl	5980 <SEGGER_RTT_HasDataUp>
    22e8:	2800      	cmp	r0, #0
    22ea:	d0f9      	beq.n	22e0 <on_write+0x10>
    22ec:	4b04      	ldr	r3, [pc, #16]	; (2300 <on_write+0x30>)
    22ee:	781b      	ldrb	r3, [r3, #0]
    22f0:	2b00      	cmp	r3, #0
    22f2:	d0f5      	beq.n	22e0 <on_write+0x10>
			on_failed_write(retry_cnt--);
    22f4:	1e65      	subs	r5, r4, #1
    22f6:	4620      	mov	r0, r4
    22f8:	f7ff ffd2 	bl	22a0 <on_failed_write>
    22fc:	462c      	mov	r4, r5
    22fe:	e7f0      	b.n	22e2 <on_write+0x12>
    2300:	200009fa 	.word	0x200009fa
    2304:	200009fb 	.word	0x200009fb

00002308 <data_out_block_mode>:
{
    2308:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    230c:	4606      	mov	r6, r0
    230e:	460d      	mov	r5, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
    2310:	2704      	movs	r7, #4
    2312:	e00d      	b.n	2330 <data_out_block_mode+0x28>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    2314:	462a      	mov	r2, r5
    2316:	4631      	mov	r1, r6
    2318:	2000      	movs	r0, #0
    231a:	f003 fa97 	bl	584c <SEGGER_RTT_WriteSkipNoLock>
    231e:	4604      	mov	r4, r0
    2320:	e01c      	b.n	235c <data_out_block_mode+0x54>
			on_write(retry_cnt);
    2322:	4638      	mov	r0, r7
    2324:	f7ff ffd4 	bl	22d0 <on_write>
	} while ((ret == 0) && host_present);
    2328:	bb1c      	cbnz	r4, 2372 <data_out_block_mode+0x6a>
    232a:	4b16      	ldr	r3, [pc, #88]	; (2384 <data_out_block_mode+0x7c>)
    232c:	781b      	ldrb	r3, [r3, #0]
    232e:	b303      	cbz	r3, 2372 <data_out_block_mode+0x6a>
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    2330:	4b15      	ldr	r3, [pc, #84]	; (2388 <data_out_block_mode+0x80>)
    2332:	781b      	ldrb	r3, [r3, #0]
		if (!is_sync_mode()) {
    2334:	2b00      	cmp	r3, #0
    2336:	d1ed      	bne.n	2314 <data_out_block_mode+0xc>
	return z_impl_k_mutex_lock(mutex, timeout);
    2338:	f8df 8050 	ldr.w	r8, [pc, #80]	; 238c <data_out_block_mode+0x84>
    233c:	f04f 32ff 	mov.w	r2, #4294967295
    2340:	f04f 33ff 	mov.w	r3, #4294967295
    2344:	4640      	mov	r0, r8
    2346:	f003 fe7b 	bl	6040 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    234a:	462a      	mov	r2, r5
    234c:	4631      	mov	r1, r6
    234e:	2000      	movs	r0, #0
    2350:	f003 fa7c 	bl	584c <SEGGER_RTT_WriteSkipNoLock>
    2354:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    2356:	4640      	mov	r0, r8
    2358:	f003 fefc 	bl	6154 <z_impl_k_mutex_unlock>
		if (ret) {
    235c:	2c00      	cmp	r4, #0
    235e:	d1e0      	bne.n	2322 <data_out_block_mode+0x1a>
		} else if (host_present) {
    2360:	4b08      	ldr	r3, [pc, #32]	; (2384 <data_out_block_mode+0x7c>)
    2362:	781b      	ldrb	r3, [r3, #0]
    2364:	2b00      	cmp	r3, #0
    2366:	d0df      	beq.n	2328 <data_out_block_mode+0x20>
			retry_cnt--;
    2368:	3f01      	subs	r7, #1
			on_failed_write(retry_cnt);
    236a:	4638      	mov	r0, r7
    236c:	f7ff ff98 	bl	22a0 <on_failed_write>
    2370:	e7da      	b.n	2328 <data_out_block_mode+0x20>
	return ((ret == 0) && host_present) ? 0 : length;
    2372:	b914      	cbnz	r4, 237a <data_out_block_mode+0x72>
    2374:	4b03      	ldr	r3, [pc, #12]	; (2384 <data_out_block_mode+0x7c>)
    2376:	781b      	ldrb	r3, [r3, #0]
    2378:	b903      	cbnz	r3, 237c <data_out_block_mode+0x74>
    237a:	462c      	mov	r4, r5
}
    237c:	4620      	mov	r0, r4
    237e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2382:	bf00      	nop
    2384:	200009fa 	.word	0x200009fa
    2388:	200009fb 	.word	0x200009fb
    238c:	20000100 	.word	0x20000100

00002390 <panic>:

static void panic(struct log_backend const *const backend)
{
    2390:	b508      	push	{r3, lr}
	panic_mode = true;
    2392:	4b03      	ldr	r3, [pc, #12]	; (23a0 <panic+0x10>)
    2394:	2201      	movs	r2, #1
    2396:	701a      	strb	r2, [r3, #0]
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
    2398:	4802      	ldr	r0, [pc, #8]	; (23a4 <panic+0x14>)
    239a:	f005 fbcc 	bl	7b36 <log_output_flush>
	log_backend_std_panic(&log_output_rtt);
}
    239e:	bd08      	pop	{r3, pc}
    23a0:	200009fb 	.word	0x200009fb
    23a4:	00009154 	.word	0x00009154

000023a8 <dropped>:

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
    23a8:	b508      	push	{r3, lr}
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
    23aa:	4802      	ldr	r0, [pc, #8]	; (23b4 <dropped+0xc>)
    23ac:	f7ff ff30 	bl	2210 <log_output_dropped_process>
	ARG_UNUSED(backend);

	log_backend_std_dropped(&log_output_rtt, cnt);
}
    23b0:	bd08      	pop	{r3, pc}
    23b2:	bf00      	nop
    23b4:	00009154 	.word	0x00009154

000023b8 <put>:
{
    23b8:	b510      	push	{r4, lr}
    23ba:	460c      	mov	r4, r1
	log_msg_get(msg);
    23bc:	4608      	mov	r0, r1
    23be:	f005 f9a3 	bl	7708 <log_msg_get>
	log_output_msg_process(output, msg, flags);
    23c2:	220f      	movs	r2, #15
    23c4:	4621      	mov	r1, r4
    23c6:	4803      	ldr	r0, [pc, #12]	; (23d4 <put+0x1c>)
    23c8:	f005 fbde 	bl	7b88 <log_output_msg_process>
	log_msg_put(msg);
    23cc:	4620      	mov	r0, r4
    23ce:	f005 f9bf 	bl	7750 <log_msg_put>
}
    23d2:	bd10      	pop	{r4, pc}
    23d4:	00009154 	.word	0x00009154

000023d8 <pm_system_resume>:
	}
	k_spin_unlock(&pm_notifier_lock, pm_notifier_key);
}

void pm_system_resume(void)
{
    23d8:	b570      	push	{r4, r5, r6, lr}
    23da:	b084      	sub	sp, #16
	uint8_t id = _current_cpu->id;
    23dc:	4b2c      	ldr	r3, [pc, #176]	; (2490 <pm_system_resume+0xb8>)
    23de:	7d1c      	ldrb	r4, [r3, #20]
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_clear_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    23e0:	f004 031f 	and.w	r3, r4, #31
    23e4:	2201      	movs	r2, #1
    23e6:	409a      	lsls	r2, r3
	atomic_val_t old;

	old = atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    23e8:	0961      	lsrs	r1, r4, #5
    23ea:	4b2a      	ldr	r3, [pc, #168]	; (2494 <pm_system_resume+0xbc>)
    23ec:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    23f0:	43d0      	mvns	r0, r2
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    23f2:	f3bf 8f5b 	dmb	ish
    23f6:	e853 1f00 	ldrex	r1, [r3]
    23fa:	ea01 0500 	and.w	r5, r1, r0
    23fe:	e843 5600 	strex	r6, r5, [r3]
    2402:	2e00      	cmp	r6, #0
    2404:	d1f7      	bne.n	23f6 <pm_system_resume+0x1e>
    2406:	f3bf 8f5b 	dmb	ish
	 * that caused the wake. This hook will be called from the ISR.
	 * For such CPU LPS states, do post operations and restores here.
	 * The kernel scheduler will get control after the ISR finishes
	 * and it may schedule another thread.
	 */
	if (atomic_test_and_clear_bit(z_post_ops_required, id)) {
    240a:	420a      	tst	r2, r1
    240c:	d03d      	beq.n	248a <pm_system_resume+0xb2>
		exit_pos_ops(z_power_states[id]);
    240e:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    2412:	009a      	lsls	r2, r3, #2
    2414:	4b20      	ldr	r3, [pc, #128]	; (2498 <pm_system_resume+0xc0>)
    2416:	4413      	add	r3, r2
    2418:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    241c:	ab04      	add	r3, sp, #16
    241e:	e903 0007 	stmdb	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
    2422:	4b1e      	ldr	r3, [pc, #120]	; (249c <pm_system_resume+0xc4>)
    2424:	b163      	cbz	r3, 2440 <pm_system_resume+0x68>
		pm_power_state_exit_post_ops(info);
    2426:	f005 fd06 	bl	7e36 <pm_power_state_exit_post_ops>
	__asm__ volatile(
    242a:	f04f 0320 	mov.w	r3, #32
    242e:	f3ef 8611 	mrs	r6, BASEPRI
    2432:	f383 8812 	msr	BASEPRI_MAX, r3
    2436:	f3bf 8f6f 	isb	sy
    243a:	4b19      	ldr	r3, [pc, #100]	; (24a0 <pm_system_resume+0xc8>)
    243c:	681d      	ldr	r5, [r3, #0]
    243e:	e00a      	b.n	2456 <pm_system_resume+0x7e>
	__asm__ volatile(
    2440:	2300      	movs	r3, #0
    2442:	f383 8811 	msr	BASEPRI, r3
    2446:	f3bf 8f6f 	isb	sy
}
    244a:	e7ee      	b.n	242a <pm_system_resume+0x52>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    244c:	462b      	mov	r3, r5
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    244e:	b10d      	cbz	r5, 2454 <pm_system_resume+0x7c>
	return node->next;
    2450:	682b      	ldr	r3, [r5, #0]
    2452:	b16b      	cbz	r3, 2470 <pm_system_resume+0x98>
{
    2454:	461d      	mov	r5, r3
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2456:	b15d      	cbz	r5, 2470 <pm_system_resume+0x98>
			callback = notifier->state_exit;
    2458:	68aa      	ldr	r2, [r5, #8]
		if (callback) {
    245a:	2a00      	cmp	r2, #0
    245c:	d0f6      	beq.n	244c <pm_system_resume+0x74>
			callback(z_power_states[_current_cpu->id].state);
    245e:	4b0c      	ldr	r3, [pc, #48]	; (2490 <pm_system_resume+0xb8>)
    2460:	7d1b      	ldrb	r3, [r3, #20]
    2462:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2466:	0099      	lsls	r1, r3, #2
    2468:	4b0b      	ldr	r3, [pc, #44]	; (2498 <pm_system_resume+0xc0>)
    246a:	5c58      	ldrb	r0, [r3, r1]
    246c:	4790      	blx	r2
    246e:	e7ed      	b.n	244c <pm_system_resume+0x74>
	__asm__ volatile(
    2470:	f386 8811 	msr	BASEPRI, r6
    2474:	f3bf 8f6f 	isb	sy
		pm_state_notify(false);
		z_power_states[id] = (struct pm_state_info){PM_STATE_ACTIVE,
    2478:	4807      	ldr	r0, [pc, #28]	; (2498 <pm_system_resume+0xc0>)
    247a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    247e:	00a2      	lsls	r2, r4, #2
    2480:	1881      	adds	r1, r0, r2
    2482:	2300      	movs	r3, #0
    2484:	5083      	str	r3, [r0, r2]
    2486:	604b      	str	r3, [r1, #4]
    2488:	608b      	str	r3, [r1, #8]
			0, 0};
	}
}
    248a:	b004      	add	sp, #16
    248c:	bd70      	pop	{r4, r5, r6, pc}
    248e:	bf00      	nop
    2490:	200009bc 	.word	0x200009bc
    2494:	20000434 	.word	0x20000434
    2498:	20000438 	.word	0x20000438
    249c:	00007e37 	.word	0x00007e37
    24a0:	2000042c 	.word	0x2000042c

000024a4 <pm_system_suspend>:

	return ret;
}

bool pm_system_suspend(int32_t ticks)
{
    24a4:	b5f0      	push	{r4, r5, r6, r7, lr}
    24a6:	b089      	sub	sp, #36	; 0x24
    24a8:	4605      	mov	r5, r0
	bool ret = true;
	uint8_t id = _current_cpu->id;
    24aa:	4b55      	ldr	r3, [pc, #340]	; (2600 <pm_system_suspend+0x15c>)
    24ac:	7d1c      	ldrb	r4, [r3, #20]
 *
 * @return true if the bit was set, false if it wasn't.
 */
static inline bool atomic_test_and_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    24ae:	f004 031f 	and.w	r3, r4, #31
    24b2:	2201      	movs	r2, #1
    24b4:	409a      	lsls	r2, r3
	atomic_val_t old;

	old = atomic_or(ATOMIC_ELEM(target, bit), mask);
    24b6:	0961      	lsrs	r1, r4, #5
    24b8:	4b52      	ldr	r3, [pc, #328]	; (2604 <pm_system_suspend+0x160>)
    24ba:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    24be:	f3bf 8f5b 	dmb	ish
    24c2:	e853 1f00 	ldrex	r1, [r3]
    24c6:	ea41 0002 	orr.w	r0, r1, r2
    24ca:	e843 0600 	strex	r6, r0, [r3]
    24ce:	2e00      	cmp	r6, #0
    24d0:	d1f7      	bne.n	24c2 <pm_system_suspend+0x1e>
    24d2:	f3bf 8f5b 	dmb	ish

	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);

	if (!atomic_test_and_set_bit(z_power_states_forced, id)) {
    24d6:	420a      	tst	r2, r1
    24d8:	d017      	beq.n	250a <pm_system_suspend+0x66>
		z_power_states[id] = pm_policy_next_state(id, ticks);
	}

	if (z_power_states[id].state == PM_STATE_ACTIVE) {
    24da:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    24de:	4a4a      	ldr	r2, [pc, #296]	; (2608 <pm_system_suspend+0x164>)
    24e0:	f812 3023 	ldrb.w	r3, [r2, r3, lsl #2]
    24e4:	2b00      	cmp	r3, #0
    24e6:	f000 8088 	beq.w	25fa <pm_system_suspend+0x156>
				   z_power_states[id].state);
		ret = false;
		goto end;
	}

	if (ticks != K_TICKS_FOREVER) {
    24ea:	f1b5 3fff 	cmp.w	r5, #4294967295
    24ee:	d11c      	bne.n	252a <pm_system_suspend+0x86>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    24f0:	f003 ff40 	bl	6374 <k_sched_lock>
	__asm__ volatile(
    24f4:	f04f 0320 	mov.w	r3, #32
    24f8:	f3ef 8611 	mrs	r6, BASEPRI
    24fc:	f383 8812 	msr	BASEPRI_MAX, r3
    2500:	f3bf 8f6f 	isb	sy
	return list->head;
    2504:	4b41      	ldr	r3, [pc, #260]	; (260c <pm_system_suspend+0x168>)
    2506:	681d      	ldr	r5, [r3, #0]
    2508:	e02a      	b.n	2560 <pm_system_suspend+0xbc>
		z_power_states[id] = pm_policy_next_state(id, ticks);
    250a:	eb04 0644 	add.w	r6, r4, r4, lsl #1
    250e:	4b3e      	ldr	r3, [pc, #248]	; (2608 <pm_system_suspend+0x164>)
    2510:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    2514:	466f      	mov	r7, sp
    2516:	462a      	mov	r2, r5
    2518:	4621      	mov	r1, r4
    251a:	4638      	mov	r0, r7
    251c:	f005 fb73 	bl	7c06 <pm_policy_next_state>
    2520:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    2524:	e886 0007 	stmia.w	r6, {r0, r1, r2}
    2528:	e7d7      	b.n	24da <pm_system_suspend+0x36>
		     k_us_to_ticks_ceil32(
    252a:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    252e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2532:	689b      	ldr	r3, [r3, #8]
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    2534:	0c59      	lsrs	r1, r3, #17
    2536:	03d8      	lsls	r0, r3, #15
    2538:	4e35      	ldr	r6, [pc, #212]	; (2610 <pm_system_suspend+0x16c>)
    253a:	4a36      	ldr	r2, [pc, #216]	; (2614 <pm_system_suspend+0x170>)
    253c:	2300      	movs	r3, #0
    253e:	1980      	adds	r0, r0, r6
    2540:	f04f 0600 	mov.w	r6, #0
    2544:	eb46 0101 	adc.w	r1, r6, r1
    2548:	f7fd ff8a 	bl	460 <__aeabi_uldivmod>
		z_set_timeout_expiry(ticks -
    254c:	2101      	movs	r1, #1
    254e:	1a28      	subs	r0, r5, r0
    2550:	f006 fb33 	bl	8bba <z_set_timeout_expiry>
    2554:	e7cc      	b.n	24f0 <pm_system_suspend+0x4c>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2556:	462b      	mov	r3, r5
Z_GENLIST_PEEK_NEXT(slist, snode)
    2558:	b10d      	cbz	r5, 255e <pm_system_suspend+0xba>
	return node->next;
    255a:	682b      	ldr	r3, [r5, #0]
    255c:	b16b      	cbz	r3, 257a <pm_system_suspend+0xd6>
{
    255e:	461d      	mov	r5, r3
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2560:	b15d      	cbz	r5, 257a <pm_system_suspend+0xd6>
			callback = notifier->state_entry;
    2562:	686a      	ldr	r2, [r5, #4]
		if (callback) {
    2564:	2a00      	cmp	r2, #0
    2566:	d0f6      	beq.n	2556 <pm_system_suspend+0xb2>
			callback(z_power_states[_current_cpu->id].state);
    2568:	4b25      	ldr	r3, [pc, #148]	; (2600 <pm_system_suspend+0x15c>)
    256a:	7d1b      	ldrb	r3, [r3, #20]
    256c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    2570:	4925      	ldr	r1, [pc, #148]	; (2608 <pm_system_suspend+0x164>)
    2572:	f811 0023 	ldrb.w	r0, [r1, r3, lsl #2]
    2576:	4790      	blx	r2
    2578:	e7ed      	b.n	2556 <pm_system_suspend+0xb2>
	__asm__ volatile(
    257a:	f386 8811 	msr	BASEPRI, r6
    257e:	f3bf 8f6f 	isb	sy
 *
 * @return N/A
 */
static inline void atomic_set_bit(atomic_t *target, int bit)
{
	atomic_val_t mask = ATOMIC_MASK(bit);
    2582:	f004 031f 	and.w	r3, r4, #31
    2586:	2101      	movs	r1, #1
    2588:	4099      	lsls	r1, r3

	(void)atomic_or(ATOMIC_ELEM(target, bit), mask);
    258a:	0963      	lsrs	r3, r4, #5
    258c:	4a22      	ldr	r2, [pc, #136]	; (2618 <pm_system_suspend+0x174>)
    258e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    2592:	f3bf 8f5b 	dmb	ish
    2596:	e853 2f00 	ldrex	r2, [r3]
    259a:	430a      	orrs	r2, r1
    259c:	e843 2000 	strex	r0, r2, [r3]
    25a0:	2800      	cmp	r0, #0
    25a2:	d1f8      	bne.n	2596 <pm_system_suspend+0xf2>
    25a4:	f3bf 8f5b 	dmb	ish
	pm_stats_start();
	/* Enter power state */
	pm_state_notify(true);
	atomic_set_bit(z_post_ops_required, id);
	pm_state_set(z_power_states[id]);
    25a8:	eb04 0344 	add.w	r3, r4, r4, lsl #1
    25ac:	4a16      	ldr	r2, [pc, #88]	; (2608 <pm_system_suspend+0x164>)
    25ae:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    25b2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    25b6:	ab08      	add	r3, sp, #32
    25b8:	e903 0007 	stmdb	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
    25bc:	4b17      	ldr	r3, [pc, #92]	; (261c <pm_system_suspend+0x178>)
    25be:	b10b      	cbz	r3, 25c4 <pm_system_suspend+0x120>
		pm_power_state_set(info);
    25c0:	f005 fc26 	bl	7e10 <pm_power_state_set>
	if (atomic_add(&z_cpus_active, 1) == 0) {
		pm_resume_devices();
	}
#endif
	pm_stats_update(z_power_states[id].state);
	pm_system_resume();
    25c4:	f7ff ff08 	bl	23d8 <pm_system_resume>
	k_sched_unlock();
    25c8:	f004 f8d2 	bl	6770 <k_sched_unlock>
	bool ret = true;
    25cc:	2001      	movs	r0, #1
	atomic_val_t mask = ATOMIC_MASK(bit);
    25ce:	f004 021f 	and.w	r2, r4, #31
    25d2:	2301      	movs	r3, #1
    25d4:	4093      	lsls	r3, r2
	(void)atomic_and(ATOMIC_ELEM(target, bit), ~mask);
    25d6:	0964      	lsrs	r4, r4, #5
    25d8:	4a0a      	ldr	r2, [pc, #40]	; (2604 <pm_system_suspend+0x160>)
    25da:	eb02 0484 	add.w	r4, r2, r4, lsl #2
    25de:	43db      	mvns	r3, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    25e0:	f3bf 8f5b 	dmb	ish
    25e4:	e854 2f00 	ldrex	r2, [r4]
    25e8:	401a      	ands	r2, r3
    25ea:	e844 2100 	strex	r1, r2, [r4]
    25ee:	2900      	cmp	r1, #0
    25f0:	d1f8      	bne.n	25e4 <pm_system_suspend+0x140>
    25f2:	f3bf 8f5b 	dmb	ish
				   z_power_states[id].state);

end:
	atomic_clear_bit(z_power_states_forced, id);
	return ret;
}
    25f6:	b009      	add	sp, #36	; 0x24
    25f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ret = false;
    25fa:	2000      	movs	r0, #0
    25fc:	e7e7      	b.n	25ce <pm_system_suspend+0x12a>
    25fe:	bf00      	nop
    2600:	200009bc 	.word	0x200009bc
    2604:	20000444 	.word	0x20000444
    2608:	20000438 	.word	0x20000438
    260c:	2000042c 	.word	0x2000042c
    2610:	000f423f 	.word	0x000f423f
    2614:	000f4240 	.word	0x000f4240
    2618:	20000434 	.word	0x20000434
    261c:	00007e11 	.word	0x00007e11

00002620 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    2620:	4901      	ldr	r1, [pc, #4]	; (2628 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    2622:	2210      	movs	r2, #16
	str	r2, [r1]
    2624:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    2626:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    2628:	e000ed10 	.word	0xe000ed10

0000262c <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    262c:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    262e:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    2630:	f380 8811 	msr	BASEPRI, r0
	isb
    2634:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    2638:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    263c:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    263e:	b662      	cpsie	i
	isb
    2640:	f3bf 8f6f 	isb	sy

	bx	lr
    2644:	4770      	bx	lr
    2646:	bf00      	nop

00002648 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    2648:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    264a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    264c:	f381 8811 	msr	BASEPRI, r1

	wfe
    2650:	bf20      	wfe

	msr	BASEPRI, r0
    2652:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    2656:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    2658:	4770      	bx	lr
    265a:	bf00      	nop

0000265c <esf_dump>:
#include <kernel_arch_data.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

static void esf_dump(const z_arch_esf_t *esf)
{
    265c:	b570      	push	{r4, r5, r6, lr}
    265e:	b082      	sub	sp, #8
    2660:	4604      	mov	r4, r0
    2662:	4d1f      	ldr	r5, [pc, #124]	; (26e0 <esf_dump+0x84>)
    2664:	4b1f      	ldr	r3, [pc, #124]	; (26e4 <esf_dump+0x88>)
    2666:	1aed      	subs	r5, r5, r3
    2668:	08ed      	lsrs	r5, r5, #3
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    266a:	2601      	movs	r6, #1
    266c:	f04f 0300 	mov.w	r3, #0
    2670:	f366 0302 	bfi	r3, r6, #0, #3
    2674:	f36f 03c5 	bfc	r3, #3, #3
    2678:	f365 138f 	bfi	r3, r5, #6, #10
    267c:	f8ad 3000 	strh.w	r3, [sp]
    2680:	6883      	ldr	r3, [r0, #8]
    2682:	6842      	ldr	r2, [r0, #4]
    2684:	6801      	ldr	r1, [r0, #0]
    2686:	4818      	ldr	r0, [pc, #96]	; (26e8 <esf_dump+0x8c>)
    2688:	f7ff f9f6 	bl	1a78 <log_3>
		esf->basic.a1, esf->basic.a2, esf->basic.a3);
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    268c:	f04f 0300 	mov.w	r3, #0
    2690:	f366 0302 	bfi	r3, r6, #0, #3
    2694:	f36f 03c5 	bfc	r3, #3, #3
    2698:	f365 138f 	bfi	r3, r5, #6, #10
    269c:	f8ad 3000 	strh.w	r3, [sp]
    26a0:	6963      	ldr	r3, [r4, #20]
    26a2:	6922      	ldr	r2, [r4, #16]
    26a4:	68e1      	ldr	r1, [r4, #12]
    26a6:	4811      	ldr	r0, [pc, #68]	; (26ec <esf_dump+0x90>)
    26a8:	f7ff f9e6 	bl	1a78 <log_3>
		esf->basic.a4, esf->basic.ip, esf->basic.lr);
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    26ac:	f04f 0200 	mov.w	r2, #0
    26b0:	f366 0202 	bfi	r2, r6, #0, #3
    26b4:	f36f 02c5 	bfc	r2, #3, #3
    26b8:	f365 128f 	bfi	r2, r5, #6, #10
    26bc:	69e1      	ldr	r1, [r4, #28]
    26be:	480c      	ldr	r0, [pc, #48]	; (26f0 <esf_dump+0x94>)
    26c0:	f7ff fa18 	bl	1af4 <log_1>
	}

	LOG_ERR("EXC_RETURN: 0x%0x", esf->extra_info.exc_return);

#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    26c4:	f04f 0200 	mov.w	r2, #0
    26c8:	f366 0202 	bfi	r2, r6, #0, #3
    26cc:	f36f 02c5 	bfc	r2, #3, #3
    26d0:	f365 128f 	bfi	r2, r5, #6, #10
    26d4:	69a1      	ldr	r1, [r4, #24]
    26d6:	4807      	ldr	r0, [pc, #28]	; (26f4 <esf_dump+0x98>)
    26d8:	f7ff fa0c 	bl	1af4 <log_1>
		esf->basic.pc);
}
    26dc:	b002      	add	sp, #8
    26de:	bd70      	pop	{r4, r5, r6, pc}
    26e0:	00008e70 	.word	0x00008e70
    26e4:	00008e48 	.word	0x00008e48
    26e8:	00009168 	.word	0x00009168
    26ec:	00009198 	.word	0x00009198
    26f0:	000091c8 	.word	0x000091c8
    26f4:	000091d8 	.word	0x000091d8

000026f8 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    26f8:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    26fa:	2b00      	cmp	r3, #0
    26fc:	db08      	blt.n	2710 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    26fe:	f000 001f 	and.w	r0, r0, #31
    2702:	095b      	lsrs	r3, r3, #5
    2704:	2201      	movs	r2, #1
    2706:	fa02 f000 	lsl.w	r0, r2, r0
    270a:	4a02      	ldr	r2, [pc, #8]	; (2714 <arch_irq_enable+0x1c>)
    270c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    2710:	4770      	bx	lr
    2712:	bf00      	nop
    2714:	e000e100 	.word	0xe000e100

00002718 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
    2718:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
    271a:	2b00      	cmp	r3, #0
    271c:	db0d      	blt.n	273a <arch_irq_disable+0x22>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    271e:	f000 001f 	and.w	r0, r0, #31
    2722:	095b      	lsrs	r3, r3, #5
    2724:	2201      	movs	r2, #1
    2726:	fa02 f000 	lsl.w	r0, r2, r0
    272a:	3320      	adds	r3, #32
    272c:	4a03      	ldr	r2, [pc, #12]	; (273c <arch_irq_disable+0x24>)
    272e:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    2732:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2736:	f3bf 8f6f 	isb	sy
}
    273a:	4770      	bx	lr
    273c:	e000e100 	.word	0xe000e100

00002740 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    2740:	0942      	lsrs	r2, r0, #5
    2742:	4b05      	ldr	r3, [pc, #20]	; (2758 <arch_irq_is_enabled+0x18>)
    2744:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    2748:	f000 001f 	and.w	r0, r0, #31
    274c:	2301      	movs	r3, #1
    274e:	fa03 f000 	lsl.w	r0, r3, r0
}
    2752:	4010      	ands	r0, r2
    2754:	4770      	bx	lr
    2756:	bf00      	nop
    2758:	e000e100 	.word	0xe000e100

0000275c <z_arm_irq_priority_set>:
	 * via flags
	 */
	if (IS_ENABLED(CONFIG_ZERO_LATENCY_IRQS) && (flags & IRQ_ZERO_LATENCY)) {
		prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
	} else {
		prio += _IRQ_PRIO_OFFSET;
    275c:	3101      	adds	r1, #1
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    275e:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    2760:	2b00      	cmp	r3, #0
    2762:	db08      	blt.n	2776 <z_arm_irq_priority_set+0x1a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2764:	0149      	lsls	r1, r1, #5
    2766:	b2c9      	uxtb	r1, r1
    2768:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    276c:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    2770:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    2774:	4770      	bx	lr
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2776:	f000 000f 	and.w	r0, r0, #15
    277a:	0149      	lsls	r1, r1, #5
    277c:	b2c9      	uxtb	r1, r1
    277e:	4b01      	ldr	r3, [pc, #4]	; (2784 <z_arm_irq_priority_set+0x28>)
    2780:	5419      	strb	r1, [r3, r0]
}
    2782:	4770      	bx	lr
    2784:	e000ed14 	.word	0xe000ed14

00002788 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    2788:	bf30      	wfi
    b z_SysNmiOnReset
    278a:	f7ff bffd 	b.w	2788 <z_SysNmiOnReset>
    278e:	bf00      	nop

00002790 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    2790:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    2792:	4b0b      	ldr	r3, [pc, #44]	; (27c0 <z_arm_prep_c+0x30>)
    2794:	4a0b      	ldr	r2, [pc, #44]	; (27c4 <z_arm_prep_c+0x34>)
    2796:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    279a:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    279c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    27a0:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    27a4:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    27a8:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    27ac:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    27b0:	f003 faa0 	bl	5cf4 <z_bss_zero>
	z_data_copy();
    27b4:	f004 f94a 	bl	6a4c <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    27b8:	f000 fcb6 	bl	3128 <z_arm_interrupt_init>
	z_cstart();
    27bc:	f003 faa6 	bl	5d0c <z_cstart>
    27c0:	e000ed00 	.word	0xe000ed00
    27c4:	00000000 	.word	0x00000000

000027c8 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    27c8:	4a0a      	ldr	r2, [pc, #40]	; (27f4 <arch_swap+0x2c>)
    27ca:	6893      	ldr	r3, [r2, #8]
    27cc:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
	_current->arch.swap_return_value = _k_neg_eagain;
    27d0:	4909      	ldr	r1, [pc, #36]	; (27f8 <arch_swap+0x30>)
    27d2:	6809      	ldr	r1, [r1, #0]
    27d4:	f8c3 10ac 	str.w	r1, [r3, #172]	; 0xac

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    27d8:	4908      	ldr	r1, [pc, #32]	; (27fc <arch_swap+0x34>)
    27da:	684b      	ldr	r3, [r1, #4]
    27dc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    27e0:	604b      	str	r3, [r1, #4]
    27e2:	2300      	movs	r3, #0
    27e4:	f383 8811 	msr	BASEPRI, r3
    27e8:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    27ec:	6893      	ldr	r3, [r2, #8]
}
    27ee:	f8d3 00ac 	ldr.w	r0, [r3, #172]	; 0xac
    27f2:	4770      	bx	lr
    27f4:	200009bc 	.word	0x200009bc
    27f8:	0000987c 	.word	0x0000987c
    27fc:	e000ed00 	.word	0xe000ed00

00002800 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    2800:	4913      	ldr	r1, [pc, #76]	; (2850 <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
    2802:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    2804:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    2808:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    280a:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    280e:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    2812:	2020      	movs	r0, #32
    msr BASEPRI_MAX, r0
    2814:	f380 8812 	msr	BASEPRI_MAX, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    2818:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    281c:	4f0d      	ldr	r7, [pc, #52]	; (2854 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    281e:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    2822:	69ca      	ldr	r2, [r1, #28]

    str r2, [r1, #_kernel_offset_to_current]
    2824:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    2826:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    2828:	f8d2 00a8 	ldr.w	r0, [r2, #168]	; 0xa8
    movs r3, #0
    282c:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    282e:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    2832:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
    2836:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    2838:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    283a:	f000 fd17 	bl	326c <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    283e:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    2842:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    2846:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    284a:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    284e:	4770      	bx	lr
    ldr r1, =_kernel
    2850:	200009bc 	.word	0x200009bc
    ldr v4, =_SCS_ICSR
    2854:	e000ed04 	.word	0xe000ed04

00002858 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    2858:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    285c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    285e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    2862:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    2866:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    2868:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    286c:	2902      	cmp	r1, #2
    beq _oops
    286e:	d0ff      	beq.n	2870 <_oops>

00002870 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    2870:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    2872:	f005 f9d9 	bl	7c28 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    2876:	bd01      	pop	{r0, pc}

00002878 <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    2878:	b410      	push	{r4}
		thread->stack_info.size -= FP_GUARD_EXTRA_SIZE;
	}
#endif /* FP_GUARD_EXTRA_SIZE */
#endif /* CONFIG_MPU_STACK_GUARD */

	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    287a:	f1a2 0420 	sub.w	r4, r2, #32
		iframe->pc = (uint32_t)arch_user_mode_enter;
	} else {
		iframe->pc = (uint32_t)z_thread_entry;
	}
#else
	iframe->pc = (uint32_t)z_thread_entry;
    287e:	490d      	ldr	r1, [pc, #52]	; (28b4 <arch_new_thread+0x3c>)
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
    2880:	f021 0101 	bic.w	r1, r1, #1
    2884:	f842 1c08 	str.w	r1, [r2, #-8]
#endif
	iframe->a1 = (uint32_t)entry;
    2888:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    288c:	9b01      	ldr	r3, [sp, #4]
    288e:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
    2892:	9b02      	ldr	r3, [sp, #8]
    2894:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    2898:	9b03      	ldr	r3, [sp, #12]
    289a:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    289e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    28a2:	f842 3c04 	str.w	r3, [r2, #-4]
#if defined(CONFIG_COMPILER_ISA_THUMB2)
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
    28a6:	6504      	str	r4, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    28a8:	2300      	movs	r3, #0
    28aa:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    28ae:	bc10      	pop	{r4}
    28b0:	4770      	bx	lr
    28b2:	bf00      	nop
    28b4:	0000745d 	.word	0x0000745d

000028b8 <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
    28b8:	4b16      	ldr	r3, [pc, #88]	; (2914 <z_check_thread_stack_fail+0x5c>)
    28ba:	689a      	ldr	r2, [r3, #8]

	if (thread == NULL) {
    28bc:	b1da      	cbz	r2, 28f6 <z_check_thread_stack_fail+0x3e>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    28be:	f110 0f16 	cmn.w	r0, #22
    28c2:	d01a      	beq.n	28fa <z_check_thread_stack_fail+0x42>
{
    28c4:	b410      	push	{r4}
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    28c6:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
    28ca:	f1a3 0420 	sub.w	r4, r3, #32
    28ce:	4284      	cmp	r4, r0
    28d0:	d805      	bhi.n	28de <z_check_thread_stack_fail+0x26>
    28d2:	4283      	cmp	r3, r0
    28d4:	d908      	bls.n	28e8 <z_check_thread_stack_fail+0x30>
    28d6:	428b      	cmp	r3, r1
    28d8:	d808      	bhi.n	28ec <z_check_thread_stack_fail+0x34>
    28da:	2100      	movs	r1, #0
    28dc:	e000      	b.n	28e0 <z_check_thread_stack_fail+0x28>
    28de:	2100      	movs	r1, #0
    28e0:	b931      	cbnz	r1, 28f0 <z_check_thread_stack_fail+0x38>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
    28e2:	2000      	movs	r0, #0
}
    28e4:	bc10      	pop	{r4}
    28e6:	4770      	bx	lr
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    28e8:	2100      	movs	r1, #0
    28ea:	e7f9      	b.n	28e0 <z_check_thread_stack_fail+0x28>
    28ec:	2101      	movs	r1, #1
    28ee:	e7f7      	b.n	28e0 <z_check_thread_stack_fail+0x28>
		return thread->stack_info.start;
    28f0:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
    28f4:	e7f6      	b.n	28e4 <z_check_thread_stack_fail+0x2c>
		return 0;
    28f6:	2000      	movs	r0, #0
    28f8:	4770      	bx	lr
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    28fa:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
    28fe:	428b      	cmp	r3, r1
    2900:	bf94      	ite	ls
    2902:	2100      	movls	r1, #0
    2904:	2101      	movhi	r1, #1
    2906:	b909      	cbnz	r1, 290c <z_check_thread_stack_fail+0x54>
	return 0;
    2908:	2000      	movs	r0, #0
}
    290a:	4770      	bx	lr
		return thread->stack_info.start;
    290c:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
    2910:	4770      	bx	lr
    2912:	bf00      	nop
    2914:	200009bc 	.word	0x200009bc

00002918 <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    2918:	b508      	push	{r3, lr}
    291a:	460d      	mov	r5, r1
    291c:	4614      	mov	r4, r2
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    291e:	4b08      	ldr	r3, [pc, #32]	; (2940 <arch_switch_to_main_thread+0x28>)
    2920:	6098      	str	r0, [r3, #8]
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    2922:	f000 fca3 	bl	326c <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    2926:	4620      	mov	r0, r4
    2928:	f385 8809 	msr	PSP, r5
    292c:	2100      	movs	r1, #0
    292e:	b663      	cpsie	if
    2930:	f381 8811 	msr	BASEPRI, r1
    2934:	f3bf 8f6f 	isb	sy
    2938:	2200      	movs	r2, #0
    293a:	2300      	movs	r3, #0
    293c:	f004 fd8e 	bl	745c <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    2940:	200009bc 	.word	0x200009bc

00002944 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    2944:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    2946:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    2948:	4a0b      	ldr	r2, [pc, #44]	; (2978 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    294a:	6990      	ldr	r0, [r2, #24]
	cmp r0, #0
    294c:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    294e:	bf1e      	ittt	ne
	movne	r1, #0
    2950:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    2952:	6191      	strne	r1, [r2, #24]
		blne	z_pm_save_idle_exit
    2954:	f005 ff88 	blne	8868 <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    2958:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    295a:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    295e:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    2962:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    2966:	4905      	ldr	r1, [pc, #20]	; (297c <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    2968:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    296a:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    296c:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    296e:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    2972:	4903      	ldr	r1, [pc, #12]	; (2980 <_isr_wrapper+0x3c>)
	bx r1
    2974:	4708      	bx	r1
    2976:	0000      	.short	0x0000
	ldr r2, =_kernel
    2978:	200009bc 	.word	0x200009bc
	ldr r1, =_sw_isr_table
    297c:	00008d10 	.word	0x00008d10
	ldr r1, =z_arm_int_exit
    2980:	00002985 	.word	0x00002985

00002984 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    2984:	4b04      	ldr	r3, [pc, #16]	; (2998 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    2986:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    2988:	69d8      	ldr	r0, [r3, #28]
	cmp r0, r1
    298a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    298c:	d003      	beq.n	2996 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    298e:	4903      	ldr	r1, [pc, #12]	; (299c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    2990:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    2994:	600a      	str	r2, [r1, #0]

00002996 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    2996:	4770      	bx	lr
	ldr r3, =_kernel
    2998:	200009bc 	.word	0x200009bc
	ldr r1, =_SCS_ICSR
    299c:	e000ed04 	.word	0xe000ed04

000029a0 <usage_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
{
    29a0:	b508      	push	{r3, lr}
    29a2:	4b4e      	ldr	r3, [pc, #312]	; (2adc <usage_fault+0x13c>)
    29a4:	4a4e      	ldr	r2, [pc, #312]	; (2ae0 <usage_fault+0x140>)
    29a6:	1a9b      	subs	r3, r3, r2
    29a8:	08db      	lsrs	r3, r3, #3
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    29aa:	f04f 0100 	mov.w	r1, #0
    29ae:	2201      	movs	r2, #1
    29b0:	f362 0102 	bfi	r1, r2, #0, #3
    29b4:	f36f 01c5 	bfc	r1, #3, #3
    29b8:	f363 118f 	bfi	r1, r3, #6, #10
    29bc:	4849      	ldr	r0, [pc, #292]	; (2ae4 <usage_fault+0x144>)
    29be:	f7ff f90b 	bl	1bd8 <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    29c2:	4b49      	ldr	r3, [pc, #292]	; (2ae8 <usage_fault+0x148>)
    29c4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29c6:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    29ca:	d121      	bne.n	2a10 <usage_fault+0x70>
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    29cc:	4b46      	ldr	r3, [pc, #280]	; (2ae8 <usage_fault+0x148>)
    29ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29d0:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
    29d4:	d12d      	bne.n	2a32 <usage_fault+0x92>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    29d6:	4b44      	ldr	r3, [pc, #272]	; (2ae8 <usage_fault+0x148>)
    29d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29da:	f413 2f00 	tst.w	r3, #524288	; 0x80000
    29de:	d139      	bne.n	2a54 <usage_fault+0xb4>
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    29e0:	4b41      	ldr	r3, [pc, #260]	; (2ae8 <usage_fault+0x148>)
    29e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29e4:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    29e8:	d145      	bne.n	2a76 <usage_fault+0xd6>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    29ea:	4b3f      	ldr	r3, [pc, #252]	; (2ae8 <usage_fault+0x148>)
    29ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29ee:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    29f2:	d151      	bne.n	2a98 <usage_fault+0xf8>
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    29f4:	4b3c      	ldr	r3, [pc, #240]	; (2ae8 <usage_fault+0x148>)
    29f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29f8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    29fc:	d15d      	bne.n	2aba <usage_fault+0x11a>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    29fe:	4a3a      	ldr	r2, [pc, #232]	; (2ae8 <usage_fault+0x148>)
    2a00:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2a02:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    2a06:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    2a0a:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    2a0c:	2000      	movs	r0, #0
    2a0e:	bd08      	pop	{r3, pc}
    2a10:	4b32      	ldr	r3, [pc, #200]	; (2adc <usage_fault+0x13c>)
    2a12:	4a33      	ldr	r2, [pc, #204]	; (2ae0 <usage_fault+0x140>)
    2a14:	1a9b      	subs	r3, r3, r2
    2a16:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Division by zero");
    2a18:	f04f 0100 	mov.w	r1, #0
    2a1c:	2201      	movs	r2, #1
    2a1e:	f362 0102 	bfi	r1, r2, #0, #3
    2a22:	f36f 01c5 	bfc	r1, #3, #3
    2a26:	f363 118f 	bfi	r1, r3, #6, #10
    2a2a:	4830      	ldr	r0, [pc, #192]	; (2aec <usage_fault+0x14c>)
    2a2c:	f7ff f8d4 	bl	1bd8 <log_0>
    2a30:	e7cc      	b.n	29cc <usage_fault+0x2c>
    2a32:	4b2a      	ldr	r3, [pc, #168]	; (2adc <usage_fault+0x13c>)
    2a34:	4a2a      	ldr	r2, [pc, #168]	; (2ae0 <usage_fault+0x140>)
    2a36:	1a9b      	subs	r3, r3, r2
    2a38:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Unaligned memory access");
    2a3a:	f04f 0100 	mov.w	r1, #0
    2a3e:	2201      	movs	r2, #1
    2a40:	f362 0102 	bfi	r1, r2, #0, #3
    2a44:	f36f 01c5 	bfc	r1, #3, #3
    2a48:	f363 118f 	bfi	r1, r3, #6, #10
    2a4c:	4828      	ldr	r0, [pc, #160]	; (2af0 <usage_fault+0x150>)
    2a4e:	f7ff f8c3 	bl	1bd8 <log_0>
    2a52:	e7c0      	b.n	29d6 <usage_fault+0x36>
    2a54:	4b21      	ldr	r3, [pc, #132]	; (2adc <usage_fault+0x13c>)
    2a56:	4a22      	ldr	r2, [pc, #136]	; (2ae0 <usage_fault+0x140>)
    2a58:	1a9b      	subs	r3, r3, r2
    2a5a:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  No coprocessor instructions");
    2a5c:	f04f 0100 	mov.w	r1, #0
    2a60:	2201      	movs	r2, #1
    2a62:	f362 0102 	bfi	r1, r2, #0, #3
    2a66:	f36f 01c5 	bfc	r1, #3, #3
    2a6a:	f363 118f 	bfi	r1, r3, #6, #10
    2a6e:	4821      	ldr	r0, [pc, #132]	; (2af4 <usage_fault+0x154>)
    2a70:	f7ff f8b2 	bl	1bd8 <log_0>
    2a74:	e7b4      	b.n	29e0 <usage_fault+0x40>
    2a76:	4b19      	ldr	r3, [pc, #100]	; (2adc <usage_fault+0x13c>)
    2a78:	4a19      	ldr	r2, [pc, #100]	; (2ae0 <usage_fault+0x140>)
    2a7a:	1a9b      	subs	r3, r3, r2
    2a7c:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    2a7e:	f04f 0100 	mov.w	r1, #0
    2a82:	2201      	movs	r2, #1
    2a84:	f362 0102 	bfi	r1, r2, #0, #3
    2a88:	f36f 01c5 	bfc	r1, #3, #3
    2a8c:	f363 118f 	bfi	r1, r3, #6, #10
    2a90:	4819      	ldr	r0, [pc, #100]	; (2af8 <usage_fault+0x158>)
    2a92:	f7ff f8a1 	bl	1bd8 <log_0>
    2a96:	e7a8      	b.n	29ea <usage_fault+0x4a>
    2a98:	4b10      	ldr	r3, [pc, #64]	; (2adc <usage_fault+0x13c>)
    2a9a:	4a11      	ldr	r2, [pc, #68]	; (2ae0 <usage_fault+0x140>)
    2a9c:	1a9b      	subs	r3, r3, r2
    2a9e:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Illegal use of the EPSR");
    2aa0:	f04f 0100 	mov.w	r1, #0
    2aa4:	2201      	movs	r2, #1
    2aa6:	f362 0102 	bfi	r1, r2, #0, #3
    2aaa:	f36f 01c5 	bfc	r1, #3, #3
    2aae:	f363 118f 	bfi	r1, r3, #6, #10
    2ab2:	4812      	ldr	r0, [pc, #72]	; (2afc <usage_fault+0x15c>)
    2ab4:	f7ff f890 	bl	1bd8 <log_0>
    2ab8:	e79c      	b.n	29f4 <usage_fault+0x54>
    2aba:	4b08      	ldr	r3, [pc, #32]	; (2adc <usage_fault+0x13c>)
    2abc:	4a08      	ldr	r2, [pc, #32]	; (2ae0 <usage_fault+0x140>)
    2abe:	1a9b      	subs	r3, r3, r2
    2ac0:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    2ac2:	f04f 0100 	mov.w	r1, #0
    2ac6:	2201      	movs	r2, #1
    2ac8:	f362 0102 	bfi	r1, r2, #0, #3
    2acc:	f36f 01c5 	bfc	r1, #3, #3
    2ad0:	f363 118f 	bfi	r1, r3, #6, #10
    2ad4:	480a      	ldr	r0, [pc, #40]	; (2b00 <usage_fault+0x160>)
    2ad6:	f7ff f87f 	bl	1bd8 <log_0>
    2ada:	e790      	b.n	29fe <usage_fault+0x5e>
    2adc:	00008e70 	.word	0x00008e70
    2ae0:	00008e48 	.word	0x00008e48
    2ae4:	00009208 	.word	0x00009208
    2ae8:	e000ed00 	.word	0xe000ed00
    2aec:	00009220 	.word	0x00009220
    2af0:	00009234 	.word	0x00009234
    2af4:	00009250 	.word	0x00009250
    2af8:	00009270 	.word	0x00009270
    2afc:	00009298 	.word	0x00009298
    2b00:	000092b4 	.word	0x000092b4

00002b04 <debug_monitor>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void debug_monitor(z_arch_esf_t *esf, bool *recoverable)
{
    2b04:	b508      	push	{r3, lr}
	*recoverable = false;
    2b06:	2200      	movs	r2, #0
    2b08:	700a      	strb	r2, [r1, #0]
    2b0a:	4b08      	ldr	r3, [pc, #32]	; (2b2c <debug_monitor+0x28>)
    2b0c:	4908      	ldr	r1, [pc, #32]	; (2b30 <debug_monitor+0x2c>)
    2b0e:	1a5b      	subs	r3, r3, r1
    2b10:	08db      	lsrs	r3, r3, #3

	PR_FAULT_INFO(
    2b12:	f04f 0100 	mov.w	r1, #0
    2b16:	2001      	movs	r0, #1
    2b18:	f360 0102 	bfi	r1, r0, #0, #3
    2b1c:	f362 01c5 	bfi	r1, r2, #3, #3
    2b20:	f363 118f 	bfi	r1, r3, #6, #10
    2b24:	4803      	ldr	r0, [pc, #12]	; (2b34 <debug_monitor+0x30>)
    2b26:	f7ff f857 	bl	1bd8 <log_0>

		*recoverable = memory_fault_recoverable(esf, false);
	}

#endif
}
    2b2a:	bd08      	pop	{r3, pc}
    2b2c:	00008e70 	.word	0x00008e70
    2b30:	00008e48 	.word	0x00008e48
    2b34:	000092e0 	.word	0x000092e0

00002b38 <bus_fault>:
{
    2b38:	b570      	push	{r4, r5, r6, lr}
    2b3a:	4605      	mov	r5, r0
    2b3c:	460e      	mov	r6, r1
    2b3e:	4614      	mov	r4, r2
    2b40:	4b5e      	ldr	r3, [pc, #376]	; (2cbc <bus_fault+0x184>)
    2b42:	4a5f      	ldr	r2, [pc, #380]	; (2cc0 <bus_fault+0x188>)
    2b44:	1a9b      	subs	r3, r3, r2
    2b46:	08db      	lsrs	r3, r3, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
    2b48:	f04f 0100 	mov.w	r1, #0
    2b4c:	2201      	movs	r2, #1
    2b4e:	f362 0102 	bfi	r1, r2, #0, #3
    2b52:	f36f 01c5 	bfc	r1, #3, #3
    2b56:	f363 118f 	bfi	r1, r3, #6, #10
    2b5a:	485a      	ldr	r0, [pc, #360]	; (2cc4 <bus_fault+0x18c>)
    2b5c:	f7ff f83c 	bl	1bd8 <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    2b60:	4b59      	ldr	r3, [pc, #356]	; (2cc8 <bus_fault+0x190>)
    2b62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b64:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    2b68:	d124      	bne.n	2bb4 <bus_fault+0x7c>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    2b6a:	4b57      	ldr	r3, [pc, #348]	; (2cc8 <bus_fault+0x190>)
    2b6c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b6e:	f413 6f00 	tst.w	r3, #2048	; 0x800
    2b72:	d130      	bne.n	2bd6 <bus_fault+0x9e>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    2b74:	4b54      	ldr	r3, [pc, #336]	; (2cc8 <bus_fault+0x190>)
    2b76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b78:	f413 7f00 	tst.w	r3, #512	; 0x200
    2b7c:	d13c      	bne.n	2bf8 <bus_fault+0xc0>
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    2b7e:	4b52      	ldr	r3, [pc, #328]	; (2cc8 <bus_fault+0x190>)
    2b80:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b82:	f413 6f80 	tst.w	r3, #1024	; 0x400
    2b86:	d165      	bne.n	2c54 <bus_fault+0x11c>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    2b88:	4b4f      	ldr	r3, [pc, #316]	; (2cc8 <bus_fault+0x190>)
    2b8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b8c:	f413 7f80 	tst.w	r3, #256	; 0x100
    2b90:	d171      	bne.n	2c76 <bus_fault+0x13e>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    2b92:	4b4d      	ldr	r3, [pc, #308]	; (2cc8 <bus_fault+0x190>)
    2b94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b96:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    2b9a:	d17d      	bne.n	2c98 <bus_fault+0x160>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    2b9c:	4a4a      	ldr	r2, [pc, #296]	; (2cc8 <bus_fault+0x190>)
    2b9e:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2ba0:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    2ba4:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    2ba6:	2101      	movs	r1, #1
    2ba8:	4628      	mov	r0, r5
    2baa:	f005 f84f 	bl	7c4c <memory_fault_recoverable>
    2bae:	7020      	strb	r0, [r4, #0]
}
    2bb0:	2000      	movs	r0, #0
    2bb2:	bd70      	pop	{r4, r5, r6, pc}
    2bb4:	4b41      	ldr	r3, [pc, #260]	; (2cbc <bus_fault+0x184>)
    2bb6:	4a42      	ldr	r2, [pc, #264]	; (2cc0 <bus_fault+0x188>)
    2bb8:	1a9b      	subs	r3, r3, r2
    2bba:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Stacking error");
    2bbc:	f04f 0100 	mov.w	r1, #0
    2bc0:	2201      	movs	r2, #1
    2bc2:	f362 0102 	bfi	r1, r2, #0, #3
    2bc6:	f36f 01c5 	bfc	r1, #3, #3
    2bca:	f363 118f 	bfi	r1, r3, #6, #10
    2bce:	483f      	ldr	r0, [pc, #252]	; (2ccc <bus_fault+0x194>)
    2bd0:	f7ff f802 	bl	1bd8 <log_0>
    2bd4:	e7c9      	b.n	2b6a <bus_fault+0x32>
    2bd6:	4b39      	ldr	r3, [pc, #228]	; (2cbc <bus_fault+0x184>)
    2bd8:	4a39      	ldr	r2, [pc, #228]	; (2cc0 <bus_fault+0x188>)
    2bda:	1a9b      	subs	r3, r3, r2
    2bdc:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Unstacking error");
    2bde:	f04f 0100 	mov.w	r1, #0
    2be2:	2201      	movs	r2, #1
    2be4:	f362 0102 	bfi	r1, r2, #0, #3
    2be8:	f36f 01c5 	bfc	r1, #3, #3
    2bec:	f363 118f 	bfi	r1, r3, #6, #10
    2bf0:	4837      	ldr	r0, [pc, #220]	; (2cd0 <bus_fault+0x198>)
    2bf2:	f7fe fff1 	bl	1bd8 <log_0>
    2bf6:	e7bd      	b.n	2b74 <bus_fault+0x3c>
    2bf8:	4b30      	ldr	r3, [pc, #192]	; (2cbc <bus_fault+0x184>)
    2bfa:	4a31      	ldr	r2, [pc, #196]	; (2cc0 <bus_fault+0x188>)
    2bfc:	1a9b      	subs	r3, r3, r2
    2bfe:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Precise data bus error");
    2c00:	f04f 0100 	mov.w	r1, #0
    2c04:	2201      	movs	r2, #1
    2c06:	f362 0102 	bfi	r1, r2, #0, #3
    2c0a:	f36f 01c5 	bfc	r1, #3, #3
    2c0e:	f363 118f 	bfi	r1, r3, #6, #10
    2c12:	4830      	ldr	r0, [pc, #192]	; (2cd4 <bus_fault+0x19c>)
    2c14:	f7fe ffe0 	bl	1bd8 <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    2c18:	4b2b      	ldr	r3, [pc, #172]	; (2cc8 <bus_fault+0x190>)
    2c1a:	6b99      	ldr	r1, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    2c1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2c1e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2c22:	d0ac      	beq.n	2b7e <bus_fault+0x46>
    2c24:	4b25      	ldr	r3, [pc, #148]	; (2cbc <bus_fault+0x184>)
    2c26:	4a26      	ldr	r2, [pc, #152]	; (2cc0 <bus_fault+0x188>)
    2c28:	1a9b      	subs	r3, r3, r2
    2c2a:	08db      	lsrs	r3, r3, #3
			PR_EXC("  BFAR Address: 0x%x", bfar);
    2c2c:	f04f 0200 	mov.w	r2, #0
    2c30:	2001      	movs	r0, #1
    2c32:	f360 0202 	bfi	r2, r0, #0, #3
    2c36:	f36f 02c5 	bfc	r2, #3, #3
    2c3a:	f363 128f 	bfi	r2, r3, #6, #10
    2c3e:	4826      	ldr	r0, [pc, #152]	; (2cd8 <bus_fault+0x1a0>)
    2c40:	f7fe ff58 	bl	1af4 <log_1>
			if (from_hard_fault != 0) {
    2c44:	2e00      	cmp	r6, #0
    2c46:	d09a      	beq.n	2b7e <bus_fault+0x46>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    2c48:	4a1f      	ldr	r2, [pc, #124]	; (2cc8 <bus_fault+0x190>)
    2c4a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2c4c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    2c50:	6293      	str	r3, [r2, #40]	; 0x28
    2c52:	e794      	b.n	2b7e <bus_fault+0x46>
    2c54:	4b19      	ldr	r3, [pc, #100]	; (2cbc <bus_fault+0x184>)
    2c56:	4a1a      	ldr	r2, [pc, #104]	; (2cc0 <bus_fault+0x188>)
    2c58:	1a9b      	subs	r3, r3, r2
    2c5a:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Imprecise data bus error");
    2c5c:	f04f 0100 	mov.w	r1, #0
    2c60:	2201      	movs	r2, #1
    2c62:	f362 0102 	bfi	r1, r2, #0, #3
    2c66:	f36f 01c5 	bfc	r1, #3, #3
    2c6a:	f363 118f 	bfi	r1, r3, #6, #10
    2c6e:	481b      	ldr	r0, [pc, #108]	; (2cdc <bus_fault+0x1a4>)
    2c70:	f7fe ffb2 	bl	1bd8 <log_0>
    2c74:	e788      	b.n	2b88 <bus_fault+0x50>
    2c76:	4b11      	ldr	r3, [pc, #68]	; (2cbc <bus_fault+0x184>)
    2c78:	4a11      	ldr	r2, [pc, #68]	; (2cc0 <bus_fault+0x188>)
    2c7a:	1a9b      	subs	r3, r3, r2
    2c7c:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Instruction bus error");
    2c7e:	f04f 0100 	mov.w	r1, #0
    2c82:	2201      	movs	r2, #1
    2c84:	f362 0102 	bfi	r1, r2, #0, #3
    2c88:	f36f 01c5 	bfc	r1, #3, #3
    2c8c:	f363 118f 	bfi	r1, r3, #6, #10
    2c90:	4813      	ldr	r0, [pc, #76]	; (2ce0 <bus_fault+0x1a8>)
    2c92:	f7fe ffa1 	bl	1bd8 <log_0>
    2c96:	e781      	b.n	2b9c <bus_fault+0x64>
    2c98:	4b08      	ldr	r3, [pc, #32]	; (2cbc <bus_fault+0x184>)
    2c9a:	4a09      	ldr	r2, [pc, #36]	; (2cc0 <bus_fault+0x188>)
    2c9c:	1a9b      	subs	r3, r3, r2
    2c9e:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    2ca0:	f04f 0100 	mov.w	r1, #0
    2ca4:	2201      	movs	r2, #1
    2ca6:	f362 0102 	bfi	r1, r2, #0, #3
    2caa:	f36f 01c5 	bfc	r1, #3, #3
    2cae:	f363 118f 	bfi	r1, r3, #6, #10
    2cb2:	480c      	ldr	r0, [pc, #48]	; (2ce4 <bus_fault+0x1ac>)
    2cb4:	f7fe ff90 	bl	1bd8 <log_0>
    2cb8:	e770      	b.n	2b9c <bus_fault+0x64>
    2cba:	bf00      	nop
    2cbc:	00008e70 	.word	0x00008e70
    2cc0:	00008e48 	.word	0x00008e48
    2cc4:	00009304 	.word	0x00009304
    2cc8:	e000ed00 	.word	0xe000ed00
    2ccc:	0000931c 	.word	0x0000931c
    2cd0:	00009330 	.word	0x00009330
    2cd4:	00009344 	.word	0x00009344
    2cd8:	00009360 	.word	0x00009360
    2cdc:	00009378 	.word	0x00009378
    2ce0:	00009394 	.word	0x00009394
    2ce4:	000093ac 	.word	0x000093ac

00002ce8 <mem_manage_fault>:
{
    2ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2cea:	4605      	mov	r5, r0
    2cec:	460c      	mov	r4, r1
    2cee:	4616      	mov	r6, r2
    2cf0:	4b64      	ldr	r3, [pc, #400]	; (2e84 <mem_manage_fault+0x19c>)
    2cf2:	4a65      	ldr	r2, [pc, #404]	; (2e88 <mem_manage_fault+0x1a0>)
    2cf4:	1a9b      	subs	r3, r3, r2
    2cf6:	08db      	lsrs	r3, r3, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
    2cf8:	f04f 0100 	mov.w	r1, #0
    2cfc:	2201      	movs	r2, #1
    2cfe:	f362 0102 	bfi	r1, r2, #0, #3
    2d02:	f36f 01c5 	bfc	r1, #3, #3
    2d06:	f363 118f 	bfi	r1, r3, #6, #10
    2d0a:	4860      	ldr	r0, [pc, #384]	; (2e8c <mem_manage_fault+0x1a4>)
    2d0c:	f7fe ff64 	bl	1bd8 <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    2d10:	4b5f      	ldr	r3, [pc, #380]	; (2e90 <mem_manage_fault+0x1a8>)
    2d12:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d14:	f013 0f10 	tst.w	r3, #16
    2d18:	d132      	bne.n	2d80 <mem_manage_fault+0x98>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    2d1a:	4b5d      	ldr	r3, [pc, #372]	; (2e90 <mem_manage_fault+0x1a8>)
    2d1c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d1e:	f013 0f08 	tst.w	r3, #8
    2d22:	d13e      	bne.n	2da2 <mem_manage_fault+0xba>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    2d24:	4b5a      	ldr	r3, [pc, #360]	; (2e90 <mem_manage_fault+0x1a8>)
    2d26:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d28:	f013 0f02 	tst.w	r3, #2
    2d2c:	d14a      	bne.n	2dc4 <mem_manage_fault+0xdc>
	uint32_t mmfar = -EINVAL;
    2d2e:	f06f 0715 	mvn.w	r7, #21
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    2d32:	4b57      	ldr	r3, [pc, #348]	; (2e90 <mem_manage_fault+0x1a8>)
    2d34:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d36:	f013 0f01 	tst.w	r3, #1
    2d3a:	d175      	bne.n	2e28 <mem_manage_fault+0x140>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    2d3c:	4b54      	ldr	r3, [pc, #336]	; (2e90 <mem_manage_fault+0x1a8>)
    2d3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d40:	f013 0f20 	tst.w	r3, #32
    2d44:	f040 8081 	bne.w	2e4a <mem_manage_fault+0x162>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    2d48:	4b51      	ldr	r3, [pc, #324]	; (2e90 <mem_manage_fault+0x1a8>)
    2d4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d4c:	f013 0f10 	tst.w	r3, #16
    2d50:	d104      	bne.n	2d5c <mem_manage_fault+0x74>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    2d52:	4b4f      	ldr	r3, [pc, #316]	; (2e90 <mem_manage_fault+0x1a8>)
    2d54:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    2d56:	f014 0402 	ands.w	r4, r4, #2
    2d5a:	d005      	beq.n	2d68 <mem_manage_fault+0x80>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    2d5c:	4b4c      	ldr	r3, [pc, #304]	; (2e90 <mem_manage_fault+0x1a8>)
    2d5e:	685c      	ldr	r4, [r3, #4]
    2d60:	f414 6400 	ands.w	r4, r4, #2048	; 0x800
    2d64:	f040 8082 	bne.w	2e6c <mem_manage_fault+0x184>
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    2d68:	4a49      	ldr	r2, [pc, #292]	; (2e90 <mem_manage_fault+0x1a8>)
    2d6a:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2d6c:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    2d70:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    2d72:	2101      	movs	r1, #1
    2d74:	4628      	mov	r0, r5
    2d76:	f004 ff69 	bl	7c4c <memory_fault_recoverable>
    2d7a:	7030      	strb	r0, [r6, #0]
}
    2d7c:	4620      	mov	r0, r4
    2d7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2d80:	4b40      	ldr	r3, [pc, #256]	; (2e84 <mem_manage_fault+0x19c>)
    2d82:	4a41      	ldr	r2, [pc, #260]	; (2e88 <mem_manage_fault+0x1a0>)
    2d84:	1a9b      	subs	r3, r3, r2
    2d86:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Stacking error (context area might be"
    2d88:	f04f 0100 	mov.w	r1, #0
    2d8c:	2201      	movs	r2, #1
    2d8e:	f362 0102 	bfi	r1, r2, #0, #3
    2d92:	f36f 01c5 	bfc	r1, #3, #3
    2d96:	f363 118f 	bfi	r1, r3, #6, #10
    2d9a:	483e      	ldr	r0, [pc, #248]	; (2e94 <mem_manage_fault+0x1ac>)
    2d9c:	f7fe ff1c 	bl	1bd8 <log_0>
    2da0:	e7bb      	b.n	2d1a <mem_manage_fault+0x32>
    2da2:	4b38      	ldr	r3, [pc, #224]	; (2e84 <mem_manage_fault+0x19c>)
    2da4:	4a38      	ldr	r2, [pc, #224]	; (2e88 <mem_manage_fault+0x1a0>)
    2da6:	1a9b      	subs	r3, r3, r2
    2da8:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Unstacking error");
    2daa:	f04f 0100 	mov.w	r1, #0
    2dae:	2201      	movs	r2, #1
    2db0:	f362 0102 	bfi	r1, r2, #0, #3
    2db4:	f36f 01c5 	bfc	r1, #3, #3
    2db8:	f363 118f 	bfi	r1, r3, #6, #10
    2dbc:	4836      	ldr	r0, [pc, #216]	; (2e98 <mem_manage_fault+0x1b0>)
    2dbe:	f7fe ff0b 	bl	1bd8 <log_0>
    2dc2:	e7af      	b.n	2d24 <mem_manage_fault+0x3c>
    2dc4:	4b2f      	ldr	r3, [pc, #188]	; (2e84 <mem_manage_fault+0x19c>)
    2dc6:	4a30      	ldr	r2, [pc, #192]	; (2e88 <mem_manage_fault+0x1a0>)
    2dc8:	1a9b      	subs	r3, r3, r2
    2dca:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Data Access Violation");
    2dcc:	f04f 0100 	mov.w	r1, #0
    2dd0:	2201      	movs	r2, #1
    2dd2:	f362 0102 	bfi	r1, r2, #0, #3
    2dd6:	f36f 01c5 	bfc	r1, #3, #3
    2dda:	f363 118f 	bfi	r1, r3, #6, #10
    2dde:	482f      	ldr	r0, [pc, #188]	; (2e9c <mem_manage_fault+0x1b4>)
    2de0:	f7fe fefa 	bl	1bd8 <log_0>
		uint32_t temp = SCB->MMFAR;
    2de4:	4b2a      	ldr	r3, [pc, #168]	; (2e90 <mem_manage_fault+0x1a8>)
    2de6:	6b5f      	ldr	r7, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    2de8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2dea:	f013 0f80 	tst.w	r3, #128	; 0x80
    2dee:	d102      	bne.n	2df6 <mem_manage_fault+0x10e>
	uint32_t mmfar = -EINVAL;
    2df0:	f06f 0715 	mvn.w	r7, #21
    2df4:	e79d      	b.n	2d32 <mem_manage_fault+0x4a>
    2df6:	4b23      	ldr	r3, [pc, #140]	; (2e84 <mem_manage_fault+0x19c>)
    2df8:	4a23      	ldr	r2, [pc, #140]	; (2e88 <mem_manage_fault+0x1a0>)
    2dfa:	1a9b      	subs	r3, r3, r2
    2dfc:	08db      	lsrs	r3, r3, #3
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    2dfe:	f04f 0200 	mov.w	r2, #0
    2e02:	2101      	movs	r1, #1
    2e04:	f361 0202 	bfi	r2, r1, #0, #3
    2e08:	f36f 02c5 	bfc	r2, #3, #3
    2e0c:	f363 128f 	bfi	r2, r3, #6, #10
    2e10:	4639      	mov	r1, r7
    2e12:	4823      	ldr	r0, [pc, #140]	; (2ea0 <mem_manage_fault+0x1b8>)
    2e14:	f7fe fe6e 	bl	1af4 <log_1>
			if (from_hard_fault != 0) {
    2e18:	2c00      	cmp	r4, #0
    2e1a:	d08a      	beq.n	2d32 <mem_manage_fault+0x4a>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    2e1c:	4a1c      	ldr	r2, [pc, #112]	; (2e90 <mem_manage_fault+0x1a8>)
    2e1e:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2e20:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    2e24:	6293      	str	r3, [r2, #40]	; 0x28
    2e26:	e784      	b.n	2d32 <mem_manage_fault+0x4a>
    2e28:	4b16      	ldr	r3, [pc, #88]	; (2e84 <mem_manage_fault+0x19c>)
    2e2a:	4a17      	ldr	r2, [pc, #92]	; (2e88 <mem_manage_fault+0x1a0>)
    2e2c:	1a9b      	subs	r3, r3, r2
    2e2e:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Instruction Access Violation");
    2e30:	f04f 0100 	mov.w	r1, #0
    2e34:	2201      	movs	r2, #1
    2e36:	f362 0102 	bfi	r1, r2, #0, #3
    2e3a:	f36f 01c5 	bfc	r1, #3, #3
    2e3e:	f363 118f 	bfi	r1, r3, #6, #10
    2e42:	4818      	ldr	r0, [pc, #96]	; (2ea4 <mem_manage_fault+0x1bc>)
    2e44:	f7fe fec8 	bl	1bd8 <log_0>
    2e48:	e778      	b.n	2d3c <mem_manage_fault+0x54>
    2e4a:	4b0e      	ldr	r3, [pc, #56]	; (2e84 <mem_manage_fault+0x19c>)
    2e4c:	4a0e      	ldr	r2, [pc, #56]	; (2e88 <mem_manage_fault+0x1a0>)
    2e4e:	1a9b      	subs	r3, r3, r2
    2e50:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO(
    2e52:	f04f 0100 	mov.w	r1, #0
    2e56:	2201      	movs	r2, #1
    2e58:	f362 0102 	bfi	r1, r2, #0, #3
    2e5c:	f36f 01c5 	bfc	r1, #3, #3
    2e60:	f363 118f 	bfi	r1, r3, #6, #10
    2e64:	4810      	ldr	r0, [pc, #64]	; (2ea8 <mem_manage_fault+0x1c0>)
    2e66:	f7fe feb7 	bl	1bd8 <log_0>
    2e6a:	e76d      	b.n	2d48 <mem_manage_fault+0x60>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    2e6c:	4629      	mov	r1, r5
    2e6e:	4638      	mov	r0, r7
    2e70:	f7ff fd22 	bl	28b8 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
    2e74:	4604      	mov	r4, r0
    2e76:	2800      	cmp	r0, #0
    2e78:	f43f af76 	beq.w	2d68 <mem_manage_fault+0x80>
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    2e7c:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
    2e80:	2402      	movs	r4, #2
    2e82:	e771      	b.n	2d68 <mem_manage_fault+0x80>
    2e84:	00008e70 	.word	0x00008e70
    2e88:	00008e48 	.word	0x00008e48
    2e8c:	000093dc 	.word	0x000093dc
    2e90:	e000ed00 	.word	0xe000ed00
    2e94:	000093f4 	.word	0x000093f4
    2e98:	00009330 	.word	0x00009330
    2e9c:	00009428 	.word	0x00009428
    2ea0:	00009440 	.word	0x00009440
    2ea4:	00009458 	.word	0x00009458
    2ea8:	000093ac 	.word	0x000093ac

00002eac <hard_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t hard_fault(z_arch_esf_t *esf, bool *recoverable)
{
    2eac:	b570      	push	{r4, r5, r6, lr}
    2eae:	4605      	mov	r5, r0
    2eb0:	460c      	mov	r4, r1
    2eb2:	4b47      	ldr	r3, [pc, #284]	; (2fd0 <hard_fault+0x124>)
    2eb4:	4a47      	ldr	r2, [pc, #284]	; (2fd4 <hard_fault+0x128>)
    2eb6:	1a9b      	subs	r3, r3, r2
    2eb8:	08db      	lsrs	r3, r3, #3
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** HARD FAULT *****");
    2eba:	f04f 0100 	mov.w	r1, #0
    2ebe:	2201      	movs	r2, #1
    2ec0:	f362 0102 	bfi	r1, r2, #0, #3
    2ec4:	f36f 01c5 	bfc	r1, #3, #3
    2ec8:	f363 118f 	bfi	r1, r3, #6, #10
    2ecc:	4842      	ldr	r0, [pc, #264]	; (2fd8 <hard_fault+0x12c>)
    2ece:	f7fe fe83 	bl	1bd8 <log_0>
		reason = esf->basic.r0;
	}

	*recoverable = memory_fault_recoverable(esf, true);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	*recoverable = false;
    2ed2:	2300      	movs	r3, #0
    2ed4:	7023      	strb	r3, [r4, #0]

	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    2ed6:	4b41      	ldr	r3, [pc, #260]	; (2fdc <hard_fault+0x130>)
    2ed8:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    2eda:	f016 0602 	ands.w	r6, r6, #2
    2ede:	d109      	bne.n	2ef4 <hard_fault+0x48>
		PR_EXC("  Bus fault on vector table read");
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    2ee0:	4b3e      	ldr	r3, [pc, #248]	; (2fdc <hard_fault+0x130>)
    2ee2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2ee4:	2b00      	cmp	r3, #0
    2ee6:	db17      	blt.n	2f18 <hard_fault+0x6c>
		PR_EXC("  Debug event");
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    2ee8:	4b3c      	ldr	r3, [pc, #240]	; (2fdc <hard_fault+0x130>)
    2eea:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    2eec:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
    2ef0:	d124      	bne.n	2f3c <hard_fault+0x90>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	return reason;
}
    2ef2:	bd70      	pop	{r4, r5, r6, pc}
    2ef4:	4b36      	ldr	r3, [pc, #216]	; (2fd0 <hard_fault+0x124>)
    2ef6:	4a37      	ldr	r2, [pc, #220]	; (2fd4 <hard_fault+0x128>)
    2ef8:	1a9b      	subs	r3, r3, r2
    2efa:	08db      	lsrs	r3, r3, #3
		PR_EXC("  Bus fault on vector table read");
    2efc:	f04f 0100 	mov.w	r1, #0
    2f00:	2201      	movs	r2, #1
    2f02:	f362 0102 	bfi	r1, r2, #0, #3
    2f06:	f36f 01c5 	bfc	r1, #3, #3
    2f0a:	f363 118f 	bfi	r1, r3, #6, #10
    2f0e:	4834      	ldr	r0, [pc, #208]	; (2fe0 <hard_fault+0x134>)
    2f10:	f7fe fe62 	bl	1bd8 <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2f14:	2000      	movs	r0, #0
    2f16:	e7ec      	b.n	2ef2 <hard_fault+0x46>
    2f18:	4b2d      	ldr	r3, [pc, #180]	; (2fd0 <hard_fault+0x124>)
    2f1a:	4a2e      	ldr	r2, [pc, #184]	; (2fd4 <hard_fault+0x128>)
    2f1c:	1a9b      	subs	r3, r3, r2
    2f1e:	08db      	lsrs	r3, r3, #3
		PR_EXC("  Debug event");
    2f20:	f04f 0100 	mov.w	r1, #0
    2f24:	2201      	movs	r2, #1
    2f26:	f362 0102 	bfi	r1, r2, #0, #3
    2f2a:	f36f 01c5 	bfc	r1, #3, #3
    2f2e:	f363 118f 	bfi	r1, r3, #6, #10
    2f32:	482c      	ldr	r0, [pc, #176]	; (2fe4 <hard_fault+0x138>)
    2f34:	f7fe fe50 	bl	1bd8 <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2f38:	4630      	mov	r0, r6
    2f3a:	e7da      	b.n	2ef2 <hard_fault+0x46>
    2f3c:	4b24      	ldr	r3, [pc, #144]	; (2fd0 <hard_fault+0x124>)
    2f3e:	4a25      	ldr	r2, [pc, #148]	; (2fd4 <hard_fault+0x128>)
    2f40:	1a9b      	subs	r3, r3, r2
    2f42:	08db      	lsrs	r3, r3, #3
		PR_EXC("  Fault escalation (see below)");
    2f44:	f04f 0100 	mov.w	r1, #0
    2f48:	2201      	movs	r2, #1
    2f4a:	f362 0102 	bfi	r1, r2, #0, #3
    2f4e:	f36f 01c5 	bfc	r1, #3, #3
    2f52:	f363 118f 	bfi	r1, r3, #6, #10
    2f56:	4824      	ldr	r0, [pc, #144]	; (2fe8 <hard_fault+0x13c>)
    2f58:	f7fe fe3e 	bl	1bd8 <log_0>
	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
    2f5c:	69ab      	ldr	r3, [r5, #24]
	uint16_t fault_insn = *(ret_addr - 1);
    2f5e:	f833 2c02 	ldrh.w	r2, [r3, #-2]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    2f62:	f64d 7302 	movw	r3, #57090	; 0xdf02
    2f66:	429a      	cmp	r2, r3
    2f68:	d00e      	beq.n	2f88 <hard_fault+0xdc>
		} else if (SCB_MMFSR != 0) {
    2f6a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2f6e:	f603 6326 	addw	r3, r3, #3622	; 0xe26
    2f72:	781b      	ldrb	r3, [r3, #0]
    2f74:	b9db      	cbnz	r3, 2fae <hard_fault+0x102>
		} else if (SCB_BFSR != 0) {
    2f76:	4b1d      	ldr	r3, [pc, #116]	; (2fec <hard_fault+0x140>)
    2f78:	781b      	ldrb	r3, [r3, #0]
    2f7a:	b9f3      	cbnz	r3, 2fba <hard_fault+0x10e>
		} else if (SCB_UFSR != 0) {
    2f7c:	4b1c      	ldr	r3, [pc, #112]	; (2ff0 <hard_fault+0x144>)
    2f7e:	881b      	ldrh	r3, [r3, #0]
    2f80:	b29b      	uxth	r3, r3
    2f82:	bb03      	cbnz	r3, 2fc6 <hard_fault+0x11a>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2f84:	4630      	mov	r0, r6
	return reason;
    2f86:	e7b4      	b.n	2ef2 <hard_fault+0x46>
    2f88:	4b11      	ldr	r3, [pc, #68]	; (2fd0 <hard_fault+0x124>)
    2f8a:	4a12      	ldr	r2, [pc, #72]	; (2fd4 <hard_fault+0x128>)
    2f8c:	1a9b      	subs	r3, r3, r2
    2f8e:	08db      	lsrs	r3, r3, #3
			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
    2f90:	f04f 0200 	mov.w	r2, #0
    2f94:	2101      	movs	r1, #1
    2f96:	f361 0202 	bfi	r2, r1, #0, #3
    2f9a:	f36f 02c5 	bfc	r2, #3, #3
    2f9e:	f363 128f 	bfi	r2, r3, #6, #10
    2fa2:	6829      	ldr	r1, [r5, #0]
    2fa4:	4813      	ldr	r0, [pc, #76]	; (2ff4 <hard_fault+0x148>)
    2fa6:	f7fe fda5 	bl	1af4 <log_1>
			reason = esf->basic.r0;
    2faa:	6828      	ldr	r0, [r5, #0]
    2fac:	e7a1      	b.n	2ef2 <hard_fault+0x46>
			reason = mem_manage_fault(esf, 1, recoverable);
    2fae:	4622      	mov	r2, r4
    2fb0:	2101      	movs	r1, #1
    2fb2:	4628      	mov	r0, r5
    2fb4:	f7ff fe98 	bl	2ce8 <mem_manage_fault>
    2fb8:	e79b      	b.n	2ef2 <hard_fault+0x46>
			reason = bus_fault(esf, 1, recoverable);
    2fba:	4622      	mov	r2, r4
    2fbc:	2101      	movs	r1, #1
    2fbe:	4628      	mov	r0, r5
    2fc0:	f7ff fdba 	bl	2b38 <bus_fault>
    2fc4:	e795      	b.n	2ef2 <hard_fault+0x46>
			reason = usage_fault(esf);
    2fc6:	4628      	mov	r0, r5
    2fc8:	f7ff fcea 	bl	29a0 <usage_fault>
    2fcc:	e791      	b.n	2ef2 <hard_fault+0x46>
    2fce:	bf00      	nop
    2fd0:	00008e70 	.word	0x00008e70
    2fd4:	00008e48 	.word	0x00008e48
    2fd8:	00009478 	.word	0x00009478
    2fdc:	e000ed00 	.word	0xe000ed00
    2fe0:	00009490 	.word	0x00009490
    2fe4:	000094b4 	.word	0x000094b4
    2fe8:	000094c4 	.word	0x000094c4
    2fec:	e000ed29 	.word	0xe000ed29
    2ff0:	e000ed2a 	.word	0xe000ed2a
    2ff4:	000094e4 	.word	0x000094e4

00002ff8 <reserved_exception>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void reserved_exception(const z_arch_esf_t *esf, int fault)
{
    2ff8:	b508      	push	{r3, lr}
    2ffa:	460a      	mov	r2, r1
    2ffc:	480b      	ldr	r0, [pc, #44]	; (302c <reserved_exception+0x34>)
    2ffe:	4b0c      	ldr	r3, [pc, #48]	; (3030 <reserved_exception+0x38>)
    3000:	1ac0      	subs	r0, r0, r3
    3002:	08c0      	lsrs	r0, r0, #3
	ARG_UNUSED(esf);

	PR_FAULT_INFO("***** %s %d) *****",
    3004:	f04f 0300 	mov.w	r3, #0
    3008:	2101      	movs	r1, #1
    300a:	f361 0302 	bfi	r3, r1, #0, #3
    300e:	f36f 03c5 	bfc	r3, #3, #3
    3012:	f360 138f 	bfi	r3, r0, #6, #10
    3016:	2a0f      	cmp	r2, #15
    3018:	dc05      	bgt.n	3026 <reserved_exception+0x2e>
    301a:	4906      	ldr	r1, [pc, #24]	; (3034 <reserved_exception+0x3c>)
    301c:	3a10      	subs	r2, #16
    301e:	4806      	ldr	r0, [pc, #24]	; (3038 <reserved_exception+0x40>)
    3020:	f7fe fd9e 	bl	1b60 <log_2>
	       fault < 16 ? "Reserved Exception (" : "Spurious interrupt (IRQ ",
	       fault - 16);
}
    3024:	bd08      	pop	{r3, pc}
	PR_FAULT_INFO("***** %s %d) *****",
    3026:	4905      	ldr	r1, [pc, #20]	; (303c <reserved_exception+0x44>)
    3028:	e7f8      	b.n	301c <reserved_exception+0x24>
    302a:	bf00      	nop
    302c:	00008e70 	.word	0x00008e70
    3030:	00008e48 	.word	0x00008e48
    3034:	00009500 	.word	0x00009500
    3038:	00009534 	.word	0x00009534
    303c:	00009518 	.word	0x00009518

00003040 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    3040:	b570      	push	{r4, r5, r6, lr}
    3042:	b08a      	sub	sp, #40	; 0x28
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    3044:	4b2b      	ldr	r3, [pc, #172]	; (30f4 <z_arm_fault+0xb4>)
    3046:	685d      	ldr	r5, [r3, #4]
    3048:	f3c5 0508 	ubfx	r5, r5, #0, #9
    304c:	2300      	movs	r3, #0
    304e:	f383 8811 	msr	BASEPRI, r3
    3052:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    3056:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    305a:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    305e:	d12a      	bne.n	30b6 <z_arm_fault+0x76>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    3060:	f002 030c 	and.w	r3, r2, #12
    3064:	2b08      	cmp	r3, #8
    3066:	d010      	beq.n	308a <z_arm_fault+0x4a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    3068:	f012 0f08 	tst.w	r2, #8
    306c:	d020      	beq.n	30b0 <z_arm_fault+0x70>
			ptr_esf =  (z_arch_esf_t *)psp;
    306e:	460c      	mov	r4, r1
	*nested_exc = false;
    3070:	2600      	movs	r6, #0

#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
    3072:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    3076:	4629      	mov	r1, r5
    3078:	4620      	mov	r0, r4
    307a:	f004 fde9 	bl	7c50 <fault_handle>
    307e:	4605      	mov	r5, r0
	if (recoverable) {
    3080:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3084:	b1d3      	cbz	r3, 30bc <z_arm_fault+0x7c>
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
	}

	z_arm_fatal_error(reason, &esf_copy);
}
    3086:	b00a      	add	sp, #40	; 0x28
    3088:	bd70      	pop	{r4, r5, r6, pc}
    308a:	4b1b      	ldr	r3, [pc, #108]	; (30f8 <z_arm_fault+0xb8>)
    308c:	4a1b      	ldr	r2, [pc, #108]	; (30fc <z_arm_fault+0xbc>)
    308e:	1a9b      	subs	r3, r3, r2
    3090:	08db      	lsrs	r3, r3, #3
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    3092:	f04f 0100 	mov.w	r1, #0
    3096:	2201      	movs	r2, #1
    3098:	f362 0102 	bfi	r1, r2, #0, #3
    309c:	f36f 01c5 	bfc	r1, #3, #3
    30a0:	f363 118f 	bfi	r1, r3, #6, #10
    30a4:	4816      	ldr	r0, [pc, #88]	; (3100 <z_arm_fault+0xc0>)
    30a6:	f7fe fd97 	bl	1bd8 <log_0>
	*nested_exc = false;
    30aa:	2600      	movs	r6, #0
		return NULL;
    30ac:	4634      	mov	r4, r6
    30ae:	e7e0      	b.n	3072 <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    30b0:	4604      	mov	r4, r0
			*nested_exc = true;
    30b2:	2601      	movs	r6, #1
    30b4:	e7dd      	b.n	3072 <z_arm_fault+0x32>
	*nested_exc = false;
    30b6:	2600      	movs	r6, #0
		return NULL;
    30b8:	4634      	mov	r4, r6
    30ba:	e7da      	b.n	3072 <z_arm_fault+0x32>
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    30bc:	2220      	movs	r2, #32
    30be:	4621      	mov	r1, r4
    30c0:	a801      	add	r0, sp, #4
    30c2:	f004 fe61 	bl	7d88 <memcpy>
	if (nested_exc) {
    30c6:	b14e      	cbz	r6, 30dc <z_arm_fault+0x9c>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    30c8:	9b08      	ldr	r3, [sp, #32]
    30ca:	f3c3 0208 	ubfx	r2, r3, #0, #9
    30ce:	b95a      	cbnz	r2, 30e8 <z_arm_fault+0xa8>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    30d0:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    30d4:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    30d8:	9308      	str	r3, [sp, #32]
    30da:	e005      	b.n	30e8 <z_arm_fault+0xa8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    30dc:	9b08      	ldr	r3, [sp, #32]
    30de:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    30e2:	f023 0301 	bic.w	r3, r3, #1
    30e6:	9308      	str	r3, [sp, #32]
	z_arm_fatal_error(reason, &esf_copy);
    30e8:	a901      	add	r1, sp, #4
    30ea:	4628      	mov	r0, r5
    30ec:	f004 fd90 	bl	7c10 <z_arm_fatal_error>
    30f0:	e7c9      	b.n	3086 <z_arm_fault+0x46>
    30f2:	bf00      	nop
    30f4:	e000ed00 	.word	0xe000ed00
    30f8:	00008e70 	.word	0x00008e70
    30fc:	00008e48 	.word	0x00008e48
    3100:	00009548 	.word	0x00009548

00003104 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    3104:	4a02      	ldr	r2, [pc, #8]	; (3110 <z_arm_fault_init+0xc>)
    3106:	6953      	ldr	r3, [r2, #20]
    3108:	f043 0310 	orr.w	r3, r3, #16
    310c:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    310e:	4770      	bx	lr
    3110:	e000ed00 	.word	0xe000ed00

00003114 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    3114:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    3118:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    311c:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    311e:	4672      	mov	r2, lr
	bl z_arm_fault
    3120:	f7ff ff8e 	bl	3040 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    3124:	bd01      	pop	{r0, pc}
    3126:	bf00      	nop

00003128 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    3128:	2200      	movs	r2, #0

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    312a:	e006      	b.n	313a <z_arm_interrupt_init+0x12>
    312c:	f002 010f 	and.w	r1, r2, #15
    3130:	4b09      	ldr	r3, [pc, #36]	; (3158 <z_arm_interrupt_init+0x30>)
    3132:	440b      	add	r3, r1
    3134:	2120      	movs	r1, #32
    3136:	7619      	strb	r1, [r3, #24]
    3138:	3201      	adds	r2, #1
    313a:	2a26      	cmp	r2, #38	; 0x26
    313c:	dc0a      	bgt.n	3154 <z_arm_interrupt_init+0x2c>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
    313e:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
    3140:	2b00      	cmp	r3, #0
    3142:	dbf3      	blt.n	312c <z_arm_interrupt_init+0x4>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    3144:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    3148:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    314c:	2120      	movs	r1, #32
    314e:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    3152:	e7f1      	b.n	3138 <z_arm_interrupt_init+0x10>
	}
}
    3154:	4770      	bx	lr
    3156:	bf00      	nop
    3158:	e000ecfc 	.word	0xe000ecfc

0000315c <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
    315c:	2000      	movs	r0, #0
    msr CONTROL, r0
    315e:	f380 8814 	msr	CONTROL, r0
    isb
    3162:	f3bf 8f6f 	isb	sy
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    3166:	f005 fd85 	bl	8c74 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
    316a:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
    316c:	490d      	ldr	r1, [pc, #52]	; (31a4 <__start+0x48>)
    str r0, [r1]
    316e:	6008      	str	r0, [r1, #0]
    dsb
    3170:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    3174:	480c      	ldr	r0, [pc, #48]	; (31a8 <__start+0x4c>)
    msr msp, r0
    3176:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
    317a:	f000 f829 	bl	31d0 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    317e:	2020      	movs	r0, #32
    msr BASEPRI, r0
    3180:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    3184:	4809      	ldr	r0, [pc, #36]	; (31ac <__start+0x50>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    3186:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
    318a:	1840      	adds	r0, r0, r1
    msr PSP, r0
    318c:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    3190:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    3194:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    3196:	4308      	orrs	r0, r1
    msr CONTROL, r0
    3198:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    319c:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    31a0:	f7ff faf6 	bl	2790 <z_arm_prep_c>
    ldr r1, =_SCS_MPU_CTRL
    31a4:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    31a8:	20001d20 	.word	0x20001d20
    ldr r0, =z_interrupt_stacks
    31ac:	20001ea0 	.word	0x20001ea0

000031b0 <z_arm_clear_arm_mpu_config>:
void z_arm_clear_arm_mpu_config(void)
{
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
    31b0:	4b06      	ldr	r3, [pc, #24]	; (31cc <z_arm_clear_arm_mpu_config+0x1c>)
    31b2:	6818      	ldr	r0, [r3, #0]
	int num_regions =
    31b4:	f3c0 2007 	ubfx	r0, r0, #8, #8

	for (i = 0; i < num_regions; i++) {
    31b8:	2300      	movs	r3, #0
    31ba:	4283      	cmp	r3, r0
    31bc:	da05      	bge.n	31ca <z_arm_clear_arm_mpu_config+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    31be:	4a03      	ldr	r2, [pc, #12]	; (31cc <z_arm_clear_arm_mpu_config+0x1c>)
    31c0:	6093      	str	r3, [r2, #8]
  MPU->RASR = 0U;
    31c2:	2100      	movs	r1, #0
    31c4:	6111      	str	r1, [r2, #16]
    31c6:	3301      	adds	r3, #1
    31c8:	e7f7      	b.n	31ba <z_arm_clear_arm_mpu_config+0xa>
		ARM_MPU_ClrRegion(i);
	}
}
    31ca:	4770      	bx	lr
    31cc:	e000ed90 	.word	0xe000ed90

000031d0 <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
    31d0:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    31d2:	b672      	cpsid	i
  \details Assigns the given value to the Fault Mask register.
  \param [in]    faultMask  Fault Mask value to set
 */
__STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
{
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
    31d4:	2400      	movs	r4, #0
    31d6:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
    31da:	f7ff ffe9 	bl	31b0 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    31de:	4623      	mov	r3, r4
    31e0:	e008      	b.n	31f4 <z_arm_init_arch_hw_at_boot+0x24>
		NVIC->ICER[i] = 0xFFFFFFFF;
    31e2:	f103 0120 	add.w	r1, r3, #32
    31e6:	4a0e      	ldr	r2, [pc, #56]	; (3220 <z_arm_init_arch_hw_at_boot+0x50>)
    31e8:	f04f 30ff 	mov.w	r0, #4294967295
    31ec:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    31f0:	3301      	adds	r3, #1
    31f2:	b2db      	uxtb	r3, r3
    31f4:	2b07      	cmp	r3, #7
    31f6:	d9f4      	bls.n	31e2 <z_arm_init_arch_hw_at_boot+0x12>
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    31f8:	2300      	movs	r3, #0
    31fa:	e008      	b.n	320e <z_arm_init_arch_hw_at_boot+0x3e>
		NVIC->ICPR[i] = 0xFFFFFFFF;
    31fc:	f103 0160 	add.w	r1, r3, #96	; 0x60
    3200:	4a07      	ldr	r2, [pc, #28]	; (3220 <z_arm_init_arch_hw_at_boot+0x50>)
    3202:	f04f 30ff 	mov.w	r0, #4294967295
    3206:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    320a:	3301      	adds	r3, #1
    320c:	b2db      	uxtb	r3, r3
    320e:	2b07      	cmp	r3, #7
    3210:	d9f4      	bls.n	31fc <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
    3212:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
    3214:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3218:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
    321c:	bd10      	pop	{r4, pc}
    321e:	bf00      	nop
    3220:	e000e100 	.word	0xe000e100

00003224 <z_impl_k_thread_abort>:
#include <kswap.h>
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    3224:	b508      	push	{r3, lr}
	if (_current == thread) {
    3226:	4b08      	ldr	r3, [pc, #32]	; (3248 <z_impl_k_thread_abort+0x24>)
    3228:	689b      	ldr	r3, [r3, #8]
    322a:	4283      	cmp	r3, r0
    322c:	d002      	beq.n	3234 <z_impl_k_thread_abort+0x10>
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
		}
	}

	z_thread_abort(thread);
    322e:	f003 fbe5 	bl	69fc <z_thread_abort>
}
    3232:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    3234:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    3238:	2b00      	cmp	r3, #0
    323a:	d0f8      	beq.n	322e <z_impl_k_thread_abort+0xa>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    323c:	4a03      	ldr	r2, [pc, #12]	; (324c <z_impl_k_thread_abort+0x28>)
    323e:	6853      	ldr	r3, [r2, #4]
    3240:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    3244:	6053      	str	r3, [r2, #4]
    3246:	e7f2      	b.n	322e <z_impl_k_thread_abort+0xa>
    3248:	200009bc 	.word	0x200009bc
    324c:	e000ed00 	.word	0xe000ed00

00003250 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    3250:	b508      	push	{r3, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    3252:	4b03      	ldr	r3, [pc, #12]	; (3260 <z_arm_configure_static_mpu_regions+0x10>)
    3254:	4a03      	ldr	r2, [pc, #12]	; (3264 <z_arm_configure_static_mpu_regions+0x14>)
    3256:	2101      	movs	r1, #1
    3258:	4803      	ldr	r0, [pc, #12]	; (3268 <z_arm_configure_static_mpu_regions+0x18>)
    325a:	f004 fd4e 	bl	7cfa <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    325e:	bd08      	pop	{r3, pc}
    3260:	20010000 	.word	0x20010000
    3264:	20000000 	.word	0x20000000
    3268:	00009578 	.word	0x00009578

0000326c <z_arm_configure_dynamic_mpu_regions>:
 *
 * This function is not inherently thread-safe, but the memory domain
 * spinlock needs to be held anyway.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    326c:	b508      	push	{r3, lr}
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
    326e:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
    3272:	3b20      	subs	r3, #32
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
    3274:	4804      	ldr	r0, [pc, #16]	; (3288 <z_arm_configure_dynamic_mpu_regions+0x1c>)
    3276:	6003      	str	r3, [r0, #0]
	dynamic_regions[region_num].size = guard_size;
    3278:	2320      	movs	r3, #32
    327a:	6043      	str	r3, [r0, #4]
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
    327c:	4b03      	ldr	r3, [pc, #12]	; (328c <z_arm_configure_dynamic_mpu_regions+0x20>)
    327e:	6083      	str	r3, [r0, #8]

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
    3280:	2101      	movs	r1, #1
    3282:	f004 fd3e 	bl	7d02 <arm_core_mpu_configure_dynamic_mpu_regions>
						   region_num);
}
    3286:	bd08      	pop	{r3, pc}
    3288:	20000448 	.word	0x20000448
    328c:	150b0000 	.word	0x150b0000

00003290 <region_init>:
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
    3290:	4a06      	ldr	r2, [pc, #24]	; (32ac <region_init+0x1c>)
    3292:	6090      	str	r0, [r2, #8]

	set_region_base_address(region_conf->base & MPU_RBAR_ADDR_Msk);
	set_region_attributes(region_conf->attr.rasr);
	set_region_size(region_conf->size | MPU_RASR_ENABLE_Msk);
#else
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    3294:	680b      	ldr	r3, [r1, #0]
    3296:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    329a:	4303      	orrs	r3, r0
    329c:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    32a0:	60d3      	str	r3, [r2, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    32a2:	688b      	ldr	r3, [r1, #8]
    32a4:	f043 0301 	orr.w	r3, r3, #1
    32a8:	6113      	str	r3, [r2, #16]
	LOG_DBG("[%d] 0x%08x 0x%08x",
		index, region_conf->base, region_conf->attr.rasr);
#endif
}
    32aa:	4770      	bx	lr
    32ac:	e000ed90 	.word	0xe000ed90

000032b0 <region_allocate_and_init>:
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
    32b0:	b510      	push	{r4, lr}
    32b2:	4604      	mov	r4, r0
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
    32b4:	2807      	cmp	r0, #7
    32b6:	d803      	bhi.n	32c0 <region_allocate_and_init+0x10>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    32b8:	f7ff ffea 	bl	3290 <region_init>

	return index;
    32bc:	4620      	mov	r0, r4
}
    32be:	bd10      	pop	{r4, pc}
    32c0:	4b09      	ldr	r3, [pc, #36]	; (32e8 <region_allocate_and_init+0x38>)
    32c2:	4a0a      	ldr	r2, [pc, #40]	; (32ec <region_allocate_and_init+0x3c>)
    32c4:	1a9b      	subs	r3, r3, r2
    32c6:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    32c8:	f04f 0200 	mov.w	r2, #0
    32cc:	2101      	movs	r1, #1
    32ce:	f361 0202 	bfi	r2, r1, #0, #3
    32d2:	f36f 02c5 	bfc	r2, #3, #3
    32d6:	f363 128f 	bfi	r2, r3, #6, #10
    32da:	4601      	mov	r1, r0
    32dc:	4804      	ldr	r0, [pc, #16]	; (32f0 <region_allocate_and_init+0x40>)
    32de:	f7fe fc09 	bl	1af4 <log_1>
		return -EINVAL;
    32e2:	f06f 0015 	mvn.w	r0, #21
    32e6:	e7ea      	b.n	32be <region_allocate_and_init+0xe>
    32e8:	00008e68 	.word	0x00008e68
    32ec:	00008e48 	.word	0x00008e48
    32f0:	00009584 	.word	0x00009584

000032f4 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    32f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    32f8:	4680      	mov	r8, r0
    32fa:	460f      	mov	r7, r1
    32fc:	469a      	mov	sl, r3
	int i;
	int reg_index = start_reg_index;
    32fe:	4616      	mov	r6, r2

	for (i = 0; i < regions_num; i++) {
    3300:	2400      	movs	r4, #0
    3302:	e009      	b.n	3318 <mpu_configure_regions+0x24>
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
    3304:	4629      	mov	r1, r5
    3306:	b2f0      	uxtb	r0, r6
    3308:	f004 fcd8 	bl	7cbc <mpu_configure_region>
    330c:	4606      	mov	r6, r0

		if (reg_index == -EINVAL) {
    330e:	f110 0f16 	cmn.w	r0, #22
    3312:	d025      	beq.n	3360 <mpu_configure_regions+0x6c>
			return reg_index;
		}

		/* Increment number of programmed MPU indices. */
		reg_index++;
    3314:	3601      	adds	r6, #1
	for (i = 0; i < regions_num; i++) {
    3316:	3401      	adds	r4, #1
    3318:	42bc      	cmp	r4, r7
    331a:	da21      	bge.n	3360 <mpu_configure_regions+0x6c>
		if (regions[i].size == 0U) {
    331c:	eb04 0544 	add.w	r5, r4, r4, lsl #1
    3320:	eb08 0585 	add.w	r5, r8, r5, lsl #2
    3324:	686a      	ldr	r2, [r5, #4]
    3326:	2a00      	cmp	r2, #0
    3328:	d0f5      	beq.n	3316 <mpu_configure_regions+0x22>
		if (do_sanity_check &&
    332a:	f1ba 0f00 	cmp.w	sl, #0
    332e:	d0e9      	beq.n	3304 <mpu_configure_regions+0x10>
				(!mpu_partition_is_valid(&regions[i]))) {
    3330:	4628      	mov	r0, r5
    3332:	f004 fcb2 	bl	7c9a <mpu_partition_is_valid>
		if (do_sanity_check &&
    3336:	2800      	cmp	r0, #0
    3338:	d1e4      	bne.n	3304 <mpu_configure_regions+0x10>
    333a:	4b0b      	ldr	r3, [pc, #44]	; (3368 <mpu_configure_regions+0x74>)
    333c:	4a0b      	ldr	r2, [pc, #44]	; (336c <mpu_configure_regions+0x78>)
    333e:	1a9b      	subs	r3, r3, r2
    3340:	08db      	lsrs	r3, r3, #3
			LOG_ERR("Partition %u: sanity check failed.", i);
    3342:	f04f 0200 	mov.w	r2, #0
    3346:	2101      	movs	r1, #1
    3348:	f361 0202 	bfi	r2, r1, #0, #3
    334c:	f36f 02c5 	bfc	r2, #3, #3
    3350:	f363 128f 	bfi	r2, r3, #6, #10
    3354:	4621      	mov	r1, r4
    3356:	4806      	ldr	r0, [pc, #24]	; (3370 <mpu_configure_regions+0x7c>)
    3358:	f7fe fbcc 	bl	1af4 <log_1>
			return -EINVAL;
    335c:	f06f 0615 	mvn.w	r6, #21
	}

	return reg_index;
}
    3360:	4630      	mov	r0, r6
    3362:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    3366:	bf00      	nop
    3368:	00008e68 	.word	0x00008e68
    336c:	00008e48 	.word	0x00008e48
    3370:	000095ac 	.word	0x000095ac

00003374 <mpu_configure_static_mpu_regions>:
 */
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
    3374:	b510      	push	{r4, lr}
	int mpu_reg_index = static_regions_num;
    3376:	4c03      	ldr	r4, [pc, #12]	; (3384 <mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    3378:	2301      	movs	r3, #1
    337a:	7822      	ldrb	r2, [r4, #0]
    337c:	f7ff ffba 	bl	32f4 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    3380:	7020      	strb	r0, [r4, #0]

	return mpu_reg_index;
}
    3382:	bd10      	pop	{r4, pc}
    3384:	200009fc 	.word	0x200009fc

00003388 <mpu_configure_dynamic_mpu_regions>:
 * If the dynamic MPU regions configuration has not been successfully
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
    3388:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    338a:	2300      	movs	r3, #0
    338c:	4a08      	ldr	r2, [pc, #32]	; (33b0 <mpu_configure_dynamic_mpu_regions+0x28>)
    338e:	7812      	ldrb	r2, [r2, #0]
    3390:	f7ff ffb0 	bl	32f4 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    3394:	f110 0f16 	cmn.w	r0, #22
    3398:	d008      	beq.n	33ac <mpu_configure_dynamic_mpu_regions+0x24>

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    339a:	4603      	mov	r3, r0
    339c:	2b07      	cmp	r3, #7
    339e:	dc05      	bgt.n	33ac <mpu_configure_dynamic_mpu_regions+0x24>
  MPU->RNR = rnr;
    33a0:	4a04      	ldr	r2, [pc, #16]	; (33b4 <mpu_configure_dynamic_mpu_regions+0x2c>)
    33a2:	6093      	str	r3, [r2, #8]
  MPU->RASR = 0U;
    33a4:	2100      	movs	r1, #0
    33a6:	6111      	str	r1, [r2, #16]
    33a8:	3301      	adds	r3, #1
    33aa:	e7f7      	b.n	339c <mpu_configure_dynamic_mpu_regions+0x14>
			ARM_MPU_ClrRegion(i);
		}
	}

	return mpu_reg_index;
}
    33ac:	bd08      	pop	{r3, pc}
    33ae:	bf00      	nop
    33b0:	200009fc 	.word	0x200009fc
    33b4:	e000ed90 	.word	0xe000ed90

000033b8 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    33b8:	4b03      	ldr	r3, [pc, #12]	; (33c8 <arm_core_mpu_enable+0x10>)
    33ba:	2205      	movs	r2, #5
    33bc:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    33be:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    33c2:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    33c6:	4770      	bx	lr
    33c8:	e000ed90 	.word	0xe000ed90

000033cc <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    33cc:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    33d0:	4b01      	ldr	r3, [pc, #4]	; (33d8 <arm_core_mpu_disable+0xc>)
    33d2:	2200      	movs	r2, #0
    33d4:	605a      	str	r2, [r3, #4]
}
    33d6:	4770      	bx	lr
    33d8:	e000ed90 	.word	0xe000ed90

000033dc <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
    33dc:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    33de:	4b0e      	ldr	r3, [pc, #56]	; (3418 <z_arm_mpu_init+0x3c>)
    33e0:	681d      	ldr	r5, [r3, #0]
    33e2:	2d08      	cmp	r5, #8
    33e4:	d815      	bhi.n	3412 <z_arm_mpu_init+0x36>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    33e6:	f7ff fff1 	bl	33cc <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    33ea:	2400      	movs	r4, #0
    33ec:	42a5      	cmp	r5, r4
    33ee:	d90a      	bls.n	3406 <z_arm_mpu_init+0x2a>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    33f0:	4b09      	ldr	r3, [pc, #36]	; (3418 <z_arm_mpu_init+0x3c>)
    33f2:	6859      	ldr	r1, [r3, #4]
    33f4:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    33f8:	0093      	lsls	r3, r2, #2
    33fa:	4419      	add	r1, r3
    33fc:	4620      	mov	r0, r4
    33fe:	f7ff ff47 	bl	3290 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    3402:	3401      	adds	r4, #1
    3404:	e7f2      	b.n	33ec <z_arm_mpu_init+0x10>
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    3406:	4b05      	ldr	r3, [pc, #20]	; (341c <z_arm_mpu_init+0x40>)
    3408:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    340a:	f7ff ffd5 	bl	33b8 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    340e:	2000      	movs	r0, #0
}
    3410:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    3412:	f04f 30ff 	mov.w	r0, #4294967295
    3416:	e7fb      	b.n	3410 <z_arm_mpu_init+0x34>
    3418:	000095e0 	.word	0x000095e0
    341c:	200009fc 	.word	0x200009fc

00003420 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    3420:	4b01      	ldr	r3, [pc, #4]	; (3428 <__stdout_hook_install+0x8>)
    3422:	6018      	str	r0, [r3, #0]
}
    3424:	4770      	bx	lr
    3426:	bf00      	nop
    3428:	20000028 	.word	0x20000028

0000342c <nordicsemi_nrf52_init>:
	__asm__ volatile(
    342c:	f04f 0220 	mov.w	r2, #32
    3430:	f3ef 8311 	mrs	r3, BASEPRI
    3434:	f382 8812 	msr	BASEPRI_MAX, r2
    3438:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    343c:	4a04      	ldr	r2, [pc, #16]	; (3450 <nordicsemi_nrf52_init+0x24>)
    343e:	2101      	movs	r1, #1
    3440:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
    3444:	f383 8811 	msr	BASEPRI, r3
    3448:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    344c:	2000      	movs	r0, #0
    344e:	4770      	bx	lr
    3450:	4001e000 	.word	0x4001e000

00003454 <sys_arch_reboot>:
    }
    else
    {
        p_gpregret = &((volatile uint32_t *)&p_reg->GPREGRET)[0];
    }
    *p_gpregret = val;
    3454:	b2c0      	uxtb	r0, r0
    3456:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    345a:	f8c3 051c 	str.w	r0, [r3, #1308]	; 0x51c
  __ASM volatile ("dsb 0xF":::"memory");
    345e:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    3462:	4905      	ldr	r1, [pc, #20]	; (3478 <sys_arch_reboot+0x24>)
    3464:	68ca      	ldr	r2, [r1, #12]
    3466:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    346a:	4b04      	ldr	r3, [pc, #16]	; (347c <sys_arch_reboot+0x28>)
    346c:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    346e:	60cb      	str	r3, [r1, #12]
    3470:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    3474:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    3476:	e7fd      	b.n	3474 <sys_arch_reboot+0x20>
    3478:	e000ed00 	.word	0xe000ed00
    347c:	05fa0004 	.word	0x05fa0004

00003480 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    3480:	b130      	cbz	r0, 3490 <arch_busy_wait+0x10>

void arch_busy_wait(uint32_t time_us)
{
    3482:	b508      	push	{r3, lr}
    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    3484:	0180      	lsls	r0, r0, #6
    3486:	4b03      	ldr	r3, [pc, #12]	; (3494 <arch_busy_wait+0x14>)
    3488:	f043 0301 	orr.w	r3, r3, #1
    348c:	4798      	blx	r3
	nrfx_coredep_delay_us(time_us);
}
    348e:	bd08      	pop	{r3, pc}
    3490:	4770      	bx	lr
    3492:	bf00      	nop
    3494:	00008ef0 	.word	0x00008ef0

00003498 <get_hf_flags>:
static uint32_t *get_hf_flags(void)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;

	return &data->subsys[CLOCK_CONTROL_NRF_TYPE_HFCLK].flags;
}
    3498:	4800      	ldr	r0, [pc, #0]	; (349c <get_hf_flags+0x4>)
    349a:	4770      	bx	lr
    349c:	200004a4 	.word	0x200004a4

000034a0 <get_subsys>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    34a0:	4b03      	ldr	r3, [pc, #12]	; (34b0 <get_subsys+0x10>)
    34a2:	1ac0      	subs	r0, r0, r3
    34a4:	1080      	asrs	r0, r0, #2

	return (clock_control_subsys_t)offset;
}
    34a6:	4b03      	ldr	r3, [pc, #12]	; (34b4 <get_subsys+0x14>)
    34a8:	fb03 f000 	mul.w	r0, r3, r0
    34ac:	4770      	bx	lr
    34ae:	bf00      	nop
    34b0:	20000464 	.word	0x20000464
    34b4:	b6db6db7 	.word	0xb6db6db7

000034b8 <onoff_stop>:

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    34b8:	b538      	push	{r3, r4, r5, lr}
    34ba:	4605      	mov	r5, r0
    34bc:	460c      	mov	r4, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    34be:	f7ff ffef 	bl	34a0 <get_subsys>
    34c2:	4601      	mov	r1, r0
    34c4:	2240      	movs	r2, #64	; 0x40
    34c6:	4803      	ldr	r0, [pc, #12]	; (34d4 <onoff_stop+0x1c>)
    34c8:	f004 fd39 	bl	7f3e <stop>
    34cc:	4601      	mov	r1, r0
	notify(mgr, res);
    34ce:	4628      	mov	r0, r5
    34d0:	47a0      	blx	r4
}
    34d2:	bd38      	pop	{r3, r4, r5, pc}
    34d4:	00008cc8 	.word	0x00008cc8

000034d8 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    34d8:	b530      	push	{r4, r5, lr}
    34da:	b083      	sub	sp, #12
    34dc:	4605      	mov	r5, r0
    34de:	460c      	mov	r4, r1
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    34e0:	f7ff ffde 	bl	34a0 <get_subsys>
    34e4:	4601      	mov	r1, r0
    34e6:	2340      	movs	r3, #64	; 0x40
    34e8:	9300      	str	r3, [sp, #0]
    34ea:	4623      	mov	r3, r4
    34ec:	4a05      	ldr	r2, [pc, #20]	; (3504 <onoff_start+0x2c>)
    34ee:	4806      	ldr	r0, [pc, #24]	; (3508 <onoff_start+0x30>)
    34f0:	f004 fd3f 	bl	7f72 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    34f4:	1e01      	subs	r1, r0, #0
    34f6:	db01      	blt.n	34fc <onoff_start+0x24>
		notify(mgr, err);
	}
}
    34f8:	b003      	add	sp, #12
    34fa:	bd30      	pop	{r4, r5, pc}
		notify(mgr, err);
    34fc:	4628      	mov	r0, r5
    34fe:	47a0      	blx	r4
}
    3500:	e7fa      	b.n	34f8 <onoff_start+0x20>
    3502:	bf00      	nop
    3504:	00007fbb 	.word	0x00007fbb
    3508:	00008cc8 	.word	0x00008cc8

0000350c <clock_event_handler>:
		__ASSERT_NO_MSG(false);
	}
}

static void clock_event_handler(nrfx_clock_evt_type_t event)
{
    350c:	b508      	push	{r3, lr}
	const struct device *dev = CLOCK_DEVICE;

	switch (event) {
    350e:	b110      	cbz	r0, 3516 <clock_event_handler+0xa>
    3510:	2801      	cmp	r0, #1
    3512:	d00d      	beq.n	3530 <clock_event_handler+0x24>
		break;
	default:
		__ASSERT_NO_MSG(0);
		break;
	}
}
    3514:	bd08      	pop	{r3, pc}
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    3516:	2100      	movs	r1, #0
    3518:	4808      	ldr	r0, [pc, #32]	; (353c <clock_event_handler+0x30>)
    351a:	f004 fc97 	bl	7e4c <get_sub_data>
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    351e:	6883      	ldr	r3, [r0, #8]
    3520:	f013 0f07 	tst.w	r3, #7
    3524:	d1f6      	bne.n	3514 <clock_event_handler+0x8>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    3526:	2100      	movs	r1, #0
    3528:	4804      	ldr	r0, [pc, #16]	; (353c <clock_event_handler+0x30>)
    352a:	f004 fcf6 	bl	7f1a <clkstarted_handle>
    352e:	e7f1      	b.n	3514 <clock_event_handler+0x8>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    3530:	2101      	movs	r1, #1
    3532:	4802      	ldr	r0, [pc, #8]	; (353c <clock_event_handler+0x30>)
    3534:	f004 fcf1 	bl	7f1a <clkstarted_handle>
}
    3538:	e7ec      	b.n	3514 <clock_event_handler+0x8>
    353a:	bf00      	nop
    353c:	00008cc8 	.word	0x00008cc8

00003540 <generic_hfclk_start>:
{
    3540:	b510      	push	{r4, lr}
	__asm__ volatile(
    3542:	f04f 0320 	mov.w	r3, #32
    3546:	f3ef 8411 	mrs	r4, BASEPRI
    354a:	f383 8812 	msr	BASEPRI_MAX, r3
    354e:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    3552:	4a13      	ldr	r2, [pc, #76]	; (35a0 <generic_hfclk_start+0x60>)
    3554:	6813      	ldr	r3, [r2, #0]
    3556:	f043 0302 	orr.w	r3, r3, #2
    355a:	6013      	str	r3, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    355c:	f013 0f01 	tst.w	r3, #1
    3560:	d108      	bne.n	3574 <generic_hfclk_start+0x34>
	bool already_started = false;
    3562:	2300      	movs	r3, #0
	__asm__ volatile(
    3564:	f384 8811 	msr	BASEPRI, r4
    3568:	f3bf 8f6f 	isb	sy
	if (already_started) {
    356c:	b99b      	cbnz	r3, 3596 <generic_hfclk_start+0x56>
	hfclk_start();
    356e:	f004 fd2c 	bl	7fca <hfclk_start>
}
    3572:	bd10      	pop	{r4, pc}
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    3574:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3578:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    357c:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    3580:	f012 0f01 	tst.w	r2, #1
    3584:	d101      	bne.n	358a <generic_hfclk_start+0x4a>
	bool already_started = false;
    3586:	2300      	movs	r3, #0
    3588:	e7ec      	b.n	3564 <generic_hfclk_start+0x24>
			set_on_state(get_hf_flags());
    358a:	f7ff ff85 	bl	3498 <get_hf_flags>
    358e:	f004 fcb1 	bl	7ef4 <set_on_state>
			already_started = true;
    3592:	2301      	movs	r3, #1
    3594:	e7e6      	b.n	3564 <generic_hfclk_start+0x24>
		clkstarted_handle(CLOCK_DEVICE,
    3596:	2100      	movs	r1, #0
    3598:	4802      	ldr	r0, [pc, #8]	; (35a4 <generic_hfclk_start+0x64>)
    359a:	f004 fcbe 	bl	7f1a <clkstarted_handle>
		return;
    359e:	e7e8      	b.n	3572 <generic_hfclk_start+0x32>
    35a0:	200004b4 	.word	0x200004b4
    35a4:	00008cc8 	.word	0x00008cc8

000035a8 <generic_hfclk_stop>:
{
    35a8:	b508      	push	{r3, lr}
    35aa:	4b0a      	ldr	r3, [pc, #40]	; (35d4 <generic_hfclk_stop+0x2c>)
    35ac:	f3bf 8f5b 	dmb	ish
    35b0:	e853 2f00 	ldrex	r2, [r3]
    35b4:	f022 0102 	bic.w	r1, r2, #2
    35b8:	e843 1000 	strex	r0, r1, [r3]
    35bc:	2800      	cmp	r0, #0
    35be:	d1f7      	bne.n	35b0 <generic_hfclk_stop+0x8>
    35c0:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    35c4:	f012 0f01 	tst.w	r2, #1
    35c8:	d000      	beq.n	35cc <generic_hfclk_stop+0x24>
}
    35ca:	bd08      	pop	{r3, pc}
	hfclk_stop();
    35cc:	f004 fd02 	bl	7fd4 <hfclk_stop>
    35d0:	e7fb      	b.n	35ca <generic_hfclk_stop+0x22>
    35d2:	bf00      	nop
    35d4:	200004b4 	.word	0x200004b4

000035d8 <api_blocking_start>:
{
    35d8:	b500      	push	{lr}
    35da:	b085      	sub	sp, #20
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    35dc:	f8cd d000 	str.w	sp, [sp]
    35e0:	f8cd d004 	str.w	sp, [sp, #4]
    35e4:	2300      	movs	r3, #0
    35e6:	9302      	str	r3, [sp, #8]
    35e8:	2301      	movs	r3, #1
    35ea:	9303      	str	r3, [sp, #12]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    35ec:	466b      	mov	r3, sp
    35ee:	4a07      	ldr	r2, [pc, #28]	; (360c <api_blocking_start+0x34>)
    35f0:	f004 fcdb 	bl	7faa <api_start>
	if (err < 0) {
    35f4:	2800      	cmp	r0, #0
    35f6:	db05      	blt.n	3604 <api_blocking_start+0x2c>
	return z_impl_k_sem_take(sem, timeout);
    35f8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    35fc:	2300      	movs	r3, #0
    35fe:	4668      	mov	r0, sp
    3600:	f002 fe10 	bl	6224 <z_impl_k_sem_take>
}
    3604:	b005      	add	sp, #20
    3606:	f85d fb04 	ldr.w	pc, [sp], #4
    360a:	bf00      	nop
    360c:	00007fe9 	.word	0x00007fe9

00003610 <lfclk_start>:
{
    3610:	b508      	push	{r3, lr}
	if (!once) {
    3612:	4b07      	ldr	r3, [pc, #28]	; (3630 <lfclk_start+0x20>)
    3614:	781b      	ldrb	r3, [r3, #0]
    3616:	b11b      	cbz	r3, 3620 <lfclk_start+0x10>
}
#endif // defined(CLOCK_FEATURE_HFCLK_DIVIDE_PRESENT) || NRF_CLOCK_HAS_HFCLK_192M

NRFX_STATIC_INLINE void nrfx_clock_lfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    3618:	2000      	movs	r0, #0
    361a:	f001 facb 	bl	4bb4 <nrfx_clock_start>
}
    361e:	bd08      	pop	{r3, pc}
	z_impl_k_busy_wait(usec_to_wait);
    3620:	f44f 70a5 	mov.w	r0, #330	; 0x14a
    3624:	f005 faf8 	bl	8c18 <z_impl_k_busy_wait>
		once = true;
    3628:	4b01      	ldr	r3, [pc, #4]	; (3630 <lfclk_start+0x20>)
    362a:	2201      	movs	r2, #1
    362c:	701a      	strb	r2, [r3, #0]
    362e:	e7f3      	b.n	3618 <lfclk_start+0x8>
    3630:	200009fd 	.word	0x200009fd

00003634 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
    3634:	b570      	push	{r4, r5, r6, lr}
    3636:	4606      	mov	r6, r0
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    3638:	2200      	movs	r2, #0
    363a:	2101      	movs	r1, #1
    363c:	4610      	mov	r0, r2
    363e:	f7ff f88d 	bl	275c <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    3642:	2000      	movs	r0, #0
    3644:	f7ff f858 	bl	26f8 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    3648:	4811      	ldr	r0, [pc, #68]	; (3690 <clk_init+0x5c>)
    364a:	f001 fa9f 	bl	4b8c <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    364e:	4b11      	ldr	r3, [pc, #68]	; (3694 <clk_init+0x60>)
    3650:	4298      	cmp	r0, r3
    3652:	d11a      	bne.n	368a <clk_init+0x56>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    3654:	f004 fe3d 	bl	82d2 <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
    3658:	2400      	movs	r4, #0
    365a:	e003      	b.n	3664 <clk_init+0x30>
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    365c:	2301      	movs	r3, #1
    365e:	60ab      	str	r3, [r5, #8]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    3660:	441c      	add	r4, r3
    3662:	b2e4      	uxtb	r4, r4
	for (enum clock_control_nrf_type i = 0;
    3664:	2c01      	cmp	r4, #1
    3666:	d80e      	bhi.n	3686 <clk_init+0x52>
						get_sub_data(dev, i);
    3668:	4621      	mov	r1, r4
    366a:	4630      	mov	r0, r6
    366c:	f004 fbee 	bl	7e4c <get_sub_data>
    3670:	4605      	mov	r5, r0
		err = onoff_manager_init(get_onoff_manager(dev, i),
    3672:	4621      	mov	r1, r4
    3674:	4630      	mov	r0, r6
    3676:	f004 fbf6 	bl	7e66 <get_onoff_manager>
    367a:	4907      	ldr	r1, [pc, #28]	; (3698 <clk_init+0x64>)
    367c:	f003 fe76 	bl	736c <onoff_manager_init>
		if (err < 0) {
    3680:	2800      	cmp	r0, #0
    3682:	daeb      	bge.n	365c <clk_init+0x28>
    3684:	e000      	b.n	3688 <clk_init+0x54>
	}

	return 0;
    3686:	2000      	movs	r0, #0
}
    3688:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    368a:	f06f 0004 	mvn.w	r0, #4
    368e:	e7fb      	b.n	3688 <clk_init+0x54>
    3690:	0000350d 	.word	0x0000350d
    3694:	0bad0000 	.word	0x0bad0000
    3698:	0000965c 	.word	0x0000965c

0000369c <lfclk_spinwait>:
{
    369c:	b570      	push	{r4, r5, r6, lr}
    369e:	4605      	mov	r5, r0
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    36a0:	2801      	cmp	r0, #1
    36a2:	d107      	bne.n	36b4 <lfclk_spinwait+0x18>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    36a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    36a8:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    36ac:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    36b0:	2b01      	cmp	r3, #1
    36b2:	d058      	beq.n	3766 <lfclk_spinwait+0xca>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    36b4:	f005 f89f 	bl	87f6 <k_is_in_isr>
    36b8:	b928      	cbnz	r0, 36c6 <lfclk_spinwait+0x2a>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    36ba:	4b2e      	ldr	r3, [pc, #184]	; (3774 <lfclk_spinwait+0xd8>)
    36bc:	781b      	ldrb	r3, [r3, #0]
    36be:	2b00      	cmp	r3, #0
    36c0:	d041      	beq.n	3746 <lfclk_spinwait+0xaa>
    36c2:	2300      	movs	r3, #0
    36c4:	e000      	b.n	36c8 <lfclk_spinwait+0x2c>
    36c6:	2301      	movs	r3, #1
	int key = isr_mode ? irq_lock() : 0;
    36c8:	461c      	mov	r4, r3
    36ca:	2b00      	cmp	r3, #0
    36cc:	d03d      	beq.n	374a <lfclk_spinwait+0xae>
	__asm__ volatile(
    36ce:	f04f 0320 	mov.w	r3, #32
    36d2:	f3ef 8611 	mrs	r6, BASEPRI
    36d6:	f383 8812 	msr	BASEPRI_MAX, r3
    36da:	f3bf 8f6f 	isb	sy
	if (!isr_mode) {
    36de:	b924      	cbnz	r4, 36ea <lfclk_spinwait+0x4e>
    p_reg->INTENCLR = mask;
    36e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    36e4:	2202      	movs	r2, #2
    36e6:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    36ea:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    36ee:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    36f2:	f003 0303 	and.w	r3, r3, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    36f6:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
    36fa:	f412 3f80 	tst.w	r2, #65536	; 0x10000
    36fe:	d12b      	bne.n	3758 <lfclk_spinwait+0xbc>
    return false;
    3700:	2200      	movs	r2, #0
	while (!(nrfx_clock_is_running(d, (void *)&type)
    3702:	b11a      	cbz	r2, 370c <lfclk_spinwait+0x70>
    3704:	2b01      	cmp	r3, #1
    3706:	d029      	beq.n	375c <lfclk_spinwait+0xc0>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    3708:	2d01      	cmp	r5, #1
    370a:	d027      	beq.n	375c <lfclk_spinwait+0xc0>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    370c:	b1fc      	cbz	r4, 374e <lfclk_spinwait+0xb2>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    370e:	4630      	mov	r0, r6
    3710:	f7fe ff9a 	bl	2648 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    3714:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3718:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    371c:	2b00      	cmp	r3, #0
    371e:	d1e4      	bne.n	36ea <lfclk_spinwait+0x4e>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    3720:	4b15      	ldr	r3, [pc, #84]	; (3778 <lfclk_spinwait+0xdc>)
    3722:	681b      	ldr	r3, [r3, #0]
		    && nrf_clock_event_check(NRF_CLOCK,
    3724:	2b00      	cmp	r3, #0
    3726:	d0e0      	beq.n	36ea <lfclk_spinwait+0x4e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3728:	4b13      	ldr	r3, [pc, #76]	; (3778 <lfclk_spinwait+0xdc>)
    372a:	2200      	movs	r2, #0
    372c:	601a      	str	r2, [r3, #0]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    372e:	681b      	ldr	r3, [r3, #0]
    p_reg->LFCLKSRC = (uint32_t)(source);
    3730:	2301      	movs	r3, #1
    3732:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    3736:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    373a:	4a10      	ldr	r2, [pc, #64]	; (377c <lfclk_spinwait+0xe0>)
    373c:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3740:	4a0f      	ldr	r2, [pc, #60]	; (3780 <lfclk_spinwait+0xe4>)
    3742:	6013      	str	r3, [r2, #0]
}
    3744:	e7d1      	b.n	36ea <lfclk_spinwait+0x4e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    3746:	2301      	movs	r3, #1
    3748:	e7be      	b.n	36c8 <lfclk_spinwait+0x2c>
	int key = isr_mode ? irq_lock() : 0;
    374a:	2600      	movs	r6, #0
    374c:	e7c7      	b.n	36de <lfclk_spinwait+0x42>
	return z_impl_k_sleep(timeout);
    374e:	2021      	movs	r0, #33	; 0x21
    3750:	2100      	movs	r1, #0
    3752:	f003 f921 	bl	6998 <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    3756:	e7dd      	b.n	3714 <lfclk_spinwait+0x78>
                return true;
    3758:	2201      	movs	r2, #1
    375a:	e7d2      	b.n	3702 <lfclk_spinwait+0x66>
	if (isr_mode) {
    375c:	b124      	cbz	r4, 3768 <lfclk_spinwait+0xcc>
	__asm__ volatile(
    375e:	f386 8811 	msr	BASEPRI, r6
    3762:	f3bf 8f6f 	isb	sy
}
    3766:	bd70      	pop	{r4, r5, r6, pc}
    p_reg->INTENSET = mask;
    3768:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    376c:	2202      	movs	r2, #2
    376e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    3772:	e7f8      	b.n	3766 <lfclk_spinwait+0xca>
    3774:	200009ff 	.word	0x200009ff
    3778:	40000104 	.word	0x40000104
    377c:	e000e100 	.word	0xe000e100
    3780:	40000008 	.word	0x40000008

00003784 <z_nrf_clock_control_lf_on>:
{
    3784:	b510      	push	{r4, lr}
    3786:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    3788:	4b10      	ldr	r3, [pc, #64]	; (37cc <z_nrf_clock_control_lf_on+0x48>)
    378a:	2101      	movs	r1, #1
    378c:	f3bf 8f5b 	dmb	ish
    3790:	e853 2f00 	ldrex	r2, [r3]
    3794:	e843 1000 	strex	r0, r1, [r3]
    3798:	2800      	cmp	r0, #0
    379a:	d1f9      	bne.n	3790 <z_nrf_clock_control_lf_on+0xc>
    379c:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
    37a0:	b11a      	cbz	r2, 37aa <z_nrf_clock_control_lf_on+0x26>
	switch (start_mode) {
    37a2:	1e63      	subs	r3, r4, #1
    37a4:	2b01      	cmp	r3, #1
    37a6:	d90c      	bls.n	37c2 <z_nrf_clock_control_lf_on+0x3e>
}
    37a8:	bd10      	pop	{r4, pc}
				get_onoff_manager(CLOCK_DEVICE,
    37aa:	4809      	ldr	r0, [pc, #36]	; (37d0 <z_nrf_clock_control_lf_on+0x4c>)
    37ac:	f004 fb5b 	bl	7e66 <get_onoff_manager>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    37b0:	4908      	ldr	r1, [pc, #32]	; (37d4 <z_nrf_clock_control_lf_on+0x50>)
    37b2:	2300      	movs	r3, #0
    37b4:	604b      	str	r3, [r1, #4]
    37b6:	60cb      	str	r3, [r1, #12]
    37b8:	2301      	movs	r3, #1
    37ba:	608b      	str	r3, [r1, #8]
		err = onoff_request(mgr, &cli);
    37bc:	f003 fdf2 	bl	73a4 <onoff_request>
    37c0:	e7ef      	b.n	37a2 <z_nrf_clock_control_lf_on+0x1e>
		lfclk_spinwait(start_mode);
    37c2:	4620      	mov	r0, r4
    37c4:	f7ff ff6a 	bl	369c <lfclk_spinwait>
		break;
    37c8:	e7ee      	b.n	37a8 <z_nrf_clock_control_lf_on+0x24>
    37ca:	bf00      	nop
    37cc:	200004b8 	.word	0x200004b8
    37d0:	00008cc8 	.word	0x00008cc8
    37d4:	20000454 	.word	0x20000454

000037d8 <rtt_console_init>:

	return character;
}

static int rtt_console_init(const struct device *d)
{
    37d8:	b510      	push	{r4, lr}
	ARG_UNUSED(d);

	__printk_hook_install(rtt_console_out);
    37da:	4c04      	ldr	r4, [pc, #16]	; (37ec <rtt_console_init+0x14>)
    37dc:	4620      	mov	r0, r4
    37de:	f7fd f913 	bl	a08 <__printk_hook_install>
	__stdout_hook_install(rtt_console_out);
    37e2:	4620      	mov	r0, r4
    37e4:	f7ff fe1c 	bl	3420 <__stdout_hook_install>

	return 0;
}
    37e8:	2000      	movs	r0, #0
    37ea:	bd10      	pop	{r4, pc}
    37ec:	000037f1 	.word	0x000037f1

000037f0 <rtt_console_out>:
{
    37f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    37f2:	b083      	sub	sp, #12
    37f4:	4607      	mov	r7, r0
	char c = (char)character;
    37f6:	f88d 0007 	strb.w	r0, [sp, #7]
	int max_cnt = CONFIG_RTT_TX_RETRY_CNT;
    37fa:	2602      	movs	r6, #2
    37fc:	e006      	b.n	380c <rtt_console_out+0x1c>
			host_present = true;
    37fe:	4b13      	ldr	r3, [pc, #76]	; (384c <rtt_console_out+0x5c>)
    3800:	2201      	movs	r2, #1
    3802:	701a      	strb	r2, [r3, #0]
    3804:	e01e      	b.n	3844 <rtt_console_out+0x54>
				wait();
    3806:	f004 fbf4 	bl	7ff2 <wait>
				max_cnt--;
    380a:	3e01      	subs	r6, #1
	return z_impl_k_mutex_lock(mutex, timeout);
    380c:	4d10      	ldr	r5, [pc, #64]	; (3850 <rtt_console_out+0x60>)
    380e:	f04f 32ff 	mov.w	r2, #4294967295
    3812:	f04f 33ff 	mov.w	r3, #4294967295
    3816:	4628      	mov	r0, r5
    3818:	f002 fc12 	bl	6040 <z_impl_k_mutex_lock>
		cnt = SEGGER_RTT_WriteNoLock(0, &c, 1);
    381c:	2201      	movs	r2, #1
    381e:	f10d 0107 	add.w	r1, sp, #7
    3822:	2000      	movs	r0, #0
    3824:	f002 f876 	bl	5914 <SEGGER_RTT_WriteNoLock>
    3828:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    382a:	4628      	mov	r0, r5
    382c:	f002 fc92 	bl	6154 <z_impl_k_mutex_unlock>
		if (cnt) {
    3830:	2c00      	cmp	r4, #0
    3832:	d1e4      	bne.n	37fe <rtt_console_out+0xe>
		} else if (host_present) {
    3834:	4b05      	ldr	r3, [pc, #20]	; (384c <rtt_console_out+0x5c>)
    3836:	781b      	ldrb	r3, [r3, #0]
    3838:	b123      	cbz	r3, 3844 <rtt_console_out+0x54>
			if (max_cnt) {
    383a:	2e00      	cmp	r6, #0
    383c:	d1e3      	bne.n	3806 <rtt_console_out+0x16>
				host_present = false;
    383e:	4b03      	ldr	r3, [pc, #12]	; (384c <rtt_console_out+0x5c>)
    3840:	2200      	movs	r2, #0
    3842:	701a      	strb	r2, [r3, #0]
}
    3844:	4638      	mov	r0, r7
    3846:	b003      	add	sp, #12
    3848:	bdf0      	pop	{r4, r5, r6, r7, pc}
    384a:	bf00      	nop
    384c:	200009fe 	.word	0x200009fe
    3850:	20000100 	.word	0x20000100

00003854 <get_drive>:

static int get_drive(gpio_flags_t flags, nrf_gpio_pin_drive_t *drive)
{
	int err = 0;

	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    3854:	4b1f      	ldr	r3, [pc, #124]	; (38d4 <get_drive+0x80>)
    3856:	4003      	ands	r3, r0
    3858:	4a1f      	ldr	r2, [pc, #124]	; (38d8 <get_drive+0x84>)
    385a:	4293      	cmp	r3, r2
    385c:	d032      	beq.n	38c4 <get_drive+0x70>
    385e:	d816      	bhi.n	388e <get_drive+0x3a>
    3860:	2b06      	cmp	r3, #6
    3862:	d02b      	beq.n	38bc <get_drive+0x68>
    3864:	d906      	bls.n	3874 <get_drive+0x20>
    3866:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    386a:	d10d      	bne.n	3888 <get_drive+0x34>
	case GPIO_DS_DFLT_LOW | GPIO_OPEN_DRAIN:
		*drive = NRF_GPIO_PIN_S0D1;
		break;

	case GPIO_DS_ALT_LOW | GPIO_DS_DFLT_HIGH:
		*drive = NRF_GPIO_PIN_H0S1;
    386c:	2301      	movs	r3, #1
    386e:	700b      	strb	r3, [r1, #0]
	int err = 0;
    3870:	2000      	movs	r0, #0
		break;
    3872:	4770      	bx	lr
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    3874:	b1fb      	cbz	r3, 38b6 <get_drive+0x62>
    3876:	2b02      	cmp	r3, #2
    3878:	d103      	bne.n	3882 <get_drive+0x2e>
	case GPIO_DS_ALT_LOW | GPIO_OPEN_DRAIN:
		*drive = NRF_GPIO_PIN_H0D1;
		break;

	case GPIO_DS_DFLT_HIGH | GPIO_OPEN_SOURCE:
		*drive = NRF_GPIO_PIN_D0S1;
    387a:	2304      	movs	r3, #4
    387c:	700b      	strb	r3, [r1, #0]
	int err = 0;
    387e:	2000      	movs	r0, #0
		break;
    3880:	4770      	bx	lr
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    3882:	f06f 0015 	mvn.w	r0, #21
    3886:	4770      	bx	lr
    3888:	f06f 0015 	mvn.w	r0, #21
    388c:	4770      	bx	lr
    388e:	4a13      	ldr	r2, [pc, #76]	; (38dc <get_drive+0x88>)
    3890:	4293      	cmp	r3, r2
    3892:	d01b      	beq.n	38cc <get_drive+0x78>
    3894:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    3898:	d103      	bne.n	38a2 <get_drive+0x4e>
		*drive = NRF_GPIO_PIN_H0H1;
    389a:	2303      	movs	r3, #3
    389c:	700b      	strb	r3, [r1, #0]
	int err = 0;
    389e:	2000      	movs	r0, #0
		break;
    38a0:	4770      	bx	lr
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    38a2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    38a6:	d103      	bne.n	38b0 <get_drive+0x5c>
		*drive = NRF_GPIO_PIN_S0H1;
    38a8:	2302      	movs	r3, #2
    38aa:	700b      	strb	r3, [r1, #0]
	int err = 0;
    38ac:	2000      	movs	r0, #0
		break;
    38ae:	4770      	bx	lr
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    38b0:	f06f 0015 	mvn.w	r0, #21
    38b4:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0S1;
    38b6:	2000      	movs	r0, #0
    38b8:	7008      	strb	r0, [r1, #0]
		break;
    38ba:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_S0D1;
    38bc:	2306      	movs	r3, #6
    38be:	700b      	strb	r3, [r1, #0]
	int err = 0;
    38c0:	2000      	movs	r0, #0
		break;
    38c2:	4770      	bx	lr
		*drive = NRF_GPIO_PIN_H0D1;
    38c4:	2307      	movs	r3, #7
    38c6:	700b      	strb	r3, [r1, #0]
	int err = 0;
    38c8:	2000      	movs	r0, #0
		break;
    38ca:	4770      	bx	lr
	case GPIO_DS_ALT_HIGH | GPIO_OPEN_SOURCE:
		*drive = NRF_GPIO_PIN_D0H1;
    38cc:	2305      	movs	r3, #5
    38ce:	700b      	strb	r3, [r1, #0]
	int err = 0;
    38d0:	2000      	movs	r0, #0
		err = -EINVAL;
		break;
	}

	return err;
}
    38d2:	4770      	bx	lr
    38d4:	00f00006 	.word	0x00f00006
    38d8:	00100006 	.word	0x00100006
    38dc:	00400002 	.word	0x00400002

000038e0 <get_dev>:
			dev = DEVICE_DT_INST_GET(i); \
		}

	if (0) {
	} /* Followed by else if from FOREACH macro. Done to avoid return statement in macro.  */
	DT_INST_FOREACH_STATUS_OKAY(GPIO_NRF_GET_DEV)
    38e0:	b908      	cbnz	r0, 38e6 <get_dev+0x6>
    38e2:	4802      	ldr	r0, [pc, #8]	; (38ec <get_dev+0xc>)
	#undef GPIO_NRF_GET_DEV

	return dev;
}
    38e4:	4770      	bx	lr
	const struct device *dev = NULL;
    38e6:	2000      	movs	r0, #0
    38e8:	4770      	bx	lr
    38ea:	bf00      	nop
    38ec:	00008ce0 	.word	0x00008ce0

000038f0 <gpio_nrfx_pin_interrupt_configure>:
{
    38f0:	b5f0      	push	{r4, r5, r6, r7, lr}
    38f2:	b085      	sub	sp, #20
    38f4:	460e      	mov	r6, r1
    38f6:	4619      	mov	r1, r3
	return port->config;
    38f8:	6843      	ldr	r3, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    38fa:	7b1b      	ldrb	r3, [r3, #12]
    38fc:	f006 051f 	and.w	r5, r6, #31
    3900:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (mode == GPIO_INT_MODE_DISABLED) {
    3904:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    3908:	d022      	beq.n	3950 <gpio_nrfx_pin_interrupt_configure+0x60>
    390a:	4607      	mov	r7, r0
    390c:	4614      	mov	r4, r2
	nrfx_gpiote_trigger_config_t trigger_config = {
    390e:	2300      	movs	r3, #0
    3910:	9302      	str	r3, [sp, #8]
    3912:	9303      	str	r3, [sp, #12]
		.trigger = get_trigger(mode, trig),
    3914:	4610      	mov	r0, r2
    3916:	f004 fba9 	bl	806c <get_trigger>
	nrfx_gpiote_trigger_config_t trigger_config = {
    391a:	f88d 0008 	strb.w	r0, [sp, #8]
	return port->config;
    391e:	687b      	ldr	r3, [r7, #4]
	if (!(BIT(pin) & get_port_cfg(port)->edge_sense) &&
    3920:	6899      	ldr	r1, [r3, #8]
    3922:	40f1      	lsrs	r1, r6
    3924:	f011 0f01 	tst.w	r1, #1
    3928:	d102      	bne.n	3930 <gpio_nrfx_pin_interrupt_configure+0x40>
    392a:	f5b4 3fa0 	cmp.w	r4, #81920	; 0x14000
    392e:	d014      	beq.n	395a <gpio_nrfx_pin_interrupt_configure+0x6a>
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    3930:	2300      	movs	r3, #0
    3932:	aa02      	add	r2, sp, #8
    3934:	4619      	mov	r1, r3
    3936:	4628      	mov	r0, r5
    3938:	f001 fbb2 	bl	50a0 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    393c:	4b19      	ldr	r3, [pc, #100]	; (39a4 <gpio_nrfx_pin_interrupt_configure+0xb4>)
    393e:	4298      	cmp	r0, r3
    3940:	d12c      	bne.n	399c <gpio_nrfx_pin_interrupt_configure+0xac>
	nrfx_gpiote_trigger_enable(abs_pin, true);
    3942:	2101      	movs	r1, #1
    3944:	4628      	mov	r0, r5
    3946:	f001 fd75 	bl	5434 <nrfx_gpiote_trigger_enable>
	return 0;
    394a:	2000      	movs	r0, #0
}
    394c:	b005      	add	sp, #20
    394e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrfx_gpiote_trigger_disable(abs_pin);
    3950:	4628      	mov	r0, r5
    3952:	f001 fdc7 	bl	54e4 <nrfx_gpiote_trigger_disable>
		return 0;
    3956:	2000      	movs	r0, #0
    3958:	e7f8      	b.n	394c <gpio_nrfx_pin_interrupt_configure+0x5c>
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    395a:	f005 031f 	and.w	r3, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    395e:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    3962:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    3966:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
    396a:	f013 0f01 	tst.w	r3, #1
    396e:	d1df      	bne.n	3930 <gpio_nrfx_pin_interrupt_configure+0x40>
		err = nrfx_gpiote_channel_get(abs_pin, &ch);
    3970:	f10d 0107 	add.w	r1, sp, #7
    3974:	4628      	mov	r0, r5
    3976:	f001 fd01 	bl	537c <nrfx_gpiote_channel_get>
		if (err == NRFX_ERROR_INVALID_PARAM) {
    397a:	4b0b      	ldr	r3, [pc, #44]	; (39a8 <gpio_nrfx_pin_interrupt_configure+0xb8>)
    397c:	4298      	cmp	r0, r3
    397e:	d003      	beq.n	3988 <gpio_nrfx_pin_interrupt_configure+0x98>
		trigger_config.p_in_channel = &ch;
    3980:	f10d 0307 	add.w	r3, sp, #7
    3984:	9303      	str	r3, [sp, #12]
    3986:	e7d3      	b.n	3930 <gpio_nrfx_pin_interrupt_configure+0x40>
			err = nrfx_gpiote_channel_alloc(&ch);
    3988:	f10d 0007 	add.w	r0, sp, #7
    398c:	f001 fd4a 	bl	5424 <nrfx_gpiote_channel_alloc>
			if (err != NRFX_SUCCESS) {
    3990:	4b04      	ldr	r3, [pc, #16]	; (39a4 <gpio_nrfx_pin_interrupt_configure+0xb4>)
    3992:	4298      	cmp	r0, r3
    3994:	d0f4      	beq.n	3980 <gpio_nrfx_pin_interrupt_configure+0x90>
				return -ENOMEM;
    3996:	f06f 000b 	mvn.w	r0, #11
    399a:	e7d7      	b.n	394c <gpio_nrfx_pin_interrupt_configure+0x5c>
		return -EIO;
    399c:	f06f 0004 	mvn.w	r0, #4
    39a0:	e7d4      	b.n	394c <gpio_nrfx_pin_interrupt_configure+0x5c>
    39a2:	bf00      	nop
    39a4:	0bad0000 	.word	0x0bad0000
    39a8:	0bad0004 	.word	0x0bad0004

000039ac <pin_uninit>:
{
    39ac:	b530      	push	{r4, r5, lr}
    39ae:	b083      	sub	sp, #12
    39b0:	4604      	mov	r4, r0
	err = nrfx_gpiote_channel_get(pin, &ch);
    39b2:	f10d 0107 	add.w	r1, sp, #7
    39b6:	f001 fce1 	bl	537c <nrfx_gpiote_channel_get>
    39ba:	4605      	mov	r5, r0
	err = nrfx_gpiote_pin_uninit(pin);
    39bc:	4620      	mov	r0, r4
    39be:	f001 fdbb 	bl	5538 <nrfx_gpiote_pin_uninit>
	if (err != NRFX_SUCCESS) {
    39c2:	4b0b      	ldr	r3, [pc, #44]	; (39f0 <pin_uninit+0x44>)
    39c4:	4298      	cmp	r0, r3
    39c6:	d10f      	bne.n	39e8 <pin_uninit+0x3c>
	if (free_ch) {
    39c8:	429d      	cmp	r5, r3
    39ca:	d005      	beq.n	39d8 <pin_uninit+0x2c>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
    39cc:	4b08      	ldr	r3, [pc, #32]	; (39f0 <pin_uninit+0x44>)
    39ce:	4298      	cmp	r0, r3
    39d0:	d107      	bne.n	39e2 <pin_uninit+0x36>
    39d2:	2000      	movs	r0, #0
}
    39d4:	b003      	add	sp, #12
    39d6:	bd30      	pop	{r4, r5, pc}
		err = nrfx_gpiote_channel_free(ch);
    39d8:	f89d 0007 	ldrb.w	r0, [sp, #7]
    39dc:	f001 fd1a 	bl	5414 <nrfx_gpiote_channel_free>
    39e0:	e7f4      	b.n	39cc <pin_uninit+0x20>
	return (err != NRFX_SUCCESS) ? -EIO : 0;
    39e2:	f06f 0004 	mvn.w	r0, #4
    39e6:	e7f5      	b.n	39d4 <pin_uninit+0x28>
		return -EIO;
    39e8:	f06f 0004 	mvn.w	r0, #4
    39ec:	e7f2      	b.n	39d4 <pin_uninit+0x28>
    39ee:	bf00      	nop
    39f0:	0bad0000 	.word	0x0bad0000

000039f4 <gpio_nrfx_pin_configure>:
{
    39f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    39f8:	b087      	sub	sp, #28
	return port->config;
    39fa:	f8d0 8004 	ldr.w	r8, [r0, #4]
	nrfx_gpiote_pin_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    39fe:	f898 300c 	ldrb.w	r3, [r8, #12]
    3a02:	f001 051f 	and.w	r5, r1, #31
    3a06:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	if (flags == GPIO_DISCONNECTED) {
    3a0a:	2a00      	cmp	r2, #0
    3a0c:	d044      	beq.n	3a98 <gpio_nrfx_pin_configure+0xa4>
    3a0e:	460c      	mov	r4, r1
    3a10:	4617      	mov	r7, r2
	nrfx_gpiote_trigger_config_t trigger_config = {
    3a12:	2600      	movs	r6, #0
    3a14:	9603      	str	r6, [sp, #12]
    3a16:	9604      	str	r6, [sp, #16]
	err = nrfx_gpiote_channel_get(pin, &ch);
    3a18:	f10d 0117 	add.w	r1, sp, #23
    3a1c:	4620      	mov	r0, r4
    3a1e:	f001 fcad 	bl	537c <nrfx_gpiote_channel_get>
    3a22:	4681      	mov	r9, r0
	err = nrfx_gpiote_input_configure(abs_pin, NULL, &trigger_config, NULL);
    3a24:	4633      	mov	r3, r6
    3a26:	aa03      	add	r2, sp, #12
    3a28:	4631      	mov	r1, r6
    3a2a:	4628      	mov	r0, r5
    3a2c:	f001 fb38 	bl	50a0 <nrfx_gpiote_input_configure>
	if (err != NRFX_SUCCESS) {
    3a30:	4b30      	ldr	r3, [pc, #192]	; (3af4 <gpio_nrfx_pin_configure+0x100>)
    3a32:	4298      	cmp	r0, r3
    3a34:	d15b      	bne.n	3aee <gpio_nrfx_pin_configure+0xfa>
	if (free_ch) {
    3a36:	4599      	cmp	r9, r3
    3a38:	d036      	beq.n	3aa8 <gpio_nrfx_pin_configure+0xb4>
	if (flags & GPIO_OUTPUT) {
    3a3a:	f417 7f00 	tst.w	r7, #512	; 0x200
    3a3e:	d043      	beq.n	3ac8 <gpio_nrfx_pin_configure+0xd4>
		int rv = get_drive(flags, &drive);
    3a40:	f10d 0103 	add.w	r1, sp, #3
    3a44:	4638      	mov	r0, r7
    3a46:	f7ff ff05 	bl	3854 <get_drive>
		if (rv != 0) {
    3a4a:	4606      	mov	r6, r0
    3a4c:	bb40      	cbnz	r0, 3aa0 <gpio_nrfx_pin_configure+0xac>
		nrfx_gpiote_output_config_t output_config = {
    3a4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3a52:	f88d 3004 	strb.w	r3, [sp, #4]
				NRF_GPIO_PIN_INPUT_CONNECT :
    3a56:	f417 7f80 	tst.w	r7, #256	; 0x100
    3a5a:	bf0c      	ite	eq
    3a5c:	2301      	moveq	r3, #1
    3a5e:	2300      	movne	r3, #0
		nrfx_gpiote_output_config_t output_config = {
    3a60:	f88d 3005 	strb.w	r3, [sp, #5]
			.pull = get_pull(flags)
    3a64:	4638      	mov	r0, r7
    3a66:	f004 face 	bl	8006 <get_pull>
		nrfx_gpiote_output_config_t output_config = {
    3a6a:	f88d 0006 	strb.w	r0, [sp, #6]
		if (flags & GPIO_OUTPUT_INIT_HIGH) {
    3a6e:	f417 6f00 	tst.w	r7, #2048	; 0x800
    3a72:	d01e      	beq.n	3ab2 <gpio_nrfx_pin_configure+0xbe>
			nrf_gpio_port_out_set(cfg->port, BIT(pin));
    3a74:	f8d8 3004 	ldr.w	r3, [r8, #4]
    3a78:	2101      	movs	r1, #1
    3a7a:	fa01 f404 	lsl.w	r4, r1, r4
    p_reg->OUTSET = set_mask;
    3a7e:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
		err = nrfx_gpiote_output_configure(abs_pin, &output_config, NULL);
    3a82:	2200      	movs	r2, #0
    3a84:	a901      	add	r1, sp, #4
    3a86:	4628      	mov	r0, r5
    3a88:	f001 fbba 	bl	5200 <nrfx_gpiote_output_configure>
		return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    3a8c:	4b19      	ldr	r3, [pc, #100]	; (3af4 <gpio_nrfx_pin_configure+0x100>)
    3a8e:	4298      	cmp	r0, r3
    3a90:	d006      	beq.n	3aa0 <gpio_nrfx_pin_configure+0xac>
    3a92:	f06f 0615 	mvn.w	r6, #21
    3a96:	e003      	b.n	3aa0 <gpio_nrfx_pin_configure+0xac>
		return pin_uninit(abs_pin);
    3a98:	4628      	mov	r0, r5
    3a9a:	f7ff ff87 	bl	39ac <pin_uninit>
    3a9e:	4606      	mov	r6, r0
}
    3aa0:	4630      	mov	r0, r6
    3aa2:	b007      	add	sp, #28
    3aa4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		err = nrfx_gpiote_channel_free(ch);
    3aa8:	f89d 0017 	ldrb.w	r0, [sp, #23]
    3aac:	f001 fcb2 	bl	5414 <nrfx_gpiote_channel_free>
    3ab0:	e7c3      	b.n	3a3a <gpio_nrfx_pin_configure+0x46>
		} else if (flags & GPIO_OUTPUT_INIT_LOW) {
    3ab2:	f417 6f80 	tst.w	r7, #1024	; 0x400
    3ab6:	d0e4      	beq.n	3a82 <gpio_nrfx_pin_configure+0x8e>
			nrf_gpio_port_out_clear(cfg->port, BIT(pin));
    3ab8:	f8d8 2004 	ldr.w	r2, [r8, #4]
    3abc:	2301      	movs	r3, #1
    3abe:	fa03 f404 	lsl.w	r4, r3, r4
    p_reg->OUTCLR = clr_mask;
    3ac2:	f8c2 450c 	str.w	r4, [r2, #1292]	; 0x50c
}
    3ac6:	e7dc      	b.n	3a82 <gpio_nrfx_pin_configure+0x8e>
		.pull = get_pull(flags)
    3ac8:	4638      	mov	r0, r7
    3aca:	f004 fa9c 	bl	8006 <get_pull>
	nrfx_gpiote_input_config_t input_config = {
    3ace:	f88d 0008 	strb.w	r0, [sp, #8]
	err = nrfx_gpiote_input_configure(abs_pin, &input_config, NULL, NULL);
    3ad2:	2300      	movs	r3, #0
    3ad4:	461a      	mov	r2, r3
    3ad6:	a902      	add	r1, sp, #8
    3ad8:	4628      	mov	r0, r5
    3ada:	f001 fae1 	bl	50a0 <nrfx_gpiote_input_configure>
	return (err != NRFX_SUCCESS) ? -EINVAL : 0;
    3ade:	4b05      	ldr	r3, [pc, #20]	; (3af4 <gpio_nrfx_pin_configure+0x100>)
    3ae0:	4298      	cmp	r0, r3
    3ae2:	d101      	bne.n	3ae8 <gpio_nrfx_pin_configure+0xf4>
    3ae4:	2600      	movs	r6, #0
    3ae6:	e7db      	b.n	3aa0 <gpio_nrfx_pin_configure+0xac>
    3ae8:	f06f 0615 	mvn.w	r6, #21
    3aec:	e7d8      	b.n	3aa0 <gpio_nrfx_pin_configure+0xac>
		return -EINVAL;
    3aee:	f06f 0615 	mvn.w	r6, #21
    3af2:	e7d5      	b.n	3aa0 <gpio_nrfx_pin_configure+0xac>
    3af4:	0bad0000 	.word	0x0bad0000

00003af8 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    3af8:	b508      	push	{r3, lr}
	nrfx_err_t err;

	if (nrfx_gpiote_is_init()) {
    3afa:	f001 fc81 	bl	5400 <nrfx_gpiote_is_init>
    3afe:	b108      	cbz	r0, 3b04 <gpio_nrfx_init+0xc>
		return 0;
    3b00:	2000      	movs	r0, #0

	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
		    nrfx_isr, nrfx_gpiote_irq_handler, 0);

	return 0;
}
    3b02:	bd08      	pop	{r3, pc}
	err = nrfx_gpiote_init(0/*not used*/);
    3b04:	f001 fc52 	bl	53ac <nrfx_gpiote_init>
	if (err != NRFX_SUCCESS) {
    3b08:	4b08      	ldr	r3, [pc, #32]	; (3b2c <gpio_nrfx_init+0x34>)
    3b0a:	4298      	cmp	r0, r3
    3b0c:	d10a      	bne.n	3b24 <gpio_nrfx_init+0x2c>
	nrfx_gpiote_global_callback_set(nrfx_gpio_handler, NULL);
    3b0e:	2100      	movs	r1, #0
    3b10:	4807      	ldr	r0, [pc, #28]	; (3b30 <gpio_nrfx_init+0x38>)
    3b12:	f001 fc2d 	bl	5370 <nrfx_gpiote_global_callback_set>
	IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    3b16:	2200      	movs	r2, #0
    3b18:	2105      	movs	r1, #5
    3b1a:	2006      	movs	r0, #6
    3b1c:	f7fe fe1e 	bl	275c <z_arm_irq_priority_set>
	return 0;
    3b20:	2000      	movs	r0, #0
    3b22:	e7ee      	b.n	3b02 <gpio_nrfx_init+0xa>
		return -EIO;
    3b24:	f06f 0004 	mvn.w	r0, #4
    3b28:	e7eb      	b.n	3b02 <gpio_nrfx_init+0xa>
    3b2a:	bf00      	nop
    3b2c:	0bad0000 	.word	0x0bad0000
    3b30:	000080fd 	.word	0x000080fd

00003b34 <configure>:
	}
}

static int configure(const struct device *dev,
		     const struct spi_config *spi_cfg)
{
    3b34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3b38:	b086      	sub	sp, #24
    3b3a:	460c      	mov	r4, r1
	return dev->data;
    3b3c:	6907      	ldr	r7, [r0, #16]
	return dev->config;
    3b3e:	f8d0 8004 	ldr.w	r8, [r0, #4]
	const struct spi_nrfx_config *dev_config = get_dev_config(dev);
	struct spi_context *ctx = &dev_data->ctx;
	nrfx_spi_config_t config;
	nrfx_err_t result;

	if (dev_data->initialized && spi_context_configured(ctx, spi_cfg)) {
    3b42:	f897 c05d 	ldrb.w	ip, [r7, #93]	; 0x5d
    3b46:	f1bc 0f00 	cmp.w	ip, #0
    3b4a:	d003      	beq.n	3b54 <configure+0x20>
	._ctx_name.num_cs_gpios = DT_PROP_LEN_OR(_node_id, cs_gpios, 0),

static inline bool spi_context_configured(struct spi_context *ctx,
					  const struct spi_config *config)
{
	return !!(ctx->config == config);
    3b4c:	683b      	ldr	r3, [r7, #0]
    3b4e:	428b      	cmp	r3, r1
    3b50:	f000 80f9 	beq.w	3d46 <configure+0x212>
		/* Already configured. No need to do it again. */
		return 0;
	}

	if (spi_cfg->operation & SPI_HALF_DUPLEX) {
    3b54:	88a3      	ldrh	r3, [r4, #4]
    3b56:	f413 6f00 	tst.w	r3, #2048	; 0x800
    3b5a:	d15c      	bne.n	3c16 <configure+0xe2>
		LOG_ERR("Half-duplex not supported");
		return -ENOTSUP;
	}

	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    3b5c:	f013 0f01 	tst.w	r3, #1
    3b60:	d16c      	bne.n	3c3c <configure+0x108>
		LOG_ERR("Slave mode is not supported on %s", dev->name);
		return -EINVAL;
	}

	if (spi_cfg->operation & SPI_MODE_LOOP) {
    3b62:	f013 0f08 	tst.w	r3, #8
    3b66:	d17d      	bne.n	3c64 <configure+0x130>
	    (spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
		LOG_ERR("Only single line mode is supported");
		return -EINVAL;
	}

	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    3b68:	f3c3 1345 	ubfx	r3, r3, #5, #6
    3b6c:	2b08      	cmp	r3, #8
    3b6e:	f040 808c 	bne.w	3c8a <configure+0x156>
		LOG_ERR("Word sizes other than 8 bits are not supported");
		return -EINVAL;
	}

	if (spi_cfg->frequency < 125000) {
    3b72:	6822      	ldr	r2, [r4, #0]
    3b74:	4b75      	ldr	r3, [pc, #468]	; (3d4c <configure+0x218>)
    3b76:	429a      	cmp	r2, r3
    3b78:	f240 809a 	bls.w	3cb0 <configure+0x17c>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
		return -EINVAL;
	}

	config = dev_config->def_config;
    3b7c:	ad01      	add	r5, sp, #4
    3b7e:	f108 0608 	add.w	r6, r8, #8
    3b82:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    3b84:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    3b86:	6833      	ldr	r3, [r6, #0]
    3b88:	602b      	str	r3, [r5, #0]

	config.frequency = get_nrf_spi_frequency(spi_cfg->frequency);
    3b8a:	6823      	ldr	r3, [r4, #0]
	if (frequency < 250000) {
    3b8c:	4a70      	ldr	r2, [pc, #448]	; (3d50 <configure+0x21c>)
    3b8e:	4293      	cmp	r3, r2
    3b90:	f240 80a1 	bls.w	3cd6 <configure+0x1a2>
	} else if (frequency < 500000) {
    3b94:	4a6f      	ldr	r2, [pc, #444]	; (3d54 <configure+0x220>)
    3b96:	4293      	cmp	r3, r2
    3b98:	f240 80a0 	bls.w	3cdc <configure+0x1a8>
	} else if (frequency < 1000000) {
    3b9c:	4a6e      	ldr	r2, [pc, #440]	; (3d58 <configure+0x224>)
    3b9e:	4293      	cmp	r3, r2
    3ba0:	f240 809f 	bls.w	3ce2 <configure+0x1ae>
	} else if (frequency < 2000000) {
    3ba4:	4a6d      	ldr	r2, [pc, #436]	; (3d5c <configure+0x228>)
    3ba6:	4293      	cmp	r3, r2
    3ba8:	f240 809e 	bls.w	3ce8 <configure+0x1b4>
	} else if (frequency < 4000000) {
    3bac:	4a6c      	ldr	r2, [pc, #432]	; (3d60 <configure+0x22c>)
    3bae:	4293      	cmp	r3, r2
    3bb0:	f240 809d 	bls.w	3cee <configure+0x1ba>
	} else if (frequency < 8000000) {
    3bb4:	4a6b      	ldr	r2, [pc, #428]	; (3d64 <configure+0x230>)
    3bb6:	4293      	cmp	r3, r2
    3bb8:	f080 809c 	bcs.w	3cf4 <configure+0x1c0>
		return NRF_SPI_FREQ_4M;
    3bbc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	config.frequency = get_nrf_spi_frequency(spi_cfg->frequency);
    3bc0:	9303      	str	r3, [sp, #12]
	config.mode      = get_nrf_spi_mode(spi_cfg->operation);
    3bc2:	88a3      	ldrh	r3, [r4, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    3bc4:	f013 0f02 	tst.w	r3, #2
    3bc8:	f000 8097 	beq.w	3cfa <configure+0x1c6>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
    3bcc:	f013 0f04 	tst.w	r3, #4
    3bd0:	f000 8098 	beq.w	3d04 <configure+0x1d0>
			return NRF_SPI_MODE_3;
    3bd4:	2303      	movs	r3, #3
	config.mode      = get_nrf_spi_mode(spi_cfg->operation);
    3bd6:	f88d 3010 	strb.w	r3, [sp, #16]
	config.bit_order = get_nrf_spi_bit_order(spi_cfg->operation);
    3bda:	88a3      	ldrh	r3, [r4, #4]
	if (operation & SPI_TRANSFER_LSB) {
    3bdc:	f013 0f10 	tst.w	r3, #16
    3be0:	f000 8094 	beq.w	3d0c <configure+0x1d8>
		return NRF_SPI_BIT_ORDER_LSB_FIRST;
    3be4:	2301      	movs	r3, #1
	config.bit_order = get_nrf_spi_bit_order(spi_cfg->operation);
    3be6:	f88d 3011 	strb.w	r3, [sp, #17]

	if (dev_data->initialized) {
    3bea:	f1bc 0f00 	cmp.w	ip, #0
    3bee:	f040 808f 	bne.w	3d10 <configure+0x1dc>
		nrfx_spi_uninit(&dev_config->spi);
		dev_data->initialized = false;
	}

	result = nrfx_spi_init(&dev_config->spi, &config,
    3bf2:	463b      	mov	r3, r7
    3bf4:	4a5c      	ldr	r2, [pc, #368]	; (3d68 <configure+0x234>)
    3bf6:	a901      	add	r1, sp, #4
    3bf8:	4640      	mov	r0, r8
    3bfa:	f001 fce9 	bl	55d0 <nrfx_spi_init>
			       event_handler, dev_data);
	if (result != NRFX_SUCCESS) {
    3bfe:	4b5b      	ldr	r3, [pc, #364]	; (3d6c <configure+0x238>)
    3c00:	4298      	cmp	r0, r3
    3c02:	f040 808c 	bne.w	3d1e <configure+0x1ea>
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
		return -EIO;
	}

	dev_data->initialized = true;
    3c06:	2301      	movs	r3, #1
    3c08:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d

	ctx->config = spi_cfg;
    3c0c:	603c      	str	r4, [r7, #0]

	return 0;
    3c0e:	2000      	movs	r0, #0
}
    3c10:	b006      	add	sp, #24
    3c12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3c16:	4b56      	ldr	r3, [pc, #344]	; (3d70 <configure+0x23c>)
    3c18:	4a56      	ldr	r2, [pc, #344]	; (3d74 <configure+0x240>)
    3c1a:	1a9b      	subs	r3, r3, r2
    3c1c:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Half-duplex not supported");
    3c1e:	f04f 0100 	mov.w	r1, #0
    3c22:	2201      	movs	r2, #1
    3c24:	f362 0102 	bfi	r1, r2, #0, #3
    3c28:	f36f 01c5 	bfc	r1, #3, #3
    3c2c:	f363 118f 	bfi	r1, r3, #6, #10
    3c30:	4851      	ldr	r0, [pc, #324]	; (3d78 <configure+0x244>)
    3c32:	f7fd ffd1 	bl	1bd8 <log_0>
		return -ENOTSUP;
    3c36:	f06f 0085 	mvn.w	r0, #133	; 0x85
    3c3a:	e7e9      	b.n	3c10 <configure+0xdc>
    3c3c:	4b4c      	ldr	r3, [pc, #304]	; (3d70 <configure+0x23c>)
    3c3e:	4a4d      	ldr	r2, [pc, #308]	; (3d74 <configure+0x240>)
    3c40:	1a9b      	subs	r3, r3, r2
    3c42:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Slave mode is not supported on %s", dev->name);
    3c44:	f04f 0200 	mov.w	r2, #0
    3c48:	2101      	movs	r1, #1
    3c4a:	f361 0202 	bfi	r2, r1, #0, #3
    3c4e:	f36f 02c5 	bfc	r2, #3, #3
    3c52:	f363 128f 	bfi	r2, r3, #6, #10
    3c56:	6801      	ldr	r1, [r0, #0]
    3c58:	4848      	ldr	r0, [pc, #288]	; (3d7c <configure+0x248>)
    3c5a:	f7fd ff4b 	bl	1af4 <log_1>
		return -EINVAL;
    3c5e:	f06f 0015 	mvn.w	r0, #21
    3c62:	e7d5      	b.n	3c10 <configure+0xdc>
    3c64:	4b42      	ldr	r3, [pc, #264]	; (3d70 <configure+0x23c>)
    3c66:	4a43      	ldr	r2, [pc, #268]	; (3d74 <configure+0x240>)
    3c68:	1a9b      	subs	r3, r3, r2
    3c6a:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Loopback mode is not supported");
    3c6c:	f04f 0100 	mov.w	r1, #0
    3c70:	2201      	movs	r2, #1
    3c72:	f362 0102 	bfi	r1, r2, #0, #3
    3c76:	f36f 01c5 	bfc	r1, #3, #3
    3c7a:	f363 118f 	bfi	r1, r3, #6, #10
    3c7e:	4840      	ldr	r0, [pc, #256]	; (3d80 <configure+0x24c>)
    3c80:	f7fd ffaa 	bl	1bd8 <log_0>
		return -EINVAL;
    3c84:	f06f 0015 	mvn.w	r0, #21
    3c88:	e7c2      	b.n	3c10 <configure+0xdc>
    3c8a:	4b39      	ldr	r3, [pc, #228]	; (3d70 <configure+0x23c>)
    3c8c:	4a39      	ldr	r2, [pc, #228]	; (3d74 <configure+0x240>)
    3c8e:	1a9b      	subs	r3, r3, r2
    3c90:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Word sizes other than 8 bits are not supported");
    3c92:	f04f 0100 	mov.w	r1, #0
    3c96:	2201      	movs	r2, #1
    3c98:	f362 0102 	bfi	r1, r2, #0, #3
    3c9c:	f36f 01c5 	bfc	r1, #3, #3
    3ca0:	f363 118f 	bfi	r1, r3, #6, #10
    3ca4:	4837      	ldr	r0, [pc, #220]	; (3d84 <configure+0x250>)
    3ca6:	f7fd ff97 	bl	1bd8 <log_0>
		return -EINVAL;
    3caa:	f06f 0015 	mvn.w	r0, #21
    3cae:	e7af      	b.n	3c10 <configure+0xdc>
    3cb0:	4b2f      	ldr	r3, [pc, #188]	; (3d70 <configure+0x23c>)
    3cb2:	4a30      	ldr	r2, [pc, #192]	; (3d74 <configure+0x240>)
    3cb4:	1a9b      	subs	r3, r3, r2
    3cb6:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
    3cb8:	f04f 0100 	mov.w	r1, #0
    3cbc:	2201      	movs	r2, #1
    3cbe:	f362 0102 	bfi	r1, r2, #0, #3
    3cc2:	f36f 01c5 	bfc	r1, #3, #3
    3cc6:	f363 118f 	bfi	r1, r3, #6, #10
    3cca:	482f      	ldr	r0, [pc, #188]	; (3d88 <configure+0x254>)
    3ccc:	f7fd ff84 	bl	1bd8 <log_0>
		return -EINVAL;
    3cd0:	f06f 0015 	mvn.w	r0, #21
    3cd4:	e79c      	b.n	3c10 <configure+0xdc>
		return NRF_SPI_FREQ_125K;
    3cd6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    3cda:	e771      	b.n	3bc0 <configure+0x8c>
		return NRF_SPI_FREQ_250K;
    3cdc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    3ce0:	e76e      	b.n	3bc0 <configure+0x8c>
		return NRF_SPI_FREQ_500K;
    3ce2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    3ce6:	e76b      	b.n	3bc0 <configure+0x8c>
		return NRF_SPI_FREQ_1M;
    3ce8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    3cec:	e768      	b.n	3bc0 <configure+0x8c>
		return NRF_SPI_FREQ_2M;
    3cee:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    3cf2:	e765      	b.n	3bc0 <configure+0x8c>
		return NRF_SPI_FREQ_8M;
    3cf4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    3cf8:	e762      	b.n	3bc0 <configure+0x8c>
		if (SPI_MODE_GET(operation) & SPI_MODE_CPHA) {
    3cfa:	f013 0f04 	tst.w	r3, #4
    3cfe:	d003      	beq.n	3d08 <configure+0x1d4>
			return NRF_SPI_MODE_1;
    3d00:	2301      	movs	r3, #1
    3d02:	e768      	b.n	3bd6 <configure+0xa2>
			return NRF_SPI_MODE_2;
    3d04:	2302      	movs	r3, #2
    3d06:	e766      	b.n	3bd6 <configure+0xa2>
			return NRF_SPI_MODE_0;
    3d08:	2300      	movs	r3, #0
    3d0a:	e764      	b.n	3bd6 <configure+0xa2>
		return NRF_SPI_BIT_ORDER_MSB_FIRST;
    3d0c:	2300      	movs	r3, #0
    3d0e:	e76a      	b.n	3be6 <configure+0xb2>
		nrfx_spi_uninit(&dev_config->spi);
    3d10:	4640      	mov	r0, r8
    3d12:	f001 fcb7 	bl	5684 <nrfx_spi_uninit>
		dev_data->initialized = false;
    3d16:	2300      	movs	r3, #0
    3d18:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    3d1c:	e769      	b.n	3bf2 <configure+0xbe>
    3d1e:	4b14      	ldr	r3, [pc, #80]	; (3d70 <configure+0x23c>)
    3d20:	4a14      	ldr	r2, [pc, #80]	; (3d74 <configure+0x240>)
    3d22:	1a9b      	subs	r3, r3, r2
    3d24:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Failed to initialize nrfx driver: %08x", result);
    3d26:	f04f 0200 	mov.w	r2, #0
    3d2a:	2101      	movs	r1, #1
    3d2c:	f361 0202 	bfi	r2, r1, #0, #3
    3d30:	f36f 02c5 	bfc	r2, #3, #3
    3d34:	f363 128f 	bfi	r2, r3, #6, #10
    3d38:	4601      	mov	r1, r0
    3d3a:	4814      	ldr	r0, [pc, #80]	; (3d8c <configure+0x258>)
    3d3c:	f7fd feda 	bl	1af4 <log_1>
		return -EIO;
    3d40:	f06f 0004 	mvn.w	r0, #4
    3d44:	e764      	b.n	3c10 <configure+0xdc>
		return 0;
    3d46:	2000      	movs	r0, #0
    3d48:	e762      	b.n	3c10 <configure+0xdc>
    3d4a:	bf00      	nop
    3d4c:	0001e847 	.word	0x0001e847
    3d50:	0003d08f 	.word	0x0003d08f
    3d54:	0007a11f 	.word	0x0007a11f
    3d58:	000f423f 	.word	0x000f423f
    3d5c:	001e847f 	.word	0x001e847f
    3d60:	003d08ff 	.word	0x003d08ff
    3d64:	007a1200 	.word	0x007a1200
    3d68:	00004139 	.word	0x00004139
    3d6c:	0bad0000 	.word	0x0bad0000
    3d70:	00008e88 	.word	0x00008e88
    3d74:	00008e48 	.word	0x00008e48
    3d78:	0000969c 	.word	0x0000969c
    3d7c:	000096b8 	.word	0x000096b8
    3d80:	000096dc 	.word	0x000096dc
    3d84:	000096fc 	.word	0x000096fc
    3d88:	0000972c 	.word	0x0000972c
    3d8c:	00009760 	.word	0x00009760

00003d90 <spi_0_init>:
		      &spi_##idx##z_config,				       \
		      POST_KERNEL, CONFIG_SPI_INIT_PRIORITY,		       \
		      &spi_nrfx_driver_api)

#ifdef CONFIG_SPI_0_NRF_SPI
SPI_NRFX_SPI_DEVICE(0);
    3d90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3d92:	4606      	mov	r6, r0
    3d94:	2200      	movs	r2, #0
    3d96:	2101      	movs	r1, #1
    3d98:	2003      	movs	r0, #3
    3d9a:	f7fe fcdf 	bl	275c <z_arm_irq_priority_set>
	return dev->data;
    3d9e:	6937      	ldr	r7, [r6, #16]
static inline int spi_context_cs_configure_all(struct spi_context *ctx)
{
	int ret;
	const struct gpio_dt_spec *cs_gpio;

	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
    3da0:	68bc      	ldr	r4, [r7, #8]
    3da2:	e011      	b.n	3dc8 <spi_0_init+0x38>
	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
    3da4:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
	if ((flags & GPIO_ACTIVE_LOW) != 0) {
    3da8:	f013 0f01 	tst.w	r3, #1
    3dac:	d027      	beq.n	3dfe <spi_0_init+0x6e>
		data->invert |= (gpio_port_pins_t)BIT(pin);
    3dae:	2301      	movs	r3, #1
    3db0:	fa03 fc01 	lsl.w	ip, r3, r1
    3db4:	682b      	ldr	r3, [r5, #0]
    3db6:	ea43 030c 	orr.w	r3, r3, ip
    3dba:	602b      	str	r3, [r5, #0]
	return api->pin_configure(port, pin, flags);
    3dbc:	f8de 3000 	ldr.w	r3, [lr]
    3dc0:	4798      	blx	r3
				cs_gpio->port->name, cs_gpio->pin);
			return -ENODEV;
		}

		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
		if (ret < 0) {
    3dc2:	2800      	cmp	r0, #0
    3dc4:	db3a      	blt.n	3e3c <spi_0_init+0xac>
	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
    3dc6:	3408      	adds	r4, #8
    3dc8:	68bb      	ldr	r3, [r7, #8]
    3dca:	68fa      	ldr	r2, [r7, #12]
    3dcc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    3dd0:	429c      	cmp	r4, r3
    3dd2:	d232      	bcs.n	3e3a <spi_0_init+0xaa>
		if (!device_is_ready(cs_gpio->port)) {
    3dd4:	6820      	ldr	r0, [r4, #0]
 *
 * @return a non-positive integer as documented in device_usable_check().
 */
static inline int z_device_usable_check(const struct device *dev)
{
	return z_device_ready(dev) ? 0 : -ENODEV;
    3dd6:	f004 fc9e 	bl	8716 <z_device_ready>
    3dda:	b1c0      	cbz	r0, 3e0e <spi_0_init+0x7e>
 * @return a value from gpio_pin_configure()
 */
static inline int gpio_pin_configure_dt(const struct gpio_dt_spec *spec,
					gpio_flags_t extra_flags)
{
	return gpio_pin_configure(spec->port,
    3ddc:	6820      	ldr	r0, [r4, #0]
    3dde:	7921      	ldrb	r1, [r4, #4]
				  spec->pin,
				  spec->dt_flags | extra_flags);
    3de0:	7963      	ldrb	r3, [r4, #5]
	return gpio_pin_configure(spec->port,
    3de2:	f443 53b0 	orr.w	r3, r3, #5632	; 0x1600
	const struct gpio_driver_api *api =
    3de6:	f8d0 e008 	ldr.w	lr, [r0, #8]
	struct gpio_driver_data *data =
    3dea:	6905      	ldr	r5, [r0, #16]
	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
    3dec:	f413 6f40 	tst.w	r3, #3072	; 0xc00
    3df0:	d0d8      	beq.n	3da4 <spi_0_init+0x14>
	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
    3df2:	f013 0f01 	tst.w	r3, #1
    3df6:	d0d5      	beq.n	3da4 <spi_0_init+0x14>
		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
    3df8:	f483 6340 	eor.w	r3, r3, #3072	; 0xc00
    3dfc:	e7d2      	b.n	3da4 <spi_0_init+0x14>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    3dfe:	2301      	movs	r3, #1
    3e00:	fa03 fc01 	lsl.w	ip, r3, r1
    3e04:	682b      	ldr	r3, [r5, #0]
    3e06:	ea23 030c 	bic.w	r3, r3, ip
    3e0a:	602b      	str	r3, [r5, #0]
    3e0c:	e7d6      	b.n	3dbc <spi_0_init+0x2c>
    3e0e:	4a24      	ldr	r2, [pc, #144]	; (3ea0 <spi_0_init+0x110>)
    3e10:	4b24      	ldr	r3, [pc, #144]	; (3ea4 <spi_0_init+0x114>)
    3e12:	1ad2      	subs	r2, r2, r3
    3e14:	08d2      	lsrs	r2, r2, #3
			LOG_ERR("CS GPIO port %s pin %d is not ready",
    3e16:	f04f 0300 	mov.w	r3, #0
    3e1a:	2101      	movs	r1, #1
    3e1c:	f361 0302 	bfi	r3, r1, #0, #3
    3e20:	f36f 03c5 	bfc	r3, #3, #3
    3e24:	f362 138f 	bfi	r3, r2, #6, #10
    3e28:	6821      	ldr	r1, [r4, #0]
    3e2a:	7922      	ldrb	r2, [r4, #4]
    3e2c:	6809      	ldr	r1, [r1, #0]
    3e2e:	481e      	ldr	r0, [pc, #120]	; (3ea8 <spi_0_init+0x118>)
    3e30:	f7fd fe96 	bl	1b60 <log_2>
			return -ENODEV;
    3e34:	f06f 0012 	mvn.w	r0, #18
    3e38:	e000      	b.n	3e3c <spi_0_init+0xac>
			return ret;
		}
	}

	return 0;
    3e3a:	2000      	movs	r0, #0
SPI_NRFX_SPI_DEVICE(0);
    3e3c:	2800      	cmp	r0, #0
    3e3e:	db1e      	blt.n	3e7e <spi_0_init+0xee>
	return dev->data;
    3e40:	6934      	ldr	r4, [r6, #16]
}

static inline void _spi_context_cs_control(struct spi_context *ctx,
					   bool on, bool force_off)
{
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
    3e42:	6823      	ldr	r3, [r4, #0]
    3e44:	b1c3      	cbz	r3, 3e78 <spi_0_init+0xe8>
    3e46:	689b      	ldr	r3, [r3, #8]
    3e48:	b1b3      	cbz	r3, 3e78 <spi_0_init+0xe8>
    3e4a:	681a      	ldr	r2, [r3, #0]
    3e4c:	b1a2      	cbz	r2, 3e78 <spi_0_init+0xe8>
			if (!force_off &&
			    ctx->config->operation & SPI_HOLD_ON_CS) {
				return;
			}

			k_busy_wait(ctx->config->cs->delay);
    3e4e:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
    3e50:	f004 fee2 	bl	8c18 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
    3e54:	6823      	ldr	r3, [r4, #0]
    3e56:	689b      	ldr	r3, [r3, #8]
 * @param value Value assigned to the pin.
 * @return a value from gpio_pin_set()
 */
static inline int gpio_pin_set_dt(const struct gpio_dt_spec *spec, int value)
{
	return gpio_pin_set(spec->port, spec->pin, value);
    3e58:	6818      	ldr	r0, [r3, #0]
    3e5a:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
    3e5c:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    3e5e:	681a      	ldr	r2, [r3, #0]
    3e60:	2301      	movs	r3, #1
    3e62:	408b      	lsls	r3, r1
    3e64:	421a      	tst	r2, r3
    3e66:	d10b      	bne.n	3e80 <spi_0_init+0xf0>
    3e68:	2300      	movs	r3, #0
	if (value != 0)	{
    3e6a:	b15b      	cbz	r3, 3e84 <spi_0_init+0xf4>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    3e6c:	2301      	movs	r3, #1
    3e6e:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    3e72:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    3e74:	68db      	ldr	r3, [r3, #12]
    3e76:	4798      	blx	r3
	return sem->count;
    3e78:	69a3      	ldr	r3, [r4, #24]
static inline void spi_context_unlock_unconditionally(struct spi_context *ctx)
{
	/* Forcing CS to go to inactive status */
	_spi_context_cs_control(ctx, false, true);

	if (!k_sem_count_get(&ctx->lock)) {
    3e7a:	b153      	cbz	r3, 3e92 <spi_0_init+0x102>
SPI_NRFX_SPI_DEVICE(0);
    3e7c:	2000      	movs	r0, #0
    3e7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		value = (value != 0) ? 0 : 1;
    3e80:	2301      	movs	r3, #1
    3e82:	e7f2      	b.n	3e6a <spi_0_init+0xda>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    3e84:	2301      	movs	r3, #1
    3e86:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    3e8a:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    3e8c:	691b      	ldr	r3, [r3, #16]
    3e8e:	4798      	blx	r3
	return gpio_pin_set(spec->port, spec->pin, value);
    3e90:	e7f2      	b.n	3e78 <spi_0_init+0xe8>
		ctx->owner = NULL;
    3e92:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
    3e94:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
    3e98:	f002 f9a0 	bl	61dc <z_impl_k_sem_give>
}
    3e9c:	e7ee      	b.n	3e7c <spi_0_init+0xec>
    3e9e:	bf00      	nop
    3ea0:	00008e88 	.word	0x00008e88
    3ea4:	00008e48 	.word	0x00008e48
    3ea8:	00009788 	.word	0x00009788

00003eac <transfer_next_chunk>:
{
    3eac:	b530      	push	{r4, r5, lr}
    3eae:	b085      	sub	sp, #20
	return dev->data;
    3eb0:	6904      	ldr	r4, [r0, #16]
 * directions have a continuous buffer, i.e. the maximum SPI transfer that
 * can be done with DMA that handles only non-scattered buffers.
 */
static inline size_t spi_context_max_continuous_chunk(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
    3eb2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    3eb4:	2a00      	cmp	r2, #0
    3eb6:	d04f      	beq.n	3f58 <transfer_next_chunk+0xac>
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
    3eb8:	6d23      	ldr	r3, [r4, #80]	; 0x50
    3eba:	2b00      	cmp	r3, #0
    3ebc:	d04e      	beq.n	3f5c <transfer_next_chunk+0xb0>
		return ctx->tx_len;
	}

	return MIN(ctx->tx_len, ctx->rx_len);
    3ebe:	4293      	cmp	r3, r2
    3ec0:	bf28      	it	cs
    3ec2:	4613      	movcs	r3, r2
	if (chunk_len > 0) {
    3ec4:	2b00      	cmp	r3, #0
    3ec6:	d055      	beq.n	3f74 <transfer_next_chunk+0xc8>
		dev_data->chunk_len = chunk_len;
    3ec8:	65a3      	str	r3, [r4, #88]	; 0x58
		xfer.p_tx_buffer = ctx->tx_buf;
    3eca:	6c61      	ldr	r1, [r4, #68]	; 0x44
    3ecc:	9100      	str	r1, [sp, #0]
	return !!(ctx->tx_buf && ctx->tx_len);
    3ece:	2900      	cmp	r1, #0
    3ed0:	d046      	beq.n	3f60 <transfer_next_chunk+0xb4>
    3ed2:	2a00      	cmp	r2, #0
    3ed4:	d146      	bne.n	3f64 <transfer_next_chunk+0xb8>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    3ed6:	2a00      	cmp	r2, #0
    3ed8:	d046      	beq.n	3f68 <transfer_next_chunk+0xbc>
    3eda:	461a      	mov	r2, r3
    3edc:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    3ede:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
    3ee0:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    3ee2:	2a00      	cmp	r2, #0
    3ee4:	d042      	beq.n	3f6c <transfer_next_chunk+0xc0>
    3ee6:	6d22      	ldr	r2, [r4, #80]	; 0x50
    3ee8:	2a00      	cmp	r2, #0
    3eea:	d141      	bne.n	3f70 <transfer_next_chunk+0xc4>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    3eec:	b902      	cbnz	r2, 3ef0 <transfer_next_chunk+0x44>
    3eee:	2300      	movs	r3, #0
    3ef0:	9303      	str	r3, [sp, #12]
		result = nrfx_spi_xfer(&get_dev_config(dev)->spi, &xfer, 0);
    3ef2:	2200      	movs	r2, #0
    3ef4:	4669      	mov	r1, sp
    3ef6:	6840      	ldr	r0, [r0, #4]
    3ef8:	f001 fc1e 	bl	5738 <nrfx_spi_xfer>
		if (result == NRFX_SUCCESS) {
    3efc:	4b23      	ldr	r3, [pc, #140]	; (3f8c <transfer_next_chunk+0xe0>)
    3efe:	4298      	cmp	r0, r3
    3f00:	d028      	beq.n	3f54 <transfer_next_chunk+0xa8>
		error = -EIO;
    3f02:	f06f 0504 	mvn.w	r5, #4
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
    3f06:	6823      	ldr	r3, [r4, #0]
    3f08:	b1e3      	cbz	r3, 3f44 <transfer_next_chunk+0x98>
    3f0a:	689a      	ldr	r2, [r3, #8]
    3f0c:	b1d2      	cbz	r2, 3f44 <transfer_next_chunk+0x98>
    3f0e:	6811      	ldr	r1, [r2, #0]
    3f10:	b1c1      	cbz	r1, 3f44 <transfer_next_chunk+0x98>
			    ctx->config->operation & SPI_HOLD_ON_CS) {
    3f12:	889b      	ldrh	r3, [r3, #4]
			if (!force_off &&
    3f14:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    3f18:	d114      	bne.n	3f44 <transfer_next_chunk+0x98>
			k_busy_wait(ctx->config->cs->delay);
    3f1a:	6890      	ldr	r0, [r2, #8]
	z_impl_k_busy_wait(usec_to_wait);
    3f1c:	f004 fe7c 	bl	8c18 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
    3f20:	6823      	ldr	r3, [r4, #0]
    3f22:	689b      	ldr	r3, [r3, #8]
    3f24:	6818      	ldr	r0, [r3, #0]
    3f26:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
    3f28:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    3f2a:	681a      	ldr	r2, [r3, #0]
    3f2c:	2301      	movs	r3, #1
    3f2e:	408b      	lsls	r3, r1
    3f30:	421a      	tst	r2, r3
    3f32:	d121      	bne.n	3f78 <transfer_next_chunk+0xcc>
    3f34:	2300      	movs	r3, #0
	if (value != 0)	{
    3f36:	b30b      	cbz	r3, 3f7c <transfer_next_chunk+0xd0>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    3f38:	2301      	movs	r3, #1
    3f3a:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    3f3e:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    3f40:	68db      	ldr	r3, [r3, #12]
    3f42:	4798      	blx	r3
	ctx->sync_status = status;
    3f44:	6325      	str	r5, [r4, #48]	; 0x30
	k_sem_give(&ctx->sync);
    3f46:	f104 0020 	add.w	r0, r4, #32
	z_impl_k_sem_give(sem);
    3f4a:	f002 f947 	bl	61dc <z_impl_k_sem_give>
	dev_data->busy = false;
    3f4e:	2300      	movs	r3, #0
    3f50:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
}
    3f54:	b005      	add	sp, #20
    3f56:	bd30      	pop	{r4, r5, pc}
		return ctx->rx_len;
    3f58:	6d23      	ldr	r3, [r4, #80]	; 0x50
    3f5a:	e7b3      	b.n	3ec4 <transfer_next_chunk+0x18>
		return ctx->tx_len;
    3f5c:	4613      	mov	r3, r2
    3f5e:	e7b1      	b.n	3ec4 <transfer_next_chunk+0x18>
	return !!(ctx->tx_buf && ctx->tx_len);
    3f60:	2200      	movs	r2, #0
    3f62:	e7b8      	b.n	3ed6 <transfer_next_chunk+0x2a>
    3f64:	2201      	movs	r2, #1
    3f66:	e7b6      	b.n	3ed6 <transfer_next_chunk+0x2a>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    3f68:	2200      	movs	r2, #0
    3f6a:	e7b7      	b.n	3edc <transfer_next_chunk+0x30>
	return !!(ctx->rx_buf && ctx->rx_len);
    3f6c:	2200      	movs	r2, #0
    3f6e:	e7bd      	b.n	3eec <transfer_next_chunk+0x40>
    3f70:	2201      	movs	r2, #1
    3f72:	e7bb      	b.n	3eec <transfer_next_chunk+0x40>
	int error = 0;
    3f74:	2500      	movs	r5, #0
    3f76:	e7c6      	b.n	3f06 <transfer_next_chunk+0x5a>
		value = (value != 0) ? 0 : 1;
    3f78:	2301      	movs	r3, #1
    3f7a:	e7dc      	b.n	3f36 <transfer_next_chunk+0x8a>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    3f7c:	2301      	movs	r3, #1
    3f7e:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    3f82:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    3f84:	691b      	ldr	r3, [r3, #16]
    3f86:	4798      	blx	r3
	return gpio_pin_set(spec->port, spec->pin, value);
    3f88:	e7dc      	b.n	3f44 <transfer_next_chunk+0x98>
    3f8a:	bf00      	nop
    3f8c:	0bad0000 	.word	0x0bad0000

00003f90 <transceive>:
{
    3f90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    3f94:	4607      	mov	r7, r0
    3f96:	460e      	mov	r6, r1
    3f98:	4691      	mov	r9, r2
    3f9a:	4698      	mov	r8, r3
	return dev->data;
    3f9c:	6904      	ldr	r4, [r0, #16]
	spi_context_lock(&dev_data->ctx, asynchronous, signal, spi_cfg);
    3f9e:	4625      	mov	r5, r4
	if ((spi_cfg->operation & SPI_LOCK_ON) &&
    3fa0:	888b      	ldrh	r3, [r1, #4]
    3fa2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    3fa6:	d004      	beq.n	3fb2 <transceive+0x22>
    3fa8:	69a3      	ldr	r3, [r4, #24]
    3faa:	b913      	cbnz	r3, 3fb2 <transceive+0x22>
		(ctx->owner == spi_cfg)) {
    3fac:	6863      	ldr	r3, [r4, #4]
		(k_sem_count_get(&ctx->lock) == 0) &&
    3fae:	4299      	cmp	r1, r3
    3fb0:	d008      	beq.n	3fc4 <transceive+0x34>
	k_sem_take(&ctx->lock, K_FOREVER);
    3fb2:	f104 0010 	add.w	r0, r4, #16
	return z_impl_k_sem_take(sem, timeout);
    3fb6:	f04f 32ff 	mov.w	r2, #4294967295
    3fba:	f04f 33ff 	mov.w	r3, #4294967295
    3fbe:	f002 f931 	bl	6224 <z_impl_k_sem_take>
	ctx->owner = spi_cfg;
    3fc2:	6066      	str	r6, [r4, #4]
	error = configure(dev, spi_cfg);
    3fc4:	4631      	mov	r1, r6
    3fc6:	4638      	mov	r0, r7
    3fc8:	f7ff fdb4 	bl	3b34 <configure>
	if (error == 0) {
    3fcc:	4606      	mov	r6, r0
    3fce:	b140      	cbz	r0, 3fe2 <transceive+0x52>
	if (!(ctx->config->operation & SPI_LOCK_ON)) {
    3fd0:	6823      	ldr	r3, [r4, #0]
    3fd2:	889b      	ldrh	r3, [r3, #4]
    3fd4:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    3fd8:	f000 80a1 	beq.w	411e <transceive+0x18e>
}
    3fdc:	4630      	mov	r0, r6
    3fde:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		dev_data->busy = true;
    3fe2:	2301      	movs	r3, #1
    3fe4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
    3fe8:	f1b9 0f00 	cmp.w	r9, #0
    3fec:	d010      	beq.n	4010 <transceive+0x80>
    3fee:	f8d9 3000 	ldr.w	r3, [r9]
    3ff2:	6363      	str	r3, [r4, #52]	; 0x34
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
    3ff4:	b173      	cbz	r3, 4014 <transceive+0x84>
    3ff6:	f8d9 3004 	ldr.w	r3, [r9, #4]
    3ffa:	63a3      	str	r3, [r4, #56]	; 0x38
	while (*count) {
    3ffc:	6bab      	ldr	r3, [r5, #56]	; 0x38
    3ffe:	b173      	cbz	r3, 401e <transceive+0x8e>
		if (((*current)->len / dfs) != 0) {
    4000:	6b6a      	ldr	r2, [r5, #52]	; 0x34
    4002:	6851      	ldr	r1, [r2, #4]
    4004:	b941      	cbnz	r1, 4018 <transceive+0x88>
		++(*current);
    4006:	3208      	adds	r2, #8
    4008:	636a      	str	r2, [r5, #52]	; 0x34
		--(*count);
    400a:	3b01      	subs	r3, #1
    400c:	63ab      	str	r3, [r5, #56]	; 0x38
    400e:	e7f5      	b.n	3ffc <transceive+0x6c>
	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
    4010:	464b      	mov	r3, r9
    4012:	e7ee      	b.n	3ff2 <transceive+0x62>
	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
    4014:	2300      	movs	r3, #0
    4016:	e7f0      	b.n	3ffa <transceive+0x6a>
			*buf_len = (*current)->len / dfs;
    4018:	64a1      	str	r1, [r4, #72]	; 0x48
			return (*current)->buf;
    401a:	6813      	ldr	r3, [r2, #0]
    401c:	e000      	b.n	4020 <transceive+0x90>
	*buf_len = 0;
    401e:	64a3      	str	r3, [r4, #72]	; 0x48
	ctx->tx_buf = (const uint8_t *)
    4020:	6463      	str	r3, [r4, #68]	; 0x44
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
    4022:	f1b8 0f00 	cmp.w	r8, #0
    4026:	d010      	beq.n	404a <transceive+0xba>
    4028:	f8d8 3000 	ldr.w	r3, [r8]
    402c:	63e3      	str	r3, [r4, #60]	; 0x3c
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
    402e:	b173      	cbz	r3, 404e <transceive+0xbe>
    4030:	f8d8 3004 	ldr.w	r3, [r8, #4]
    4034:	6423      	str	r3, [r4, #64]	; 0x40
	while (*count) {
    4036:	6c2a      	ldr	r2, [r5, #64]	; 0x40
    4038:	b172      	cbz	r2, 4058 <transceive+0xc8>
		if (((*current)->len / dfs) != 0) {
    403a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    403c:	6859      	ldr	r1, [r3, #4]
    403e:	b941      	cbnz	r1, 4052 <transceive+0xc2>
		++(*current);
    4040:	3308      	adds	r3, #8
    4042:	63eb      	str	r3, [r5, #60]	; 0x3c
		--(*count);
    4044:	3a01      	subs	r2, #1
    4046:	642a      	str	r2, [r5, #64]	; 0x40
    4048:	e7f5      	b.n	4036 <transceive+0xa6>
	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
    404a:	4643      	mov	r3, r8
    404c:	e7ee      	b.n	402c <transceive+0x9c>
	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
    404e:	2300      	movs	r3, #0
    4050:	e7f0      	b.n	4034 <transceive+0xa4>
			*buf_len = (*current)->len / dfs;
    4052:	6521      	str	r1, [r4, #80]	; 0x50
			return (*current)->buf;
    4054:	681b      	ldr	r3, [r3, #0]
    4056:	e001      	b.n	405c <transceive+0xcc>
	*buf_len = 0;
    4058:	2300      	movs	r3, #0
    405a:	6523      	str	r3, [r4, #80]	; 0x50
	ctx->rx_buf = (uint8_t *)
    405c:	64e3      	str	r3, [r4, #76]	; 0x4c
	ctx->sync_status = 0;
    405e:	2300      	movs	r3, #0
    4060:	6323      	str	r3, [r4, #48]	; 0x30
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
    4062:	6823      	ldr	r3, [r4, #0]
    4064:	b1c3      	cbz	r3, 4098 <transceive+0x108>
    4066:	689b      	ldr	r3, [r3, #8]
    4068:	b1b3      	cbz	r3, 4098 <transceive+0x108>
    406a:	681a      	ldr	r2, [r3, #0]
    406c:	b1a2      	cbz	r2, 4098 <transceive+0x108>
    406e:	4610      	mov	r0, r2
    4070:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
    4072:	6913      	ldr	r3, [r2, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    4074:	681a      	ldr	r2, [r3, #0]
    4076:	2301      	movs	r3, #1
    4078:	408b      	lsls	r3, r1
    407a:	421a      	tst	r2, r3
    407c:	d100      	bne.n	4080 <transceive+0xf0>
    407e:	2601      	movs	r6, #1
	if (value != 0)	{
    4080:	b39e      	cbz	r6, 40ea <transceive+0x15a>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    4082:	2301      	movs	r3, #1
    4084:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    4088:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    408a:	68db      	ldr	r3, [r3, #12]
    408c:	4798      	blx	r3
			k_busy_wait(ctx->config->cs->delay);
    408e:	6823      	ldr	r3, [r4, #0]
    4090:	689b      	ldr	r3, [r3, #8]
    4092:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
    4094:	f004 fdc0 	bl	8c18 <z_impl_k_busy_wait>
		transfer_next_chunk(dev);
    4098:	4638      	mov	r0, r7
    409a:	f7ff ff07 	bl	3eac <transfer_next_chunk>
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
    409e:	6d23      	ldr	r3, [r4, #80]	; 0x50
    40a0:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    40a2:	429a      	cmp	r2, r3
    40a4:	bf38      	it	cc
    40a6:	461a      	movcc	r2, r3
    40a8:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
    40ac:	fb03 f302 	mul.w	r3, r3, r2
			     ctx->config->frequency;
    40b0:	4625      	mov	r5, r4
    40b2:	f855 2b20 	ldr.w	r2, [r5], #32
    40b6:	6812      	ldr	r2, [r2, #0]
		timeout_ms = MAX(ctx->tx_len, ctx->rx_len) * 8 * 1000 /
    40b8:	fbb3 f3f2 	udiv	r3, r3, r2
		timeout_ms += CONFIG_SPI_COMPLETION_TIMEOUT_TOLERANCE;
    40bc:	33c8      	adds	r3, #200	; 0xc8
		} else {
			return (t * to_hz + off) / from_hz;
    40be:	0c59      	lsrs	r1, r3, #17
    40c0:	03d8      	lsls	r0, r3, #15
    40c2:	f240 36e7 	movw	r6, #999	; 0x3e7
    40c6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    40ca:	2300      	movs	r3, #0
    40cc:	1980      	adds	r0, r0, r6
    40ce:	f04f 0600 	mov.w	r6, #0
    40d2:	eb46 0101 	adc.w	r1, r6, r1
    40d6:	f7fc f9c3 	bl	460 <__aeabi_uldivmod>
    40da:	4602      	mov	r2, r0
    40dc:	460b      	mov	r3, r1
	return z_impl_k_sem_take(sem, timeout);
    40de:	4628      	mov	r0, r5
    40e0:	f002 f8a0 	bl	6224 <z_impl_k_sem_take>
	if (k_sem_take(&ctx->sync, timeout)) {
    40e4:	b940      	cbnz	r0, 40f8 <transceive+0x168>
	status = ctx->sync_status;
    40e6:	6b26      	ldr	r6, [r4, #48]	; 0x30
	return status;
    40e8:	e772      	b.n	3fd0 <transceive+0x40>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    40ea:	2301      	movs	r3, #1
    40ec:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    40f0:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    40f2:	691b      	ldr	r3, [r3, #16]
    40f4:	4798      	blx	r3
    40f6:	e7ca      	b.n	408e <transceive+0xfe>
    40f8:	4b0c      	ldr	r3, [pc, #48]	; (412c <transceive+0x19c>)
    40fa:	4a0d      	ldr	r2, [pc, #52]	; (4130 <transceive+0x1a0>)
    40fc:	1a9b      	subs	r3, r3, r2
    40fe:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Timeout waiting for transfer complete");
    4100:	f04f 0100 	mov.w	r1, #0
    4104:	2201      	movs	r2, #1
    4106:	f362 0102 	bfi	r1, r2, #0, #3
    410a:	f36f 01c5 	bfc	r1, #3, #3
    410e:	f363 118f 	bfi	r1, r3, #6, #10
    4112:	4808      	ldr	r0, [pc, #32]	; (4134 <transceive+0x1a4>)
    4114:	f7fd fd60 	bl	1bd8 <log_0>
		return -ETIMEDOUT;
    4118:	f06f 0673 	mvn.w	r6, #115	; 0x73
    411c:	e758      	b.n	3fd0 <transceive+0x40>
		ctx->owner = NULL;
    411e:	2300      	movs	r3, #0
    4120:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
    4122:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
    4126:	f002 f859 	bl	61dc <z_impl_k_sem_give>
	return error;
    412a:	e757      	b.n	3fdc <transceive+0x4c>
    412c:	00008e88 	.word	0x00008e88
    4130:	00008e48 	.word	0x00008e48
    4134:	000097ac 	.word	0x000097ac

00004138 <event_handler>:
	if (p_event->type == NRFX_SPI_EVENT_DONE) {
    4138:	7803      	ldrb	r3, [r0, #0]
    413a:	2b00      	cmp	r3, #0
    413c:	d16d      	bne.n	421a <event_handler+0xe2>
{
    413e:	b510      	push	{r4, lr}
    4140:	460c      	mov	r4, r1
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
    4142:	6d8a      	ldr	r2, [r1, #88]	; 0x58
	if (!ctx->tx_len) {
    4144:	6c8b      	ldr	r3, [r1, #72]	; 0x48
    4146:	b1cb      	cbz	r3, 417c <event_handler+0x44>
	if (len > ctx->tx_len) {
    4148:	429a      	cmp	r2, r3
    414a:	d807      	bhi.n	415c <event_handler+0x24>
	ctx->tx_len -= len;
    414c:	1a9b      	subs	r3, r3, r2
    414e:	648b      	str	r3, [r1, #72]	; 0x48
	if (!ctx->tx_len) {
    4150:	b31b      	cbz	r3, 419a <event_handler+0x62>
	} else if (ctx->tx_buf) {
    4152:	6c4b      	ldr	r3, [r1, #68]	; 0x44
    4154:	b193      	cbz	r3, 417c <event_handler+0x44>
		ctx->tx_buf += dfs * len;
    4156:	441a      	add	r2, r3
    4158:	644a      	str	r2, [r1, #68]	; 0x44
    415a:	e00f      	b.n	417c <event_handler+0x44>
    415c:	4b2f      	ldr	r3, [pc, #188]	; (421c <event_handler+0xe4>)
    415e:	4a30      	ldr	r2, [pc, #192]	; (4220 <event_handler+0xe8>)
    4160:	1a9b      	subs	r3, r3, r2
    4162:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Update exceeds current buffer");
    4164:	f04f 0100 	mov.w	r1, #0
    4168:	2201      	movs	r2, #1
    416a:	f362 0102 	bfi	r1, r2, #0, #3
    416e:	f36f 01c5 	bfc	r1, #3, #3
    4172:	f363 118f 	bfi	r1, r3, #6, #10
    4176:	482b      	ldr	r0, [pc, #172]	; (4224 <event_handler+0xec>)
    4178:	f7fd fd2e 	bl	1bd8 <log_0>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
    417c:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (!ctx->rx_len) {
    417e:	6d23      	ldr	r3, [r4, #80]	; 0x50
    4180:	2b00      	cmp	r3, #0
    4182:	d030      	beq.n	41e6 <event_handler+0xae>
	if (len > ctx->rx_len) {
    4184:	429a      	cmp	r2, r3
    4186:	d81e      	bhi.n	41c6 <event_handler+0x8e>
	ctx->rx_len -= len;
    4188:	1a9b      	subs	r3, r3, r2
    418a:	6523      	str	r3, [r4, #80]	; 0x50
	if (!ctx->rx_len) {
    418c:	2b00      	cmp	r3, #0
    418e:	d02e      	beq.n	41ee <event_handler+0xb6>
	} else if (ctx->rx_buf) {
    4190:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    4192:	b343      	cbz	r3, 41e6 <event_handler+0xae>
		ctx->rx_buf += dfs * len;
    4194:	441a      	add	r2, r3
    4196:	64e2      	str	r2, [r4, #76]	; 0x4c
    4198:	e025      	b.n	41e6 <event_handler+0xae>
		++ctx->current_tx;
    419a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
    419c:	3308      	adds	r3, #8
    419e:	634b      	str	r3, [r1, #52]	; 0x34
		--ctx->tx_count;
    41a0:	6b8b      	ldr	r3, [r1, #56]	; 0x38
    41a2:	3b01      	subs	r3, #1
    41a4:	638b      	str	r3, [r1, #56]	; 0x38
	while (*count) {
    41a6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    41a8:	b153      	cbz	r3, 41c0 <event_handler+0x88>
		if (((*current)->len / dfs) != 0) {
    41aa:	6b62      	ldr	r2, [r4, #52]	; 0x34
    41ac:	6851      	ldr	r1, [r2, #4]
    41ae:	b921      	cbnz	r1, 41ba <event_handler+0x82>
		++(*current);
    41b0:	3208      	adds	r2, #8
    41b2:	6362      	str	r2, [r4, #52]	; 0x34
		--(*count);
    41b4:	3b01      	subs	r3, #1
    41b6:	63a3      	str	r3, [r4, #56]	; 0x38
    41b8:	e7f5      	b.n	41a6 <event_handler+0x6e>
			*buf_len = (*current)->len / dfs;
    41ba:	64a1      	str	r1, [r4, #72]	; 0x48
			return (*current)->buf;
    41bc:	6813      	ldr	r3, [r2, #0]
    41be:	e000      	b.n	41c2 <event_handler+0x8a>
	*buf_len = 0;
    41c0:	64a3      	str	r3, [r4, #72]	; 0x48
		ctx->tx_buf = (const uint8_t *)
    41c2:	6463      	str	r3, [r4, #68]	; 0x44
    41c4:	e7da      	b.n	417c <event_handler+0x44>
    41c6:	4b15      	ldr	r3, [pc, #84]	; (421c <event_handler+0xe4>)
    41c8:	4a15      	ldr	r2, [pc, #84]	; (4220 <event_handler+0xe8>)
    41ca:	1a9b      	subs	r3, r3, r2
    41cc:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Update exceeds current buffer");
    41ce:	f04f 0100 	mov.w	r1, #0
    41d2:	2201      	movs	r2, #1
    41d4:	f362 0102 	bfi	r1, r2, #0, #3
    41d8:	f36f 01c5 	bfc	r1, #3, #3
    41dc:	f363 118f 	bfi	r1, r3, #6, #10
    41e0:	4810      	ldr	r0, [pc, #64]	; (4224 <event_handler+0xec>)
    41e2:	f7fd fcf9 	bl	1bd8 <log_0>
		transfer_next_chunk(dev_data->dev);
    41e6:	6d60      	ldr	r0, [r4, #84]	; 0x54
    41e8:	f7ff fe60 	bl	3eac <transfer_next_chunk>
}
    41ec:	bd10      	pop	{r4, pc}
		++ctx->current_rx;
    41ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    41f0:	3308      	adds	r3, #8
    41f2:	63e3      	str	r3, [r4, #60]	; 0x3c
		--ctx->rx_count;
    41f4:	6c23      	ldr	r3, [r4, #64]	; 0x40
    41f6:	3b01      	subs	r3, #1
    41f8:	6423      	str	r3, [r4, #64]	; 0x40
	while (*count) {
    41fa:	6c23      	ldr	r3, [r4, #64]	; 0x40
    41fc:	b153      	cbz	r3, 4214 <event_handler+0xdc>
		if (((*current)->len / dfs) != 0) {
    41fe:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    4200:	6851      	ldr	r1, [r2, #4]
    4202:	b921      	cbnz	r1, 420e <event_handler+0xd6>
		++(*current);
    4204:	3208      	adds	r2, #8
    4206:	63e2      	str	r2, [r4, #60]	; 0x3c
		--(*count);
    4208:	3b01      	subs	r3, #1
    420a:	6423      	str	r3, [r4, #64]	; 0x40
    420c:	e7f5      	b.n	41fa <event_handler+0xc2>
			*buf_len = (*current)->len / dfs;
    420e:	6521      	str	r1, [r4, #80]	; 0x50
			return (*current)->buf;
    4210:	6813      	ldr	r3, [r2, #0]
    4212:	e000      	b.n	4216 <event_handler+0xde>
	*buf_len = 0;
    4214:	6523      	str	r3, [r4, #80]	; 0x50
		ctx->rx_buf = (uint8_t *)
    4216:	64e3      	str	r3, [r4, #76]	; 0x4c
    4218:	e7e5      	b.n	41e6 <event_handler+0xae>
    421a:	4770      	bx	lr
    421c:	00008e88 	.word	0x00008e88
    4220:	00008e48 	.word	0x00008e48
    4224:	000097d4 	.word	0x000097d4

00004228 <set_comparator>:
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(int32_t chan, uint32_t cyc)
{
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    4228:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
    422c:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    4230:	4b01      	ldr	r3, [pc, #4]	; (4238 <set_comparator+0x10>)
    4232:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
}
    4236:	4770      	bx	lr
    4238:	40011000 	.word	0x40011000

0000423c <get_comparator>:
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
    423c:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    4240:	4b01      	ldr	r3, [pc, #4]	; (4248 <get_comparator+0xc>)
    4242:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

static uint32_t get_comparator(int32_t chan)
{
	return nrf_rtc_cc_get(RTC, chan);
}
    4246:	4770      	bx	lr
    4248:	40011000 	.word	0x40011000

0000424c <event_enable>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
}

static void event_enable(int32_t chan)
{
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    424c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    4250:	4083      	lsls	r3, r0
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    4252:	4a02      	ldr	r2, [pc, #8]	; (425c <event_enable+0x10>)
    4254:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
}
    4258:	4770      	bx	lr
    425a:	bf00      	nop
    425c:	40011000 	.word	0x40011000

00004260 <event_disable>:

static void event_disable(int32_t chan)
{
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    4260:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    4264:	4083      	lsls	r3, r0
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    4266:	4a02      	ldr	r2, [pc, #8]	; (4270 <event_disable+0x10>)
    4268:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
}
    426c:	4770      	bx	lr
    426e:	bf00      	nop
    4270:	40011000 	.word	0x40011000

00004274 <counter>:
     return p_reg->COUNTER;
    4274:	4b01      	ldr	r3, [pc, #4]	; (427c <counter+0x8>)
    4276:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

static uint32_t counter(void)
{
	return nrf_rtc_counter_get(RTC);
}
    427a:	4770      	bx	lr
    427c:	40011000 	.word	0x40011000

00004280 <compare_int_lock>:
	__ASSERT_NO_MSG(chan < CHAN_COUNT);
	return nrf_rtc_event_address_get(RTC, nrf_rtc_compare_event_get(chan));
}

static bool compare_int_lock(int32_t chan)
{
    4280:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
    4282:	2301      	movs	r3, #1
    4284:	4083      	lsls	r3, r0
    4286:	43dc      	mvns	r4, r3
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    4288:	4a10      	ldr	r2, [pc, #64]	; (42cc <compare_int_lock+0x4c>)
    428a:	f3bf 8f5b 	dmb	ish
    428e:	e852 1f00 	ldrex	r1, [r2]
    4292:	ea01 0c04 	and.w	ip, r1, r4
    4296:	e842 ce00 	strex	lr, ip, [r2]
    429a:	f1be 0f00 	cmp.w	lr, #0
    429e:	d1f6      	bne.n	428e <compare_int_lock+0xe>
    42a0:	f3bf 8f5b 	dmb	ish

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    42a4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    42a8:	fa02 f000 	lsl.w	r0, r2, r0
    p_reg->INTENCLR = mask;
    42ac:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    42b0:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    42b4:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
  __ASM volatile ("dmb 0xF":::"memory");
    42b8:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
    42bc:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
    42c0:	420b      	tst	r3, r1
}
    42c2:	bf14      	ite	ne
    42c4:	2001      	movne	r0, #1
    42c6:	2000      	moveq	r0, #0
    42c8:	bd10      	pop	{r4, pc}
    42ca:	bf00      	nop
    42cc:	200004cc 	.word	0x200004cc

000042d0 <channel_processing_check_and_clear>:
		event_enable(chan);
	}
}

static bool channel_processing_check_and_clear(int32_t chan)
{
    42d0:	b570      	push	{r4, r5, r6, lr}
    42d2:	4604      	mov	r4, r0
	bool result = false;

	uint32_t mcu_critical_state = full_int_lock();
    42d4:	f003 ff90 	bl	81f8 <full_int_lock>
    42d8:	4605      	mov	r5, r0

	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
    42da:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    42de:	40a3      	lsls	r3, r4
    return p_reg->INTENSET & mask;
    42e0:	4a17      	ldr	r2, [pc, #92]	; (4340 <channel_processing_check_and_clear+0x70>)
    42e2:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
    42e6:	4213      	tst	r3, r2
    42e8:	d105      	bne.n	42f6 <channel_processing_check_and_clear+0x26>
	bool result = false;
    42ea:	2600      	movs	r6, #0
		if (result) {
			event_clear(chan);
		}
	}

	full_int_unlock(mcu_critical_state);
    42ec:	4628      	mov	r0, r5
    42ee:	f003 ff8c 	bl	820a <full_int_unlock>

	return result;
}
    42f2:	4630      	mov	r0, r6
    42f4:	bd70      	pop	{r4, r5, r6, pc}
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    42f6:	2301      	movs	r3, #1
    42f8:	40a3      	lsls	r3, r4
    42fa:	43db      	mvns	r3, r3
    42fc:	4a11      	ldr	r2, [pc, #68]	; (4344 <channel_processing_check_and_clear+0x74>)
    42fe:	f3bf 8f5b 	dmb	ish
    4302:	e852 1f00 	ldrex	r1, [r2]
    4306:	ea01 0003 	and.w	r0, r1, r3
    430a:	e842 0600 	strex	r6, r0, [r2]
    430e:	2e00      	cmp	r6, #0
    4310:	d1f7      	bne.n	4302 <channel_processing_check_and_clear+0x32>
    4312:	f3bf 8f5b 	dmb	ish
    4316:	b959      	cbnz	r1, 4330 <channel_processing_check_and_clear+0x60>
			 nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    4318:	f104 0350 	add.w	r3, r4, #80	; 0x50
    431c:	009b      	lsls	r3, r3, #2
    431e:	b29b      	uxth	r3, r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    4320:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    4324:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
    4328:	681b      	ldr	r3, [r3, #0]
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    432a:	b113      	cbz	r3, 4332 <channel_processing_check_and_clear+0x62>
    432c:	2301      	movs	r3, #1
    432e:	e000      	b.n	4332 <channel_processing_check_and_clear+0x62>
    4330:	2301      	movs	r3, #1
		if (result) {
    4332:	461e      	mov	r6, r3
    4334:	2b00      	cmp	r3, #0
    4336:	d0d9      	beq.n	42ec <channel_processing_check_and_clear+0x1c>
			event_clear(chan);
    4338:	4620      	mov	r0, r4
    433a:	f003 ff4e 	bl	81da <event_clear>
    433e:	e7d5      	b.n	42ec <channel_processing_check_and_clear+0x1c>
    4340:	40011000 	.word	0x40011000
    4344:	200004c8 	.word	0x200004c8

00004348 <compare_int_unlock>:
	if (key) {
    4348:	b901      	cbnz	r1, 434c <compare_int_unlock+0x4>
}
    434a:	4770      	bx	lr
		atomic_or(&int_mask, BIT(chan));
    434c:	2301      	movs	r3, #1
    434e:	4083      	lsls	r3, r0
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    4350:	4a11      	ldr	r2, [pc, #68]	; (4398 <compare_int_unlock+0x50>)
    4352:	f3bf 8f5b 	dmb	ish
    4356:	e852 1f00 	ldrex	r1, [r2]
    435a:	4319      	orrs	r1, r3
    435c:	e842 1c00 	strex	ip, r1, [r2]
    4360:	f1bc 0f00 	cmp.w	ip, #0
    4364:	d1f7      	bne.n	4356 <compare_int_unlock+0xe>
    4366:	f3bf 8f5b 	dmb	ish
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    436a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    436e:	4083      	lsls	r3, r0
    p_reg->INTENSET = mask;
    4370:	4a0a      	ldr	r2, [pc, #40]	; (439c <compare_int_unlock+0x54>)
    4372:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    4376:	f3bf 8f5b 	dmb	ish
    437a:	4b09      	ldr	r3, [pc, #36]	; (43a0 <compare_int_unlock+0x58>)
    437c:	681b      	ldr	r3, [r3, #0]
    437e:	f3bf 8f5b 	dmb	ish
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
    4382:	fa23 f000 	lsr.w	r0, r3, r0
    4386:	f010 0f01 	tst.w	r0, #1
    438a:	d0de      	beq.n	434a <compare_int_unlock+0x2>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    438c:	4b05      	ldr	r3, [pc, #20]	; (43a4 <compare_int_unlock+0x5c>)
    438e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    4392:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
    4396:	e7d8      	b.n	434a <compare_int_unlock+0x2>
    4398:	200004cc 	.word	0x200004cc
    439c:	40011000 	.word	0x40011000
    43a0:	200004c8 	.word	0x200004c8
    43a4:	e000e100 	.word	0xe000e100

000043a8 <sys_clock_timeout_handler>:
{
    43a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    43aa:	4607      	mov	r7, r0
    43ac:	4614      	mov	r4, r2
    43ae:	461e      	mov	r6, r3
	uint32_t cc_value = absolute_time_to_cc(expire_time);
    43b0:	4610      	mov	r0, r2
    43b2:	4619      	mov	r1, r3
    43b4:	f003 ff1d 	bl	81f2 <absolute_time_to_cc>
    43b8:	4605      	mov	r5, r0
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
    43ba:	4b15      	ldr	r3, [pc, #84]	; (4410 <sys_clock_timeout_handler+0x68>)
    43bc:	681a      	ldr	r2, [r3, #0]
    43be:	1aa0      	subs	r0, r4, r2
	last_count += dticks * CYC_PER_TICK;
    43c0:	601c      	str	r4, [r3, #0]
    43c2:	605e      	str	r6, [r3, #4]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
    43c4:	f5a5 1300 	sub.w	r3, r5, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
    43c8:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
    43cc:	d308      	bcc.n	43e0 <sys_clock_timeout_handler+0x38>
	return false;
    43ce:	2400      	movs	r4, #0
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    43d0:	f002 fc48 	bl	6c64 <sys_clock_announce>
	if (cc_value == get_comparator(chan)) {
    43d4:	4638      	mov	r0, r7
    43d6:	f7ff ff31 	bl	423c <get_comparator>
    43da:	42a8      	cmp	r0, r5
    43dc:	d00c      	beq.n	43f8 <sys_clock_timeout_handler+0x50>
}
    43de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
    43e0:	4b0c      	ldr	r3, [pc, #48]	; (4414 <sys_clock_timeout_handler+0x6c>)
    43e2:	6819      	ldr	r1, [r3, #0]
    43e4:	0a0b      	lsrs	r3, r1, #8
    43e6:	060a      	lsls	r2, r1, #24
    43e8:	1952      	adds	r2, r2, r5
    43ea:	f143 0300 	adc.w	r3, r3, #0
    43ee:	490a      	ldr	r1, [pc, #40]	; (4418 <sys_clock_timeout_handler+0x70>)
    43f0:	e9c1 2300 	strd	r2, r3, [r1]
		return true;
    43f4:	2401      	movs	r4, #1
    43f6:	e7eb      	b.n	43d0 <sys_clock_timeout_handler+0x28>
		if (!anchor_updated) {
    43f8:	b11c      	cbz	r4, 4402 <sys_clock_timeout_handler+0x5a>
		event_enable(chan);
    43fa:	4638      	mov	r0, r7
    43fc:	f7ff ff26 	bl	424c <event_enable>
}
    4400:	e7ed      	b.n	43de <sys_clock_timeout_handler+0x36>
			set_comparator(chan, COUNTER_HALF_SPAN);
    4402:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
    4406:	4638      	mov	r0, r7
    4408:	f7ff ff0e 	bl	4228 <set_comparator>
    440c:	e7f5      	b.n	43fa <sys_clock_timeout_handler+0x52>
    440e:	bf00      	nop
    4410:	20000228 	.word	0x20000228
    4414:	200004d0 	.word	0x200004d0
    4418:	20000210 	.word	0x20000210

0000441c <z_nrf_rtc_timer_read>:
{
    441c:	b538      	push	{r3, r4, r5, lr}
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
    441e:	4b0d      	ldr	r3, [pc, #52]	; (4454 <z_nrf_rtc_timer_read+0x38>)
    4420:	681b      	ldr	r3, [r3, #0]
    4422:	0a1d      	lsrs	r5, r3, #8
    4424:	061c      	lsls	r4, r3, #24
  __ASM volatile ("dmb 0xF":::"memory");
    4426:	f3bf 8f5f 	dmb	sy
	uint32_t cntr = counter();
    442a:	f7ff ff23 	bl	4274 <counter>
    442e:	4603      	mov	r3, r0
	val += cntr;
    4430:	1820      	adds	r0, r4, r0
    4432:	f145 0100 	adc.w	r1, r5, #0
	if (cntr < OVERFLOW_RISK_RANGE_END) {
    4436:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    443a:	d20a      	bcs.n	4452 <z_nrf_rtc_timer_read+0x36>
		if (val < anchor) {
    443c:	4b06      	ldr	r3, [pc, #24]	; (4458 <z_nrf_rtc_timer_read+0x3c>)
    443e:	e9d3 2300 	ldrd	r2, r3, [r3]
    4442:	4299      	cmp	r1, r3
    4444:	bf08      	it	eq
    4446:	4290      	cmpeq	r0, r2
    4448:	d203      	bcs.n	4452 <z_nrf_rtc_timer_read+0x36>
			val += COUNTER_SPAN;
    444a:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
    444e:	f141 0100 	adc.w	r1, r1, #0
}
    4452:	bd38      	pop	{r3, r4, r5, pc}
    4454:	200004d0 	.word	0x200004d0
    4458:	20000210 	.word	0x20000210

0000445c <compare_set_nolocks>:
{
    445c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4460:	4606      	mov	r6, r0
    4462:	4614      	mov	r4, r2
    4464:	461d      	mov	r5, r3
	uint32_t cc_value = absolute_time_to_cc(target_time);
    4466:	4610      	mov	r0, r2
    4468:	4619      	mov	r1, r3
    446a:	f003 fec2 	bl	81f2 <absolute_time_to_cc>
    446e:	4607      	mov	r7, r0
	uint64_t curr_time = z_nrf_rtc_timer_read();
    4470:	f7ff ffd4 	bl	441c <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
    4474:	42a9      	cmp	r1, r5
    4476:	bf08      	it	eq
    4478:	42a0      	cmpeq	r0, r4
    447a:	d21e      	bcs.n	44ba <compare_set_nolocks+0x5e>
		if (target_time - curr_time > COUNTER_SPAN) {
    447c:	ebb4 0800 	subs.w	r8, r4, r0
    4480:	eb65 0901 	sbc.w	r9, r5, r1
    4484:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    4488:	2300      	movs	r3, #0
    448a:	454b      	cmp	r3, r9
    448c:	bf08      	it	eq
    448e:	4542      	cmpeq	r2, r8
    4490:	d32e      	bcc.n	44f0 <compare_set_nolocks+0x94>
		if (target_time != cc_data[chan].target_time) {
    4492:	4b19      	ldr	r3, [pc, #100]	; (44f8 <compare_set_nolocks+0x9c>)
    4494:	eb03 1306 	add.w	r3, r3, r6, lsl #4
    4498:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
    449c:	42ab      	cmp	r3, r5
    449e:	bf08      	it	eq
    44a0:	42a2      	cmpeq	r2, r4
    44a2:	d018      	beq.n	44d6 <compare_set_nolocks+0x7a>
			uint32_t cc_set = set_absolute_alarm(chan, cc_value);
    44a4:	4639      	mov	r1, r7
    44a6:	4630      	mov	r0, r6
    44a8:	f003 feb4 	bl	8214 <set_absolute_alarm>
			target_time += counter_sub(cc_set, cc_value);
    44ac:	4639      	mov	r1, r7
    44ae:	f003 fe90 	bl	81d2 <counter_sub>
    44b2:	1824      	adds	r4, r4, r0
    44b4:	f145 0500 	adc.w	r5, r5, #0
    44b8:	e00d      	b.n	44d6 <compare_set_nolocks+0x7a>
		atomic_or(&force_isr_mask, BIT(chan));
    44ba:	2301      	movs	r3, #1
    44bc:	40b3      	lsls	r3, r6
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    44be:	4a0f      	ldr	r2, [pc, #60]	; (44fc <compare_set_nolocks+0xa0>)
    44c0:	f3bf 8f5b 	dmb	ish
    44c4:	e852 1f00 	ldrex	r1, [r2]
    44c8:	4319      	orrs	r1, r3
    44ca:	e842 1000 	strex	r0, r1, [r2]
    44ce:	2800      	cmp	r0, #0
    44d0:	d1f8      	bne.n	44c4 <compare_set_nolocks+0x68>
    44d2:	f3bf 8f5b 	dmb	ish
	cc_data[chan].target_time = target_time;
    44d6:	4b08      	ldr	r3, [pc, #32]	; (44f8 <compare_set_nolocks+0x9c>)
    44d8:	0132      	lsls	r2, r6, #4
    44da:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    44de:	e9c6 4502 	strd	r4, r5, [r6, #8]
	cc_data[chan].callback = handler;
    44e2:	9908      	ldr	r1, [sp, #32]
    44e4:	5099      	str	r1, [r3, r2]
	cc_data[chan].user_context = user_data;
    44e6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    44e8:	6073      	str	r3, [r6, #4]
	return ret;
    44ea:	2000      	movs	r0, #0
}
    44ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			return -EINVAL;
    44f0:	f06f 0015 	mvn.w	r0, #21
    44f4:	e7fa      	b.n	44ec <compare_set_nolocks+0x90>
    44f6:	bf00      	nop
    44f8:	20000218 	.word	0x20000218
    44fc:	200004c8 	.word	0x200004c8

00004500 <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
    4500:	b530      	push	{r4, r5, lr}
    4502:	b083      	sub	sp, #12
    p_reg->PRESCALER = val;
    4504:	2300      	movs	r3, #0
    4506:	4a1e      	ldr	r2, [pc, #120]	; (4580 <sys_clock_driver_init+0x80>)
    4508:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			CLOCK_CONTROL_NRF_LF_START_AVAILABLE :
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    450c:	2b00      	cmp	r3, #0
    450e:	dd25      	ble.n	455c <sys_clock_driver_init+0x5c>
    p_reg->INTENSET = mask;
    4510:	4c1b      	ldr	r4, [pc, #108]	; (4580 <sys_clock_driver_init+0x80>)
    4512:	2502      	movs	r5, #2
    4514:	f8c4 5304 	str.w	r5, [r4, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    4518:	4b1a      	ldr	r3, [pc, #104]	; (4584 <sys_clock_driver_init+0x84>)
    451a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    451e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    4522:	2200      	movs	r2, #0
    4524:	2101      	movs	r1, #1
    4526:	2011      	movs	r0, #17
    4528:	f7fe f918 	bl	275c <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    452c:	2011      	movs	r0, #17
    452e:	f7fe f8e3 	bl	26f8 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    4532:	2301      	movs	r3, #1
    4534:	4a14      	ldr	r2, [pc, #80]	; (4588 <sys_clock_driver_init+0x88>)
    4536:	6013      	str	r3, [r2, #0]
    4538:	6023      	str	r3, [r4, #0]

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    453a:	4a14      	ldr	r2, [pc, #80]	; (458c <sys_clock_driver_init+0x8c>)
    453c:	6013      	str	r3, [r2, #0]

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
    453e:	2400      	movs	r4, #0
    4540:	9401      	str	r4, [sp, #4]
    4542:	4b13      	ldr	r3, [pc, #76]	; (4590 <sys_clock_driver_init+0x90>)
    4544:	9300      	str	r3, [sp, #0]
    4546:	4a13      	ldr	r2, [pc, #76]	; (4594 <sys_clock_driver_init+0x94>)
    4548:	2300      	movs	r3, #0
    454a:	4620      	mov	r0, r4
    454c:	f003 fe9d 	bl	828a <compare_set>

	z_nrf_clock_control_lf_on(mode);
    4550:	4628      	mov	r0, r5
    4552:	f7ff f917 	bl	3784 <z_nrf_clock_control_lf_on>

	return 0;
}
    4556:	4620      	mov	r0, r4
    4558:	b003      	add	sp, #12
    455a:	bd30      	pop	{r4, r5, pc}
		cc_data[chan].target_time = TARGET_TIME_INVALID;
    455c:	4a0e      	ldr	r2, [pc, #56]	; (4598 <sys_clock_driver_init+0x98>)
    455e:	eb02 1203 	add.w	r2, r2, r3, lsl #4
    4562:	f04f 30ff 	mov.w	r0, #4294967295
    4566:	f04f 31ff 	mov.w	r1, #4294967295
    456a:	e9c2 0102 	strd	r0, r1, [r2, #8]
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    456e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    4572:	409a      	lsls	r2, r3
    p_reg->INTENSET = mask;
    4574:	4902      	ldr	r1, [pc, #8]	; (4580 <sys_clock_driver_init+0x80>)
    4576:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    457a:	3301      	adds	r3, #1
    457c:	e7c6      	b.n	450c <sys_clock_driver_init+0xc>
    457e:	bf00      	nop
    4580:	40011000 	.word	0x40011000
    4584:	e000e100 	.word	0xe000e100
    4588:	40011008 	.word	0x40011008
    458c:	200004cc 	.word	0x200004cc
    4590:	000043a9 	.word	0x000043a9
    4594:	007fffff 	.word	0x007fffff
    4598:	20000218 	.word	0x20000218

0000459c <process_channel>:
{
    459c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    45a0:	b082      	sub	sp, #8
    45a2:	4604      	mov	r4, r0
	if (channel_processing_check_and_clear(chan)) {
    45a4:	f7ff fe94 	bl	42d0 <channel_processing_check_and_clear>
    45a8:	b910      	cbnz	r0, 45b0 <process_channel+0x14>
}
    45aa:	b002      	add	sp, #8
    45ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_time = z_nrf_rtc_timer_read();
    45b0:	f7ff ff34 	bl	441c <z_nrf_rtc_timer_read>
    45b4:	4606      	mov	r6, r0
    45b6:	460f      	mov	r7, r1
		mcu_critical_state = full_int_lock();
    45b8:	f003 fe1e 	bl	81f8 <full_int_lock>
    45bc:	4682      	mov	sl, r0
		expire_time = cc_data[chan].target_time;
    45be:	4b13      	ldr	r3, [pc, #76]	; (460c <process_channel+0x70>)
    45c0:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    45c4:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
		if (curr_time >= expire_time) {
    45c8:	454f      	cmp	r7, r9
    45ca:	bf08      	it	eq
    45cc:	4546      	cmpeq	r6, r8
    45ce:	d20b      	bcs.n	45e8 <process_channel+0x4c>
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
    45d0:	2600      	movs	r6, #0
		full_int_unlock(mcu_critical_state);
    45d2:	4650      	mov	r0, sl
    45d4:	f003 fe19 	bl	820a <full_int_unlock>
		if (handler) {
    45d8:	2e00      	cmp	r6, #0
    45da:	d0e6      	beq.n	45aa <process_channel+0xe>
			handler(chan, expire_time, user_context);
    45dc:	9500      	str	r5, [sp, #0]
    45de:	4642      	mov	r2, r8
    45e0:	464b      	mov	r3, r9
    45e2:	4620      	mov	r0, r4
    45e4:	47b0      	blx	r6
}
    45e6:	e7e0      	b.n	45aa <process_channel+0xe>
			handler = cc_data[chan].callback;
    45e8:	4a08      	ldr	r2, [pc, #32]	; (460c <process_channel+0x70>)
    45ea:	0123      	lsls	r3, r4, #4
    45ec:	eb02 1104 	add.w	r1, r2, r4, lsl #4
    45f0:	58d6      	ldr	r6, [r2, r3]
			user_context = cc_data[chan].user_context;
    45f2:	684d      	ldr	r5, [r1, #4]
			cc_data[chan].callback = NULL;
    45f4:	2000      	movs	r0, #0
    45f6:	50d0      	str	r0, [r2, r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
    45f8:	f04f 32ff 	mov.w	r2, #4294967295
    45fc:	f04f 33ff 	mov.w	r3, #4294967295
    4600:	e9c1 2302 	strd	r2, r3, [r1, #8]
			event_disable(chan);
    4604:	4620      	mov	r0, r4
    4606:	f7ff fe2b 	bl	4260 <event_disable>
    460a:	e7e2      	b.n	45d2 <process_channel+0x36>
    460c:	20000218 	.word	0x20000218

00004610 <rtc_nrf_isr>:
{
    4610:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
    4612:	4b0d      	ldr	r3, [pc, #52]	; (4648 <rtc_nrf_isr+0x38>)
    4614:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
    4618:	f013 0f02 	tst.w	r3, #2
    461c:	d00a      	beq.n	4634 <rtc_nrf_isr+0x24>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    461e:	4b0b      	ldr	r3, [pc, #44]	; (464c <rtc_nrf_isr+0x3c>)
    4620:	681b      	ldr	r3, [r3, #0]
    4622:	b13b      	cbz	r3, 4634 <rtc_nrf_isr+0x24>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    4624:	4b09      	ldr	r3, [pc, #36]	; (464c <rtc_nrf_isr+0x3c>)
    4626:	2200      	movs	r2, #0
    4628:	601a      	str	r2, [r3, #0]
    462a:	681b      	ldr	r3, [r3, #0]
		overflow_cnt++;
    462c:	4a08      	ldr	r2, [pc, #32]	; (4650 <rtc_nrf_isr+0x40>)
    462e:	6813      	ldr	r3, [r2, #0]
    4630:	3301      	adds	r3, #1
    4632:	6013      	str	r3, [r2, #0]
{
    4634:	2400      	movs	r4, #0
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    4636:	2c00      	cmp	r4, #0
    4638:	dd00      	ble.n	463c <rtc_nrf_isr+0x2c>
}
    463a:	bd10      	pop	{r4, pc}
		process_channel(chan);
    463c:	4620      	mov	r0, r4
    463e:	f7ff ffad 	bl	459c <process_channel>
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    4642:	3401      	adds	r4, #1
    4644:	e7f7      	b.n	4636 <rtc_nrf_isr+0x26>
    4646:	bf00      	nop
    4648:	40011000 	.word	0x40011000
    464c:	40011104 	.word	0x40011104
    4650:	200004d0 	.word	0x200004d0

00004654 <sys_clock_set_timeout>:
{
    4654:	b510      	push	{r4, lr}
    4656:	b082      	sub	sp, #8
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    4658:	f1b0 3fff 	cmp.w	r0, #4294967295
    465c:	d007      	beq.n	466e <sys_clock_set_timeout+0x1a>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    465e:	1e44      	subs	r4, r0, #1
    4660:	2c00      	cmp	r4, #0
    4662:	dd07      	ble.n	4674 <sys_clock_set_timeout+0x20>
    4664:	4b11      	ldr	r3, [pc, #68]	; (46ac <sys_clock_set_timeout+0x58>)
    4666:	429c      	cmp	r4, r3
    4668:	dd05      	ble.n	4676 <sys_clock_set_timeout+0x22>
    466a:	4c11      	ldr	r4, [pc, #68]	; (46b0 <sys_clock_set_timeout+0x5c>)
    466c:	e003      	b.n	4676 <sys_clock_set_timeout+0x22>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    466e:	f500 0000 	add.w	r0, r0, #8388608	; 0x800000
    4672:	e7f4      	b.n	465e <sys_clock_set_timeout+0xa>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    4674:	2400      	movs	r4, #0
	uint32_t unannounced = z_nrf_rtc_timer_read() - last_count;
    4676:	f7ff fed1 	bl	441c <z_nrf_rtc_timer_read>
    467a:	4b0e      	ldr	r3, [pc, #56]	; (46b4 <sys_clock_set_timeout+0x60>)
    467c:	e9d3 2300 	ldrd	r2, r3, [r3]
    4680:	1a80      	subs	r0, r0, r2
	if (unannounced >= COUNTER_HALF_SPAN) {
    4682:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    4686:	d300      	bcc.n	468a <sys_clock_set_timeout+0x36>
		ticks = 0;
    4688:	2400      	movs	r4, #0
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    468a:	4404      	add	r4, r0
    468c:	3401      	adds	r4, #1
	if (cyc > MAX_CYCLES) {
    468e:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
    4692:	d300      	bcc.n	4696 <sys_clock_set_timeout+0x42>
		cyc = MAX_CYCLES;
    4694:	4c06      	ldr	r4, [pc, #24]	; (46b0 <sys_clock_set_timeout+0x5c>)
	compare_set(0, target_time, sys_clock_timeout_handler, NULL);
    4696:	2000      	movs	r0, #0
    4698:	9001      	str	r0, [sp, #4]
    469a:	4907      	ldr	r1, [pc, #28]	; (46b8 <sys_clock_set_timeout+0x64>)
    469c:	9100      	str	r1, [sp, #0]
    469e:	1912      	adds	r2, r2, r4
    46a0:	f143 0300 	adc.w	r3, r3, #0
    46a4:	f003 fdf1 	bl	828a <compare_set>
}
    46a8:	b002      	add	sp, #8
    46aa:	bd10      	pop	{r4, pc}
    46ac:	007ffffe 	.word	0x007ffffe
    46b0:	007fffff 	.word	0x007fffff
    46b4:	20000228 	.word	0x20000228
    46b8:	000043a9 	.word	0x000043a9

000046bc <sys_clock_elapsed>:
{
    46bc:	b508      	push	{r3, lr}
	return (z_nrf_rtc_timer_read() - last_count) / CYC_PER_TICK;
    46be:	f7ff fead 	bl	441c <z_nrf_rtc_timer_read>
    46c2:	4b02      	ldr	r3, [pc, #8]	; (46cc <sys_clock_elapsed+0x10>)
    46c4:	681b      	ldr	r3, [r3, #0]
}
    46c6:	1ac0      	subs	r0, r0, r3
    46c8:	bd08      	pop	{r3, pc}
    46ca:	bf00      	nop
    46cc:	20000228 	.word	0x20000228

000046d0 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
    46d0:	b508      	push	{r3, lr}
	z_impl_log_panic();
    46d2:	f7fd fae1 	bl	1c98 <z_impl_log_panic>
    46d6:	4b09      	ldr	r3, [pc, #36]	; (46fc <k_sys_fatal_error_handler+0x2c>)
    46d8:	4a09      	ldr	r2, [pc, #36]	; (4700 <k_sys_fatal_error_handler+0x30>)
    46da:	1a9b      	subs	r3, r3, r2
    46dc:	08db      	lsrs	r3, r3, #3
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
    46de:	f04f 0100 	mov.w	r1, #0
    46e2:	2201      	movs	r2, #1
    46e4:	f362 0102 	bfi	r1, r2, #0, #3
    46e8:	f36f 01c5 	bfc	r1, #3, #3
    46ec:	f363 118f 	bfi	r1, r3, #6, #10
    46f0:	4804      	ldr	r0, [pc, #16]	; (4704 <k_sys_fatal_error_handler+0x34>)
    46f2:	f7fd fa71 	bl	1bd8 <log_0>
		sys_arch_reboot(0);
    46f6:	2000      	movs	r0, #0
    46f8:	f7fe feac 	bl	3454 <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
    46fc:	00008e58 	.word	0x00008e58
    4700:	00008e48 	.word	0x00008e48
    4704:	00009830 	.word	0x00009830

00004708 <nrf52_errata_12>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    4708:	4b06      	ldr	r3, [pc, #24]	; (4724 <nrf52_errata_12+0x1c>)
    470a:	681b      	ldr	r3, [r3, #0]
    470c:	f1b3 3fff 	cmp.w	r3, #4294967295
    4710:	d003      	beq.n	471a <nrf52_errata_12+0x12>
                var2 = *(uint32_t *)0x10000134ul;
            }
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4712:	2b06      	cmp	r3, #6
    4714:	d004      	beq.n	4720 <nrf52_errata_12+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    4716:	2000      	movs	r0, #0
    4718:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    471a:	4b03      	ldr	r3, [pc, #12]	; (4728 <nrf52_errata_12+0x20>)
    471c:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    471e:	e7f8      	b.n	4712 <nrf52_errata_12+0xa>
                        return true;
    4720:	2001      	movs	r0, #1
    #endif
}
    4722:	4770      	bx	lr
    4724:	10000130 	.word	0x10000130
    4728:	f0000fe0 	.word	0xf0000fe0

0000472c <nrf52_errata_16>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    472c:	4b09      	ldr	r3, [pc, #36]	; (4754 <nrf52_errata_16+0x28>)
    472e:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    4730:	3308      	adds	r3, #8
    4732:	681b      	ldr	r3, [r3, #0]
    4734:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4738:	2a06      	cmp	r2, #6
    473a:	d001      	beq.n	4740 <nrf52_errata_16+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    473c:	2000      	movs	r0, #0
    473e:	4770      	bx	lr
                switch(var2)
    4740:	3b03      	subs	r3, #3
    4742:	2b00      	cmp	r3, #0
    4744:	d804      	bhi.n	4750 <nrf52_errata_16+0x24>
    4746:	e8df f003 	tbb	[pc, r3]
    474a:	01          	.byte	0x01
    474b:	00          	.byte	0x00
            if (var1 == 0x06)
    474c:	2001      	movs	r0, #1
    474e:	4770      	bx	lr
                        return false;
    4750:	2000      	movs	r0, #0
    #endif
}
    4752:	4770      	bx	lr
    4754:	f0000fe0 	.word	0xf0000fe0

00004758 <nrf52_errata_31>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    4758:	4b06      	ldr	r3, [pc, #24]	; (4774 <nrf52_errata_31+0x1c>)
    475a:	681b      	ldr	r3, [r3, #0]
    475c:	f1b3 3fff 	cmp.w	r3, #4294967295
    4760:	d003      	beq.n	476a <nrf52_errata_31+0x12>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4762:	2b06      	cmp	r3, #6
    4764:	d004      	beq.n	4770 <nrf52_errata_31+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    4766:	2000      	movs	r0, #0
    4768:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    476a:	4b03      	ldr	r3, [pc, #12]	; (4778 <nrf52_errata_31+0x20>)
    476c:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    476e:	e7f8      	b.n	4762 <nrf52_errata_31+0xa>
                        return true;
    4770:	2001      	movs	r0, #1
    #endif
}
    4772:	4770      	bx	lr
    4774:	10000130 	.word	0x10000130
    4778:	f0000fe0 	.word	0xf0000fe0

0000477c <nrf52_errata_32>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    477c:	4b09      	ldr	r3, [pc, #36]	; (47a4 <nrf52_errata_32+0x28>)
    477e:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    4780:	3308      	adds	r3, #8
    4782:	681b      	ldr	r3, [r3, #0]
    4784:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4788:	2a06      	cmp	r2, #6
    478a:	d001      	beq.n	4790 <nrf52_errata_32+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    478c:	2000      	movs	r0, #0
    478e:	4770      	bx	lr
                switch(var2)
    4790:	3b03      	subs	r3, #3
    4792:	2b00      	cmp	r3, #0
    4794:	d804      	bhi.n	47a0 <nrf52_errata_32+0x24>
    4796:	e8df f003 	tbb	[pc, r3]
    479a:	01          	.byte	0x01
    479b:	00          	.byte	0x00
            if (var1 == 0x06)
    479c:	2001      	movs	r0, #1
    479e:	4770      	bx	lr
                        return false;
    47a0:	2000      	movs	r0, #0
    #endif
}
    47a2:	4770      	bx	lr
    47a4:	f0000fe0 	.word	0xf0000fe0

000047a8 <nrf52_errata_36>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    47a8:	4b06      	ldr	r3, [pc, #24]	; (47c4 <nrf52_errata_36+0x1c>)
    47aa:	681b      	ldr	r3, [r3, #0]
    47ac:	f1b3 3fff 	cmp.w	r3, #4294967295
    47b0:	d003      	beq.n	47ba <nrf52_errata_36+0x12>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    47b2:	2b06      	cmp	r3, #6
    47b4:	d004      	beq.n	47c0 <nrf52_errata_36+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    47b6:	2000      	movs	r0, #0
    47b8:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    47ba:	4b03      	ldr	r3, [pc, #12]	; (47c8 <nrf52_errata_36+0x20>)
    47bc:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    47be:	e7f8      	b.n	47b2 <nrf52_errata_36+0xa>
                        return true;
    47c0:	2001      	movs	r0, #1
    #endif
}
    47c2:	4770      	bx	lr
    47c4:	10000130 	.word	0x10000130
    47c8:	f0000fe0 	.word	0xf0000fe0

000047cc <nrf52_errata_37>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    47cc:	4b09      	ldr	r3, [pc, #36]	; (47f4 <nrf52_errata_37+0x28>)
    47ce:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    47d0:	3308      	adds	r3, #8
    47d2:	681b      	ldr	r3, [r3, #0]
    47d4:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    47d8:	2a06      	cmp	r2, #6
    47da:	d001      	beq.n	47e0 <nrf52_errata_37+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    47dc:	2000      	movs	r0, #0
    47de:	4770      	bx	lr
                switch(var2)
    47e0:	3b03      	subs	r3, #3
    47e2:	2b00      	cmp	r3, #0
    47e4:	d804      	bhi.n	47f0 <nrf52_errata_37+0x24>
    47e6:	e8df f003 	tbb	[pc, r3]
    47ea:	01          	.byte	0x01
    47eb:	00          	.byte	0x00
            if (var1 == 0x06)
    47ec:	2001      	movs	r0, #1
    47ee:	4770      	bx	lr
                        return false;
    47f0:	2000      	movs	r0, #0
    #endif
}
    47f2:	4770      	bx	lr
    47f4:	f0000fe0 	.word	0xf0000fe0

000047f8 <nrf52_errata_57>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    47f8:	4b09      	ldr	r3, [pc, #36]	; (4820 <nrf52_errata_57+0x28>)
    47fa:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    47fc:	3308      	adds	r3, #8
    47fe:	681b      	ldr	r3, [r3, #0]
    4800:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4804:	2a06      	cmp	r2, #6
    4806:	d001      	beq.n	480c <nrf52_errata_57+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    4808:	2000      	movs	r0, #0
    480a:	4770      	bx	lr
                switch(var2)
    480c:	3b03      	subs	r3, #3
    480e:	2b00      	cmp	r3, #0
    4810:	d804      	bhi.n	481c <nrf52_errata_57+0x24>
    4812:	e8df f003 	tbb	[pc, r3]
    4816:	01          	.byte	0x01
    4817:	00          	.byte	0x00
            if (var1 == 0x06)
    4818:	2001      	movs	r0, #1
    481a:	4770      	bx	lr
                        return false;
    481c:	2000      	movs	r0, #0
    #endif
}
    481e:	4770      	bx	lr
    4820:	f0000fe0 	.word	0xf0000fe0

00004824 <nrf52_errata_66>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    4824:	4b0d      	ldr	r3, [pc, #52]	; (485c <nrf52_errata_66+0x38>)
    4826:	681a      	ldr	r2, [r3, #0]
    4828:	f1b2 3fff 	cmp.w	r2, #4294967295
    482c:	d005      	beq.n	483a <nrf52_errata_66+0x16>
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
            }
            else
            {
                var1 = *(uint32_t *)0x10000130ul;
                var2 = *(uint32_t *)0x10000134ul;
    482e:	4b0c      	ldr	r3, [pc, #48]	; (4860 <nrf52_errata_66+0x3c>)
    4830:	681b      	ldr	r3, [r3, #0]
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4832:	2a06      	cmp	r2, #6
    4834:	d008      	beq.n	4848 <nrf52_errata_66+0x24>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    4836:	2000      	movs	r0, #0
    4838:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    483a:	4b0a      	ldr	r3, [pc, #40]	; (4864 <nrf52_errata_66+0x40>)
    483c:	781a      	ldrb	r2, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    483e:	3308      	adds	r3, #8
    4840:	681b      	ldr	r3, [r3, #0]
    4842:	f3c3 1303 	ubfx	r3, r3, #4, #4
    4846:	e7f4      	b.n	4832 <nrf52_errata_66+0xe>
                switch(var2)
    4848:	3b03      	subs	r3, #3
    484a:	2b01      	cmp	r3, #1
    484c:	d804      	bhi.n	4858 <nrf52_errata_66+0x34>
    484e:	e8df f003 	tbb	[pc, r3]
    4852:	0101      	.short	0x0101
            if (var1 == 0x06)
    4854:	2000      	movs	r0, #0
    4856:	4770      	bx	lr
                        return true;
    4858:	2001      	movs	r0, #1
    #endif
}
    485a:	4770      	bx	lr
    485c:	10000130 	.word	0x10000130
    4860:	10000134 	.word	0x10000134
    4864:	f0000fe0 	.word	0xf0000fe0

00004868 <nrf52_errata_108>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    4868:	4b06      	ldr	r3, [pc, #24]	; (4884 <nrf52_errata_108+0x1c>)
    486a:	681b      	ldr	r3, [r3, #0]
    486c:	f1b3 3fff 	cmp.w	r3, #4294967295
    4870:	d003      	beq.n	487a <nrf52_errata_108+0x12>
                var2 = *(uint32_t *)0x10000134ul;
            }
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4872:	2b06      	cmp	r3, #6
    4874:	d004      	beq.n	4880 <nrf52_errata_108+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    4876:	2000      	movs	r0, #0
    4878:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    487a:	4b03      	ldr	r3, [pc, #12]	; (4888 <nrf52_errata_108+0x20>)
    487c:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    487e:	e7f8      	b.n	4872 <nrf52_errata_108+0xa>
                        return true;
    4880:	2001      	movs	r0, #1
    #endif
}
    4882:	4770      	bx	lr
    4884:	10000130 	.word	0x10000130
    4888:	f0000fe0 	.word	0xf0000fe0

0000488c <nrf52_errata_136>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    488c:	4b06      	ldr	r3, [pc, #24]	; (48a8 <nrf52_errata_136+0x1c>)
    488e:	681b      	ldr	r3, [r3, #0]
    4890:	f1b3 3fff 	cmp.w	r3, #4294967295
    4894:	d003      	beq.n	489e <nrf52_errata_136+0x12>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    4896:	2b06      	cmp	r3, #6
    4898:	d004      	beq.n	48a4 <nrf52_errata_136+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    489a:	2000      	movs	r0, #0
    489c:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    489e:	4b03      	ldr	r3, [pc, #12]	; (48ac <nrf52_errata_136+0x20>)
    48a0:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    48a2:	e7f8      	b.n	4896 <nrf52_errata_136+0xa>
                        return true;
    48a4:	2001      	movs	r0, #1
    #endif
}
    48a6:	4770      	bx	lr
    48a8:	10000130 	.word	0x10000130
    48ac:	f0000fe0 	.word	0xf0000fe0

000048b0 <nrf52_errata_182>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    48b0:	4b08      	ldr	r3, [pc, #32]	; (48d4 <nrf52_errata_182+0x24>)
    48b2:	681b      	ldr	r3, [r3, #0]
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    48b4:	4a08      	ldr	r2, [pc, #32]	; (48d8 <nrf52_errata_182+0x28>)
    48b6:	6812      	ldr	r2, [r2, #0]
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    48b8:	2b06      	cmp	r3, #6
    48ba:	d001      	beq.n	48c0 <nrf52_errata_182+0x10>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    48bc:	2000      	movs	r0, #0
    48be:	4770      	bx	lr
                switch(var2)
    48c0:	2a05      	cmp	r2, #5
    48c2:	d803      	bhi.n	48cc <nrf52_errata_182+0x1c>
    48c4:	2a03      	cmp	r2, #3
    48c6:	d303      	bcc.n	48d0 <nrf52_errata_182+0x20>
    48c8:	2000      	movs	r0, #0
    48ca:	4770      	bx	lr
                        return true;
    48cc:	2001      	movs	r0, #1
    48ce:	4770      	bx	lr
                        return true;
    48d0:	2001      	movs	r0, #1
    #endif
}
    48d2:	4770      	bx	lr
    48d4:	10000130 	.word	0x10000130
    48d8:	10000134 	.word	0x10000134

000048dc <nrf52_configuration_249>:
         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    48dc:	4b08      	ldr	r3, [pc, #32]	; (4900 <nrf52_configuration_249+0x24>)
    48de:	681b      	ldr	r3, [r3, #0]
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    48e0:	4a08      	ldr	r2, [pc, #32]	; (4904 <nrf52_configuration_249+0x28>)
    48e2:	6812      	ldr	r2, [r2, #0]
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    48e4:	2b06      	cmp	r3, #6
    48e6:	d001      	beq.n	48ec <nrf52_configuration_249+0x10>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    48e8:	2000      	movs	r0, #0
    48ea:	4770      	bx	lr
                switch(var2)
    48ec:	2a06      	cmp	r2, #6
    48ee:	d803      	bhi.n	48f8 <nrf52_configuration_249+0x1c>
    48f0:	2a03      	cmp	r2, #3
    48f2:	d303      	bcc.n	48fc <nrf52_configuration_249+0x20>
    48f4:	2000      	movs	r0, #0
    48f6:	4770      	bx	lr
                        return true;
    48f8:	2001      	movs	r0, #1
    48fa:	4770      	bx	lr
                        return true;
    48fc:	2001      	movs	r0, #1
    #endif
}
    48fe:	4770      	bx	lr
    4900:	10000130 	.word	0x10000130
    4904:	10000134 	.word	0x10000134

00004908 <SystemCoreClockUpdate>:
    nvmc_wait();
}

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    4908:	4b01      	ldr	r3, [pc, #4]	; (4910 <SystemCoreClockUpdate+0x8>)
    490a:	4a02      	ldr	r2, [pc, #8]	; (4914 <SystemCoreClockUpdate+0xc>)
    490c:	601a      	str	r2, [r3, #0]
}
    490e:	4770      	bx	lr
    4910:	2000008c 	.word	0x2000008c
    4914:	03d09000 	.word	0x03d09000

00004918 <SystemInit>:

void SystemInit(void)
{
    4918:	b508      	push	{r3, lr}
    #endif

    #if NRF52_ERRATA_12_ENABLE_WORKAROUND
        /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_12()){
    491a:	f7ff fef5 	bl	4708 <nrf52_errata_12>
    491e:	b128      	cbz	r0, 492c <SystemInit+0x14>
            *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
    4920:	4b5b      	ldr	r3, [pc, #364]	; (4a90 <SystemInit+0x178>)
    4922:	681b      	ldr	r3, [r3, #0]
    4924:	f3c3 2304 	ubfx	r3, r3, #8, #5
    4928:	4a5a      	ldr	r2, [pc, #360]	; (4a94 <SystemInit+0x17c>)
    492a:	6013      	str	r3, [r2, #0]
    #endif

    #if NRF52_ERRATA_16_ENABLE_WORKAROUND
        /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_16()){
    492c:	f7ff fefe 	bl	472c <nrf52_errata_16>
    4930:	b110      	cbz	r0, 4938 <SystemInit+0x20>
            *(volatile uint32_t *)0x4007C074 = 3131961357ul;
    4932:	4b59      	ldr	r3, [pc, #356]	; (4a98 <SystemInit+0x180>)
    4934:	4a59      	ldr	r2, [pc, #356]	; (4a9c <SystemInit+0x184>)
    4936:	601a      	str	r2, [r3, #0]
    #endif

    #if NRF52_ERRATA_31_ENABLE_WORKAROUND
        /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_31()){
    4938:	f7ff ff0e 	bl	4758 <nrf52_errata_31>
    493c:	b128      	cbz	r0, 494a <SystemInit+0x32>
            *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
    493e:	4b58      	ldr	r3, [pc, #352]	; (4aa0 <SystemInit+0x188>)
    4940:	681b      	ldr	r3, [r3, #0]
    4942:	f3c3 3342 	ubfx	r3, r3, #13, #3
    4946:	4a57      	ldr	r2, [pc, #348]	; (4aa4 <SystemInit+0x18c>)
    4948:	6013      	str	r3, [r2, #0]
    #endif

    #if NRF52_ERRATA_32_ENABLE_WORKAROUND
        /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_32()){
    494a:	f7ff ff17 	bl	477c <nrf52_errata_32>
    494e:	b120      	cbz	r0, 495a <SystemInit+0x42>
            CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
    4950:	4a55      	ldr	r2, [pc, #340]	; (4aa8 <SystemInit+0x190>)
    4952:	68d3      	ldr	r3, [r2, #12]
    4954:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    4958:	60d3      	str	r3, [r2, #12]
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
    495a:	f7ff ff25 	bl	47a8 <nrf52_errata_36>
    495e:	b140      	cbz	r0, 4972 <SystemInit+0x5a>
            NRF_CLOCK->EVENTS_DONE = 0;
    4960:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4964:	2200      	movs	r2, #0
    4966:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
    496a:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
    496e:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_37_ENABLE_WORKAROUND
        /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_37()){
    4972:	f7ff ff2b 	bl	47cc <nrf52_errata_37>
    4976:	b110      	cbz	r0, 497e <SystemInit+0x66>
            *(volatile uint32_t *)0x400005A0 = 0x3;
    4978:	4b4c      	ldr	r3, [pc, #304]	; (4aac <SystemInit+0x194>)
    497a:	2203      	movs	r2, #3
    497c:	601a      	str	r2, [r3, #0]
    #endif

    #if NRF52_ERRATA_57_ENABLE_WORKAROUND
        /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_57()){
    497e:	f7ff ff3b 	bl	47f8 <nrf52_errata_57>
    4982:	b158      	cbz	r0, 499c <SystemInit+0x84>
            *(volatile uint32_t *)0x40005610 = 0x00000005;
    4984:	4b4a      	ldr	r3, [pc, #296]	; (4ab0 <SystemInit+0x198>)
    4986:	2205      	movs	r2, #5
    4988:	601a      	str	r2, [r3, #0]
            *(volatile uint32_t *)0x40005688 = 0x00000001;
    498a:	3378      	adds	r3, #120	; 0x78
    498c:	2201      	movs	r2, #1
    498e:	601a      	str	r2, [r3, #0]
            *(volatile uint32_t *)0x40005618 = 0x00000000;
    4990:	3b70      	subs	r3, #112	; 0x70
    4992:	2200      	movs	r2, #0
    4994:	601a      	str	r2, [r3, #0]
            *(volatile uint32_t *)0x40005614 = 0x0000003F;
    4996:	3b04      	subs	r3, #4
    4998:	223f      	movs	r2, #63	; 0x3f
    499a:	601a      	str	r2, [r3, #0]
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
    499c:	f7ff ff42 	bl	4824 <nrf52_errata_66>
    49a0:	2800      	cmp	r0, #0
    49a2:	d046      	beq.n	4a32 <SystemInit+0x11a>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    49a4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    49a8:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    49ac:	4b41      	ldr	r3, [pc, #260]	; (4ab4 <SystemInit+0x19c>)
    49ae:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    49b2:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    49b6:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    49ba:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    49be:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    49c2:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    49c6:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    49ca:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    49ce:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    49d2:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    49d6:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    49da:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    49de:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    49e2:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    49e6:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    49ea:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    49ee:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    49f2:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    49f6:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    49fa:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    49fe:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    4a02:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    4a06:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    4a0a:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    4a0e:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    4a12:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    4a16:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    4a1a:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    4a1e:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    4a22:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    4a26:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    4a2a:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    4a2e:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_108_ENABLE_WORKAROUND
        /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_108()){
    4a32:	f7ff ff19 	bl	4868 <nrf52_errata_108>
    4a36:	b128      	cbz	r0, 4a44 <SystemInit+0x12c>
            *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
    4a38:	4b1f      	ldr	r3, [pc, #124]	; (4ab8 <SystemInit+0x1a0>)
    4a3a:	681b      	ldr	r3, [r3, #0]
    4a3c:	f003 034f 	and.w	r3, r3, #79	; 0x4f
    4a40:	4a1e      	ldr	r2, [pc, #120]	; (4abc <SystemInit+0x1a4>)
    4a42:	6013      	str	r3, [r2, #0]
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
    4a44:	f7ff ff22 	bl	488c <nrf52_errata_136>
    4a48:	b160      	cbz	r0, 4a64 <SystemInit+0x14c>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    4a4a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4a4e:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    4a52:	f013 0f01 	tst.w	r3, #1
    4a56:	d005      	beq.n	4a64 <SystemInit+0x14c>
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    4a58:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4a5c:	f06f 0201 	mvn.w	r2, #1
    4a60:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    #endif

    #if NRF52_ERRATA_182_ENABLE_WORKAROUND
        /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_182()){
    4a64:	f7ff ff24 	bl	48b0 <nrf52_errata_182>
    4a68:	b120      	cbz	r0, 4a74 <SystemInit+0x15c>
            *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
    4a6a:	4a15      	ldr	r2, [pc, #84]	; (4ac0 <SystemInit+0x1a8>)
    4a6c:	6813      	ldr	r3, [r2, #0]
    4a6e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    4a72:	6013      	str	r3, [r2, #0]
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
    4a74:	f7ff ff32 	bl	48dc <nrf52_configuration_249>
    4a78:	b138      	cbz	r0, 4a8a <SystemInit+0x172>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
    4a7a:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    4a7e:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    4a82:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4a86:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558
            nvmc_config(NVMC_CONFIG_WEN_Ren);
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
    4a8a:	f7ff ff3d 	bl	4908 <SystemCoreClockUpdate>
}
    4a8e:	bd08      	pop	{r3, pc}
    4a90:	10000324 	.word	0x10000324
    4a94:	40013540 	.word	0x40013540
    4a98:	4007c074 	.word	0x4007c074
    4a9c:	baadf00d 	.word	0xbaadf00d
    4aa0:	10000244 	.word	0x10000244
    4aa4:	4000053c 	.word	0x4000053c
    4aa8:	e000edf0 	.word	0xe000edf0
    4aac:	400005a0 	.word	0x400005a0
    4ab0:	40005610 	.word	0x40005610
    4ab4:	4000c000 	.word	0x4000c000
    4ab8:	10000258 	.word	0x10000258
    4abc:	40000ee4 	.word	0x40000ee4
    4ac0:	4000173c 	.word	0x4000173c

00004ac4 <nrfx_flag32_alloc>:
{
    return (mask & NRFX_BIT(bitpos)) ? false : true;
}

nrfx_err_t nrfx_flag32_alloc(nrfx_atomic_t * p_mask, uint8_t *p_flag)
{
    4ac4:	b430      	push	{r4, r5}
    int8_t idx;
    uint32_t new_mask, prev_mask;

    do {
        prev_mask = *p_mask;
    4ac6:	6804      	ldr	r4, [r0, #0]
        idx = 31 - NRF_CLZ(prev_mask);
    4ac8:	fab4 f384 	clz	r3, r4
        if (idx < 0) {
    4acc:	f1d3 031f 	rsbs	r3, r3, #31
    4ad0:	d415      	bmi.n	4afe <nrfx_flag32_alloc+0x3a>
            return NRFX_ERROR_NO_MEM;
        }

        new_mask = prev_mask & ~NRFX_BIT(idx);
    4ad2:	2201      	movs	r2, #1
    4ad4:	409a      	lsls	r2, r3
    4ad6:	ea24 0202 	bic.w	r2, r4, r2
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    4ada:	f3bf 8f5b 	dmb	ish
    4ade:	e850 5f00 	ldrex	r5, [r0]
    4ae2:	42a5      	cmp	r5, r4
    4ae4:	d104      	bne.n	4af0 <nrfx_flag32_alloc+0x2c>
    4ae6:	e840 2c00 	strex	ip, r2, [r0]
    4aea:	f1bc 0f00 	cmp.w	ip, #0
    4aee:	d1f6      	bne.n	4ade <nrfx_flag32_alloc+0x1a>
    4af0:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    4af4:	d1e7      	bne.n	4ac6 <nrfx_flag32_alloc+0x2>

    *p_flag = idx;
    4af6:	700b      	strb	r3, [r1, #0]

    return NRFX_SUCCESS;
    4af8:	4802      	ldr	r0, [pc, #8]	; (4b04 <nrfx_flag32_alloc+0x40>)
}
    4afa:	bc30      	pop	{r4, r5}
    4afc:	4770      	bx	lr
            return NRFX_ERROR_NO_MEM;
    4afe:	4802      	ldr	r0, [pc, #8]	; (4b08 <nrfx_flag32_alloc+0x44>)
    4b00:	e7fb      	b.n	4afa <nrfx_flag32_alloc+0x36>
    4b02:	bf00      	nop
    4b04:	0bad0000 	.word	0x0bad0000
    4b08:	0bad0002 	.word	0x0bad0002

00004b0c <nrfx_flag32_free>:

nrfx_err_t nrfx_flag32_free(nrfx_atomic_t * p_mask, uint8_t flag)
{
    4b0c:	b410      	push	{r4}
    uint32_t new_mask, prev_mask;

    if ((NRFX_BIT(flag) & *p_mask))
    4b0e:	6803      	ldr	r3, [r0, #0]
    4b10:	460c      	mov	r4, r1
    4b12:	fa23 f101 	lsr.w	r1, r3, r1
    4b16:	f011 0f01 	tst.w	r1, #1
    4b1a:	d114      	bne.n	4b46 <nrfx_flag32_free+0x3a>
    {
        return NRFX_ERROR_INVALID_PARAM;
    }

    do {
        prev_mask = *p_mask;
    4b1c:	6802      	ldr	r2, [r0, #0]
        new_mask = prev_mask | NRFX_BIT(flag);
    4b1e:	2301      	movs	r3, #1
    4b20:	40a3      	lsls	r3, r4
    4b22:	4313      	orrs	r3, r2
    4b24:	f3bf 8f5b 	dmb	ish
    4b28:	e850 1f00 	ldrex	r1, [r0]
    4b2c:	4291      	cmp	r1, r2
    4b2e:	d104      	bne.n	4b3a <nrfx_flag32_free+0x2e>
    4b30:	e840 3c00 	strex	ip, r3, [r0]
    4b34:	f1bc 0f00 	cmp.w	ip, #0
    4b38:	d1f6      	bne.n	4b28 <nrfx_flag32_free+0x1c>
    4b3a:	f3bf 8f5b 	dmb	ish
    } while (!NRFX_ATOMIC_CAS(p_mask, prev_mask, new_mask));
    4b3e:	d1ed      	bne.n	4b1c <nrfx_flag32_free+0x10>

    return NRFX_SUCCESS;
    4b40:	4802      	ldr	r0, [pc, #8]	; (4b4c <nrfx_flag32_free+0x40>)
}
    4b42:	bc10      	pop	{r4}
    4b44:	4770      	bx	lr
        return NRFX_ERROR_INVALID_PARAM;
    4b46:	4802      	ldr	r0, [pc, #8]	; (4b50 <nrfx_flag32_free+0x44>)
    4b48:	e7fb      	b.n	4b42 <nrfx_flag32_free+0x36>
    4b4a:	bf00      	nop
    4b4c:	0bad0000 	.word	0x0bad0000
    4b50:	0bad0004 	.word	0x0bad0004

00004b54 <nrfx_clock_anomaly_132>:
    uint32_t core_debug;
    uint32_t dwt_ctrl;

    // Preserve DEMCR register to do not influence into its configuration. Enable the trace and
    // debug blocks. It is required to read and write data to DWT block.
    core_debug = CoreDebug->DEMCR;
    4b54:	4b0b      	ldr	r3, [pc, #44]	; (4b84 <nrfx_clock_anomaly_132+0x30>)
    4b56:	68d9      	ldr	r1, [r3, #12]
    CoreDebug->DEMCR = core_debug | CoreDebug_DEMCR_TRCENA_Msk;
    4b58:	f041 7280 	orr.w	r2, r1, #16777216	; 0x1000000
    4b5c:	60da      	str	r2, [r3, #12]

    // Preserve CTRL register in DWT block to do not influence into its configuration. Make sure
    // that cycle counter is enabled.
    dwt_ctrl = DWT->CTRL;
    4b5e:	4b0a      	ldr	r3, [pc, #40]	; (4b88 <nrfx_clock_anomaly_132+0x34>)
    4b60:	6818      	ldr	r0, [r3, #0]
    DWT->CTRL = dwt_ctrl | DWT_CTRL_CYCCNTENA_Msk;
    4b62:	f040 0201 	orr.w	r2, r0, #1
    4b66:	601a      	str	r2, [r3, #0]

    // Store start value of cycle counter.
    cyccnt_inital = DWT->CYCCNT;
    4b68:	685a      	ldr	r2, [r3, #4]

    // Delay required time.
    while ((DWT->CYCCNT - cyccnt_inital) < ANOMALY_132_DELAY_CYCLES)
    4b6a:	4b07      	ldr	r3, [pc, #28]	; (4b88 <nrfx_clock_anomaly_132+0x34>)
    4b6c:	685b      	ldr	r3, [r3, #4]
    4b6e:	1a9b      	subs	r3, r3, r2
    4b70:	f5b3 5f0a 	cmp.w	r3, #8832	; 0x2280
    4b74:	d3f9      	bcc.n	4b6a <nrfx_clock_anomaly_132+0x16>
    {}

    // Restore preserved registers.
    DWT->CTRL = dwt_ctrl;
    4b76:	4b04      	ldr	r3, [pc, #16]	; (4b88 <nrfx_clock_anomaly_132+0x34>)
    4b78:	6018      	str	r0, [r3, #0]
    CoreDebug->DEMCR = core_debug;
    4b7a:	f503 435d 	add.w	r3, r3, #56576	; 0xdd00
    4b7e:	33f0      	adds	r3, #240	; 0xf0
    4b80:	60d9      	str	r1, [r3, #12]
}
    4b82:	4770      	bx	lr
    4b84:	e000edf0 	.word	0xe000edf0
    4b88:	e0001000 	.word	0xe0001000

00004b8c <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    4b8c:	4b06      	ldr	r3, [pc, #24]	; (4ba8 <nrfx_clock_init+0x1c>)
    4b8e:	791b      	ldrb	r3, [r3, #4]
    4b90:	b93b      	cbnz	r3, 4ba2 <nrfx_clock_init+0x16>
    else
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
    4b92:	4b05      	ldr	r3, [pc, #20]	; (4ba8 <nrfx_clock_init+0x1c>)
    4b94:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    4b96:	2201      	movs	r2, #1
    4b98:	711a      	strb	r2, [r3, #4]
#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        m_clock_cb.hfclk_started = false;
    4b9a:	2200      	movs	r2, #0
    4b9c:	715a      	strb	r2, [r3, #5]
    nrfx_err_t err_code = NRFX_SUCCESS;
    4b9e:	4803      	ldr	r0, [pc, #12]	; (4bac <nrfx_clock_init+0x20>)
    4ba0:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    4ba2:	4803      	ldr	r0, [pc, #12]	; (4bb0 <nrfx_clock_init+0x24>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    4ba4:	4770      	bx	lr
    4ba6:	bf00      	nop
    4ba8:	200004d4 	.word	0x200004d4
    4bac:	0bad0000 	.word	0x0bad0000
    4bb0:	0bad000c 	.word	0x0bad000c

00004bb4 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    4bb4:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    4bb6:	b110      	cbz	r0, 4bbe <nrfx_clock_start+0xa>
    4bb8:	2801      	cmp	r0, #1
    4bba:	d027      	beq.n	4c0c <nrfx_clock_start+0x58>
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
    4bbc:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    4bbe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4bc2:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    4bc6:	f003 0303 	and.w	r3, r3, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    4bca:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
    4bce:	f412 3f80 	tst.w	r2, #65536	; 0x10000
    4bd2:	d113      	bne.n	4bfc <nrfx_clock_start+0x48>
    p_reg->LFCLKSRC = (uint32_t)(source);
    4bd4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4bd8:	2200      	movs	r2, #0
    4bda:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4bde:	4b11      	ldr	r3, [pc, #68]	; (4c24 <nrfx_clock_start+0x70>)
    4be0:	2200      	movs	r2, #0
    4be2:	601a      	str	r2, [r3, #0]
    4be4:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    4be6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4bea:	2202      	movs	r2, #2
    4bec:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
            nrfx_clock_anomaly_132();
    4bf0:	f7ff ffb0 	bl	4b54 <nrfx_clock_anomaly_132>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4bf4:	4b0c      	ldr	r3, [pc, #48]	; (4c28 <nrfx_clock_start+0x74>)
    4bf6:	2201      	movs	r2, #1
    4bf8:	601a      	str	r2, [r3, #0]
}
    4bfa:	e7df      	b.n	4bbc <nrfx_clock_start+0x8>
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    4bfc:	2b01      	cmp	r3, #1
    4bfe:	d1e9      	bne.n	4bd4 <nrfx_clock_start+0x20>
    p_reg->LFCLKSRC = (uint32_t)(source);
    4c00:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4c04:	2201      	movs	r2, #1
    4c06:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    4c0a:	e7e8      	b.n	4bde <nrfx_clock_start+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4c0c:	4b07      	ldr	r3, [pc, #28]	; (4c2c <nrfx_clock_start+0x78>)
    4c0e:	2200      	movs	r2, #0
    4c10:	601a      	str	r2, [r3, #0]
    4c12:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    4c14:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4c18:	2201      	movs	r2, #1
    4c1a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4c1e:	601a      	str	r2, [r3, #0]
}
    4c20:	e7cc      	b.n	4bbc <nrfx_clock_start+0x8>
    4c22:	bf00      	nop
    4c24:	40000104 	.word	0x40000104
    4c28:	40000008 	.word	0x40000008
    4c2c:	40000100 	.word	0x40000100

00004c30 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    4c30:	b530      	push	{r4, r5, lr}
    4c32:	b083      	sub	sp, #12
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    4c34:	4604      	mov	r4, r0
    4c36:	b118      	cbz	r0, 4c40 <nrfx_clock_stop+0x10>
    4c38:	2801      	cmp	r0, #1
    4c3a:	d013      	beq.n	4c64 <nrfx_clock_stop+0x34>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    4c3c:	b003      	add	sp, #12
    4c3e:	bd30      	pop	{r4, r5, pc}
    p_reg->INTENCLR = mask;
    4c40:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4c44:	2202      	movs	r2, #2
    4c46:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4c4a:	f503 7382 	add.w	r3, r3, #260	; 0x104
    4c4e:	2200      	movs	r2, #0
    4c50:	601a      	str	r2, [r3, #0]
    4c52:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4c54:	4b39      	ldr	r3, [pc, #228]	; (4d3c <nrfx_clock_stop+0x10c>)
    4c56:	2201      	movs	r2, #1
    4c58:	601a      	str	r2, [r3, #0]
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    4c5a:	2c01      	cmp	r4, #1
    4c5c:	d00f      	beq.n	4c7e <nrfx_clock_stop+0x4e>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    4c5e:	f242 7510 	movw	r5, #10000	; 0x2710
    4c62:	e052      	b.n	4d0a <nrfx_clock_stop+0xda>
    p_reg->INTENCLR = mask;
    4c64:	2301      	movs	r3, #1
    4c66:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4c6a:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4c6e:	f502 7280 	add.w	r2, r2, #256	; 0x100
    4c72:	2100      	movs	r1, #0
    4c74:	6011      	str	r1, [r2, #0]
    4c76:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4c78:	4a31      	ldr	r2, [pc, #196]	; (4d40 <nrfx_clock_stop+0x110>)
    4c7a:	6013      	str	r3, [r2, #0]
}
    4c7c:	e7ed      	b.n	4c5a <nrfx_clock_stop+0x2a>
        nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    4c7e:	2301      	movs	r3, #1
    4c80:	f88d 3007 	strb.w	r3, [sp, #7]
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    4c84:	f242 7510 	movw	r5, #10000	; 0x2710
    4c88:	e018      	b.n	4cbc <nrfx_clock_stop+0x8c>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    4c8a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4c8e:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    4c92:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    4c96:	f8cd 3007 	str.w	r3, [sp, #7]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    4c9a:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
    4c9e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    4ca2:	d120      	bne.n	4ce6 <nrfx_clock_stop+0xb6>
    return false;
    4ca4:	2300      	movs	r3, #0
    4ca6:	2b00      	cmp	r3, #0
    4ca8:	d042      	beq.n	4d30 <nrfx_clock_stop+0x100>
    4caa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    4cae:	2b01      	cmp	r3, #1
    4cb0:	d13e      	bne.n	4d30 <nrfx_clock_stop+0x100>
    4cb2:	2001      	movs	r0, #1
    4cb4:	f003 fb09 	bl	82ca <nrfx_busy_wait>
    4cb8:	3d01      	subs	r5, #1
    4cba:	d039      	beq.n	4d30 <nrfx_clock_stop+0x100>
    switch (domain)
    4cbc:	2c00      	cmp	r4, #0
    4cbe:	d0e4      	beq.n	4c8a <nrfx_clock_stop+0x5a>
    4cc0:	2c01      	cmp	r4, #1
    4cc2:	d001      	beq.n	4cc8 <nrfx_clock_stop+0x98>
    4cc4:	2300      	movs	r3, #0
    4cc6:	e7ee      	b.n	4ca6 <nrfx_clock_stop+0x76>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    4cc8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4ccc:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
    4cd0:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    4cd4:	f88d 3007 	strb.w	r3, [sp, #7]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    4cd8:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
    4cdc:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    4ce0:	d103      	bne.n	4cea <nrfx_clock_stop+0xba>
    return false;
    4ce2:	2300      	movs	r3, #0
    4ce4:	e7df      	b.n	4ca6 <nrfx_clock_stop+0x76>
                return true;
    4ce6:	2301      	movs	r3, #1
    4ce8:	e7dd      	b.n	4ca6 <nrfx_clock_stop+0x76>
                return true;
    4cea:	2301      	movs	r3, #1
    4cec:	e7db      	b.n	4ca6 <nrfx_clock_stop+0x76>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    4cee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4cf2:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
    4cf6:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    4cfa:	d115      	bne.n	4d28 <nrfx_clock_stop+0xf8>
    return false;
    4cfc:	2300      	movs	r3, #0
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    4cfe:	b1bb      	cbz	r3, 4d30 <nrfx_clock_stop+0x100>
    4d00:	2001      	movs	r0, #1
    4d02:	f003 fae2 	bl	82ca <nrfx_busy_wait>
    4d06:	3d01      	subs	r5, #1
    4d08:	d012      	beq.n	4d30 <nrfx_clock_stop+0x100>
    switch (domain)
    4d0a:	2c00      	cmp	r4, #0
    4d0c:	d0ef      	beq.n	4cee <nrfx_clock_stop+0xbe>
    4d0e:	2c01      	cmp	r4, #1
    4d10:	d001      	beq.n	4d16 <nrfx_clock_stop+0xe6>
    4d12:	2300      	movs	r3, #0
    4d14:	e7f3      	b.n	4cfe <nrfx_clock_stop+0xce>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    4d16:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4d1a:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    4d1e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    4d22:	d103      	bne.n	4d2c <nrfx_clock_stop+0xfc>
    return false;
    4d24:	2300      	movs	r3, #0
    4d26:	e7ea      	b.n	4cfe <nrfx_clock_stop+0xce>
                return true;
    4d28:	2301      	movs	r3, #1
    4d2a:	e7e8      	b.n	4cfe <nrfx_clock_stop+0xce>
                return true;
    4d2c:	2301      	movs	r3, #1
    4d2e:	e7e6      	b.n	4cfe <nrfx_clock_stop+0xce>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    4d30:	2c01      	cmp	r4, #1
    4d32:	d183      	bne.n	4c3c <nrfx_clock_stop+0xc>
            m_clock_cb.hfclk_started = false;
    4d34:	4b03      	ldr	r3, [pc, #12]	; (4d44 <nrfx_clock_stop+0x114>)
    4d36:	2200      	movs	r2, #0
    4d38:	715a      	strb	r2, [r3, #5]
    4d3a:	e77f      	b.n	4c3c <nrfx_clock_stop+0xc>
    4d3c:	4000000c 	.word	0x4000000c
    4d40:	40000004 	.word	0x40000004
    4d44:	200004d4 	.word	0x200004d4

00004d48 <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    4d48:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    4d4a:	4b1b      	ldr	r3, [pc, #108]	; (4db8 <nrfx_power_clock_irq_handler+0x70>)
    4d4c:	681b      	ldr	r3, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    4d4e:	b183      	cbz	r3, 4d72 <nrfx_power_clock_irq_handler+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4d50:	4b19      	ldr	r3, [pc, #100]	; (4db8 <nrfx_power_clock_irq_handler+0x70>)
    4d52:	2200      	movs	r2, #0
    4d54:	601a      	str	r2, [r3, #0]
    4d56:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    4d58:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4d5c:	2201      	movs	r2, #1
    4d5e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
    4d62:	4b16      	ldr	r3, [pc, #88]	; (4dbc <nrfx_power_clock_irq_handler+0x74>)
    4d64:	795b      	ldrb	r3, [r3, #5]
    4d66:	b923      	cbnz	r3, 4d72 <nrfx_power_clock_irq_handler+0x2a>
        {
            m_clock_cb.hfclk_started = true;
    4d68:	4b14      	ldr	r3, [pc, #80]	; (4dbc <nrfx_power_clock_irq_handler+0x74>)
    4d6a:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    4d6c:	681b      	ldr	r3, [r3, #0]
    4d6e:	2000      	movs	r0, #0
    4d70:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    4d72:	4b13      	ldr	r3, [pc, #76]	; (4dc0 <nrfx_power_clock_irq_handler+0x78>)
    4d74:	681b      	ldr	r3, [r3, #0]
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    4d76:	b19b      	cbz	r3, 4da0 <nrfx_power_clock_irq_handler+0x58>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    4d78:	4b11      	ldr	r3, [pc, #68]	; (4dc0 <nrfx_power_clock_irq_handler+0x78>)
    4d7a:	2200      	movs	r2, #0
    4d7c:	601a      	str	r2, [r3, #0]
    4d7e:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    4d80:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4d84:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    4d88:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    4d8c:	f012 0f03 	tst.w	r2, #3
    4d90:	d107      	bne.n	4da2 <nrfx_power_clock_irq_handler+0x5a>
    p_reg->LFCLKSRC = (uint32_t)(source);
    4d92:	2301      	movs	r3, #1
    4d94:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    4d98:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4d9c:	3208      	adds	r2, #8
    4d9e:	6013      	str	r3, [r2, #0]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    4da0:	bd08      	pop	{r3, pc}
    p_reg->INTENCLR = mask;
    4da2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    4da6:	2202      	movs	r2, #2
    4da8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    4dac:	4b03      	ldr	r3, [pc, #12]	; (4dbc <nrfx_power_clock_irq_handler+0x74>)
    4dae:	681b      	ldr	r3, [r3, #0]
    4db0:	2001      	movs	r0, #1
    4db2:	4798      	blx	r3
}
    4db4:	e7f4      	b.n	4da0 <nrfx_power_clock_irq_handler+0x58>
    4db6:	bf00      	nop
    4db8:	40000100 	.word	0x40000100
    4dbc:	200004d4 	.word	0x200004d4
    4dc0:	40000104 	.word	0x40000104

00004dc4 <pin_in_use>:
 *
 * @return True if pin is in use.
 */
static bool pin_in_use(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_IN_USE;
    4dc4:	3008      	adds	r0, #8
    4dc6:	4b03      	ldr	r3, [pc, #12]	; (4dd4 <pin_in_use+0x10>)
    4dc8:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    4dcc:	f000 0001 	and.w	r0, r0, #1
    4dd0:	4770      	bx	lr
    4dd2:	bf00      	nop
    4dd4:	20000090 	.word	0x20000090

00004dd8 <pin_in_use_by_te>:
 *
 * @return True if pin uses GPIOTE task/event.
 */
static bool pin_in_use_by_te(uint32_t pin)
{
    return m_cb.pin_flags[pin] & PIN_FLAG_TE_USED;
    4dd8:	3008      	adds	r0, #8
    4dda:	4b03      	ldr	r3, [pc, #12]	; (4de8 <pin_in_use_by_te+0x10>)
    4ddc:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    4de0:	f3c0 1040 	ubfx	r0, r0, #5, #1
    4de4:	4770      	bx	lr
    4de6:	bf00      	nop
    4de8:	20000090 	.word	0x20000090

00004dec <pin_has_trigger>:
 *
 * @return True if pin has trigger.
 */
static bool pin_has_trigger(uint32_t pin)
{
    return PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]) != NRFX_GPIOTE_TRIGGER_NONE;
    4dec:	3008      	adds	r0, #8
    4dee:	4b04      	ldr	r3, [pc, #16]	; (4e00 <pin_has_trigger+0x14>)
    4df0:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    4df4:	f010 001c 	ands.w	r0, r0, #28
    4df8:	bf18      	it	ne
    4dfa:	2001      	movne	r0, #1
    4dfc:	4770      	bx	lr
    4dfe:	bf00      	nop
    4e00:	20000090 	.word	0x20000090

00004e04 <pin_is_output>:
 *
 * @return True if pin is output.
 */
static bool pin_is_output(uint32_t pin)
{
    return PIN_FLAG_IS_OUTPUT(m_cb.pin_flags[pin]);
    4e04:	3008      	adds	r0, #8
    4e06:	4b03      	ldr	r3, [pc, #12]	; (4e14 <pin_is_output+0x10>)
    4e08:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    4e0c:	f3c0 0040 	ubfx	r0, r0, #1, #1
    4e10:	4770      	bx	lr
    4e12:	bf00      	nop
    4e14:	20000090 	.word	0x20000090

00004e18 <pin_te_get>:
}

/* Returns gpiote TE channel associated with the pin */
static uint8_t pin_te_get(nrfx_gpiote_pin_t pin)
{
    return PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    4e18:	3008      	adds	r0, #8
    4e1a:	4b02      	ldr	r3, [pc, #8]	; (4e24 <pin_te_get+0xc>)
    4e1c:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
}
    4e20:	0b40      	lsrs	r0, r0, #13
    4e22:	4770      	bx	lr
    4e24:	20000090 	.word	0x20000090

00004e28 <handler_in_use>:
}

static bool handler_in_use(int32_t handler_id)
{

    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    4e28:	2200      	movs	r2, #0
    4e2a:	e004      	b.n	4e36 <handler_in_use+0xe>
    {
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    4e2c:	f04f 33ff 	mov.w	r3, #4294967295
    4e30:	4283      	cmp	r3, r0
    4e32:	d00f      	beq.n	4e54 <handler_in_use+0x2c>
    for (uint32_t i = 0; i < MAX_PIN_NUMBER; i++)
    4e34:	3201      	adds	r2, #1
    4e36:	2a1f      	cmp	r2, #31
    4e38:	d80a      	bhi.n	4e50 <handler_in_use+0x28>
        if (PIN_GET_HANDLER_ID(m_cb.pin_flags[i]) == handler_id)
    4e3a:	f102 0308 	add.w	r3, r2, #8
    4e3e:	4906      	ldr	r1, [pc, #24]	; (4e58 <handler_in_use+0x30>)
    4e40:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    4e44:	f413 7f80 	tst.w	r3, #256	; 0x100
    4e48:	d0f0      	beq.n	4e2c <handler_in_use+0x4>
    4e4a:	f3c3 2343 	ubfx	r3, r3, #9, #4
    4e4e:	e7ef      	b.n	4e30 <handler_in_use+0x8>
        {
            return true;
        }
    }

    return false;
    4e50:	2000      	movs	r0, #0
    4e52:	4770      	bx	lr
            return true;
    4e54:	2001      	movs	r0, #1
}
    4e56:	4770      	bx	lr
    4e58:	20000090 	.word	0x20000090

00004e5c <find_handler>:
    return NRFX_SUCCESS;
}

static int32_t find_handler(nrfx_gpiote_interrupt_handler_t handler, void * p_context)
{
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
    4e5c:	2300      	movs	r3, #0
    4e5e:	b113      	cbz	r3, 4e66 <find_handler+0xa>
        {
            return i;
        }
    }

    return -1;
    4e60:	f04f 30ff 	mov.w	r0, #4294967295
}
    4e64:	4770      	bx	lr
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    4e66:	4a07      	ldr	r2, [pc, #28]	; (4e84 <find_handler+0x28>)
    4e68:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
    4e6c:	4282      	cmp	r2, r0
    4e6e:	d001      	beq.n	4e74 <find_handler+0x18>
    for (uint32_t i = 0; i < NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS; i++)
    4e70:	3301      	adds	r3, #1
    4e72:	e7f4      	b.n	4e5e <find_handler+0x2>
        if ((m_cb.handlers[i].handler == handler) && (m_cb.handlers[i].p_context == p_context))
    4e74:	4a03      	ldr	r2, [pc, #12]	; (4e84 <find_handler+0x28>)
    4e76:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    4e7a:	6852      	ldr	r2, [r2, #4]
    4e7c:	428a      	cmp	r2, r1
    4e7e:	d1f7      	bne.n	4e70 <find_handler+0x14>
            return i;
    4e80:	4618      	mov	r0, r3
    4e82:	4770      	bx	lr
    4e84:	20000090 	.word	0x20000090

00004e88 <channel_handler_get>:
}

/* Return handler associated with given pin or null. */
static nrfx_gpiote_handler_config_t const * channel_handler_get(nrfx_gpiote_pin_t pin)
{
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    4e88:	3008      	adds	r0, #8
    4e8a:	4b06      	ldr	r3, [pc, #24]	; (4ea4 <channel_handler_get+0x1c>)
    4e8c:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
    4e90:	f410 7f80 	tst.w	r0, #256	; 0x100
    4e94:	d004      	beq.n	4ea0 <channel_handler_get+0x18>
    4e96:	f3c0 2043 	ubfx	r0, r0, #9, #4
    if (handler_id == PIN_FLAG_NO_HANDLER)
    {
        return NULL;
    }

    return &m_cb.handlers[handler_id];
    4e9a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    4e9e:	4770      	bx	lr
        return NULL;
    4ea0:	2000      	movs	r0, #0
}
    4ea2:	4770      	bx	lr
    4ea4:	20000090 	.word	0x20000090

00004ea8 <call_handler>:
    nrf_gpiote_event_t event = nrfx_gpiote_in_event_get(pin);
    return nrf_gpiote_event_address_get(NRF_GPIOTE, event);
}

static void call_handler(nrfx_gpiote_pin_t pin, nrfx_gpiote_trigger_t trigger)
{
    4ea8:	b570      	push	{r4, r5, r6, lr}
    4eaa:	4604      	mov	r4, r0
    4eac:	460d      	mov	r5, r1
    nrfx_gpiote_handler_config_t const * handler = channel_handler_get(pin);
    4eae:	f7ff ffeb 	bl	4e88 <channel_handler_get>

    if (handler)
    4eb2:	b120      	cbz	r0, 4ebe <call_handler+0x16>
    {
        handler->handler(pin, trigger, handler->p_context);
    4eb4:	6806      	ldr	r6, [r0, #0]
    4eb6:	6842      	ldr	r2, [r0, #4]
    4eb8:	4629      	mov	r1, r5
    4eba:	4620      	mov	r0, r4
    4ebc:	47b0      	blx	r6
    }
    if (m_cb.global_handler.handler)
    4ebe:	4b04      	ldr	r3, [pc, #16]	; (4ed0 <call_handler+0x28>)
    4ec0:	689b      	ldr	r3, [r3, #8]
    4ec2:	b123      	cbz	r3, 4ece <call_handler+0x26>
    {
        m_cb.global_handler.handler(pin, trigger, m_cb.global_handler.p_context);
    4ec4:	4a02      	ldr	r2, [pc, #8]	; (4ed0 <call_handler+0x28>)
    4ec6:	68d2      	ldr	r2, [r2, #12]
    4ec8:	4629      	mov	r1, r5
    4eca:	4620      	mov	r0, r4
    4ecc:	4798      	blx	r3
    }
}
    4ece:	bd70      	pop	{r4, r5, r6, pc}
    4ed0:	20000090 	.word	0x20000090

00004ed4 <release_handler>:
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    4ed4:	f100 0208 	add.w	r2, r0, #8
    4ed8:	4b0e      	ldr	r3, [pc, #56]	; (4f14 <release_handler+0x40>)
    4eda:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    4ede:	f413 7f80 	tst.w	r3, #256	; 0x100
    4ee2:	d016      	beq.n	4f12 <release_handler+0x3e>
{
    4ee4:	b510      	push	{r4, lr}
    int32_t handler_id = PIN_GET_HANDLER_ID(m_cb.pin_flags[pin]);
    4ee6:	f3c3 2443 	ubfx	r4, r3, #9, #4
    m_cb.pin_flags[pin] &= ~PIN_HANDLER_MASK;
    4eea:	4610      	mov	r0, r2
    4eec:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
    4ef0:	4a08      	ldr	r2, [pc, #32]	; (4f14 <release_handler+0x40>)
    4ef2:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    if (!handler_in_use(handler_id))
    4ef6:	4620      	mov	r0, r4
    4ef8:	f7ff ff96 	bl	4e28 <handler_in_use>
    4efc:	b100      	cbz	r0, 4f00 <release_handler+0x2c>
}
    4efe:	bd10      	pop	{r4, pc}
        m_cb.handlers[handler_id].handler = NULL;
    4f00:	4804      	ldr	r0, [pc, #16]	; (4f14 <release_handler+0x40>)
    4f02:	2300      	movs	r3, #0
    4f04:	f840 3034 	str.w	r3, [r0, r4, lsl #3]
        nrfx_err_t err = nrfx_flag32_free(&m_cb.available_evt_handlers, handler_id);
    4f08:	4621      	mov	r1, r4
    4f0a:	3054      	adds	r0, #84	; 0x54
    4f0c:	f7ff fdfe 	bl	4b0c <nrfx_flag32_free>
        NRFX_ASSERT(err == NRFX_SUCCESS);
    4f10:	e7f5      	b.n	4efe <release_handler+0x2a>
    4f12:	4770      	bx	lr
    4f14:	20000090 	.word	0x20000090

00004f18 <pin_handler_trigger_uninit>:
{
    4f18:	b510      	push	{r4, lr}
    4f1a:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin))
    4f1c:	f7ff ff5c 	bl	4dd8 <pin_in_use_by_te>
    4f20:	b140      	cbz	r0, 4f34 <pin_handler_trigger_uninit+0x1c>
        nrf_gpiote_te_default(NRF_GPIOTE, pin_te_get(pin));
    4f22:	4620      	mov	r0, r4
    4f24:	f7ff ff78 	bl	4e18 <pin_te_get>
                         ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
}

NRF_STATIC_INLINE void nrf_gpiote_te_default(NRF_GPIOTE_Type * p_reg, uint32_t idx)
{
    p_reg->CONFIG[idx] = 0;
    4f28:	f500 70a2 	add.w	r0, r0, #324	; 0x144
    4f2c:	4b06      	ldr	r3, [pc, #24]	; (4f48 <pin_handler_trigger_uninit+0x30>)
    4f2e:	2200      	movs	r2, #0
    4f30:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
    release_handler(pin);
    4f34:	4620      	mov	r0, r4
    4f36:	f7ff ffcd 	bl	4ed4 <release_handler>
    m_cb.pin_flags[pin] = PIN_FLAG_NOT_USED;
    4f3a:	3408      	adds	r4, #8
    4f3c:	4b03      	ldr	r3, [pc, #12]	; (4f4c <pin_handler_trigger_uninit+0x34>)
    4f3e:	2200      	movs	r2, #0
    4f40:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
}
    4f44:	bd10      	pop	{r4, pc}
    4f46:	bf00      	nop
    4f48:	40006000 	.word	0x40006000
    4f4c:	20000090 	.word	0x20000090

00004f50 <pin_handler_set>:
{
    4f50:	b570      	push	{r4, r5, r6, lr}
    4f52:	b082      	sub	sp, #8
    4f54:	4606      	mov	r6, r0
    4f56:	460c      	mov	r4, r1
    4f58:	4615      	mov	r5, r2
    release_handler(pin);
    4f5a:	f7ff ffbb 	bl	4ed4 <release_handler>
    if (!handler)
    4f5e:	b324      	cbz	r4, 4faa <pin_handler_set+0x5a>
    handler_id = find_handler(handler, p_context);
    4f60:	4629      	mov	r1, r5
    4f62:	4620      	mov	r0, r4
    4f64:	f7ff ff7a 	bl	4e5c <find_handler>
    if (handler_id < 0)
    4f68:	1e03      	subs	r3, r0, #0
    4f6a:	db13      	blt.n	4f94 <pin_handler_set+0x44>
    m_cb.handlers[handler_id].handler = handler;
    4f6c:	4a10      	ldr	r2, [pc, #64]	; (4fb0 <pin_handler_set+0x60>)
    4f6e:	f842 4033 	str.w	r4, [r2, r3, lsl #3]
    m_cb.handlers[handler_id].p_context = p_context;
    4f72:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
    4f76:	604d      	str	r5, [r1, #4]
    m_cb.pin_flags[pin] |= PIN_FLAG_HANDLER(handler_id);
    4f78:	025b      	lsls	r3, r3, #9
    4f7a:	b29b      	uxth	r3, r3
    4f7c:	f106 0008 	add.w	r0, r6, #8
    4f80:	f832 1010 	ldrh.w	r1, [r2, r0, lsl #1]
    4f84:	430b      	orrs	r3, r1
    4f86:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    4f8a:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
    return NRFX_SUCCESS;
    4f8e:	4809      	ldr	r0, [pc, #36]	; (4fb4 <pin_handler_set+0x64>)
}
    4f90:	b002      	add	sp, #8
    4f92:	bd70      	pop	{r4, r5, r6, pc}
        err = nrfx_flag32_alloc(&m_cb.available_evt_handlers, &id);
    4f94:	f10d 0107 	add.w	r1, sp, #7
    4f98:	4807      	ldr	r0, [pc, #28]	; (4fb8 <pin_handler_set+0x68>)
    4f9a:	f7ff fd93 	bl	4ac4 <nrfx_flag32_alloc>
        if (err != NRFX_SUCCESS)
    4f9e:	4b05      	ldr	r3, [pc, #20]	; (4fb4 <pin_handler_set+0x64>)
    4fa0:	4298      	cmp	r0, r3
    4fa2:	d1f5      	bne.n	4f90 <pin_handler_set+0x40>
        handler_id = (int32_t)id;
    4fa4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    4fa8:	e7e0      	b.n	4f6c <pin_handler_set+0x1c>
        return NRFX_SUCCESS;
    4faa:	4802      	ldr	r0, [pc, #8]	; (4fb4 <pin_handler_set+0x64>)
    4fac:	e7f0      	b.n	4f90 <pin_handler_set+0x40>
    4fae:	bf00      	nop
    4fb0:	20000090 	.word	0x20000090
    4fb4:	0bad0000 	.word	0x0bad0000
    4fb8:	200000e4 	.word	0x200000e4

00004fbc <port_event_handle>:
    }
    return false;
}

static void port_event_handle(void)
{
    4fbc:	b5f0      	push	{r4, r5, r6, r7, lr}
    4fbe:	b083      	sub	sp, #12
    for (i = start_port; i < (start_port + length); i++)
    4fc0:	2300      	movs	r3, #0
    4fc2:	a801      	add	r0, sp, #4
    4fc4:	e008      	b.n	4fd8 <port_event_handle+0x1c>
        *p_masks = gpio_regs[i]->LATCH;
    4fc6:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    4fca:	f8d2 1520 	ldr.w	r1, [r2, #1312]	; 0x520
    4fce:	f840 1b04 	str.w	r1, [r0], #4
        gpio_regs[i]->LATCH = *p_masks;
    4fd2:	f8c2 1520 	str.w	r1, [r2, #1312]	; 0x520
    for (i = start_port; i < (start_port + length); i++)
    4fd6:	3301      	adds	r3, #1
    4fd8:	2b00      	cmp	r3, #0
    4fda:	d0f4      	beq.n	4fc6 <port_event_handle+0xa>
    4fdc:	e038      	b.n	5050 <port_event_handle+0x94>
    nrf_gpio_latches_read_and_clear(0, GPIO_COUNT, latch);

    do {
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
        {
            while (latch[i])
    4fde:	ab02      	add	r3, sp, #8
    4fe0:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    4fe4:	f853 0c04 	ldr.w	r0, [r3, #-4]
    4fe8:	b338      	cbz	r0, 503a <port_event_handle+0x7e>
            {
                uint32_t pin = NRF_CTZ(latch[i]);
    4fea:	fa90 f0a0 	rbit	r0, r0
    4fee:	fab0 f080 	clz	r0, r0

                /* Convert to absolute value. */
                pin += 32 * i;
    4ff2:	eb00 1045 	add.w	r0, r0, r5, lsl #5
                nrf_gpio_pin_sense_t sense;
                nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    4ff6:	f100 0208 	add.w	r2, r0, #8
    4ffa:	4b17      	ldr	r3, [pc, #92]	; (5058 <port_event_handle+0x9c>)
    4ffc:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
 * @param[in,out] p_mask Pointer to mask with bit fields.
 */
__STATIC_INLINE void nrf_bitmask_bit_clear(uint32_t bit, void * p_mask)
{
    uint8_t * p_mask8 = (uint8_t *)p_mask;
    uint32_t byte_idx = BITMASK_BYTE_GET(bit);
    5000:	08c6      	lsrs	r6, r0, #3
    bit = BITMASK_RELBIT_GET(bit);
    5002:	f000 0307 	and.w	r3, r0, #7
    p_mask8[byte_idx] &= ~(1 << bit);
    5006:	af01      	add	r7, sp, #4
    5008:	2401      	movs	r4, #1
    500a:	fa04 f203 	lsl.w	r2, r4, r3
    500e:	5dbb      	ldrb	r3, [r7, r6]
    5010:	ea23 0302 	bic.w	r3, r3, r2
    5014:	55bb      	strb	r3, [r7, r6]
    *p_pin = pin_number & 0x1F;
    5016:	f000 071f 	and.w	r7, r0, #31
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    501a:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
    501e:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
    5022:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]

                nrf_bitmask_bit_clear(pin, latch);
                sense = nrf_gpio_pin_sense_get(pin);

                next_sense_cond_call_handler(pin, trigger, sense);
    5026:	f3c2 4201 	ubfx	r2, r2, #16, #2
    502a:	f3c1 0182 	ubfx	r1, r1, #2, #3
    502e:	f003 f976 	bl	831e <next_sense_cond_call_handler>
    reg->LATCH = (1 << pin_number);
    5032:	40bc      	lsls	r4, r7
    5034:	f8c6 4520 	str.w	r4, [r6, #1312]	; 0x520
}
    5038:	e7d1      	b.n	4fde <port_event_handle+0x22>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    503a:	3501      	adds	r5, #1
    503c:	2d00      	cmp	r5, #0
    503e:	d0ce      	beq.n	4fde <port_event_handle+0x22>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    5040:	4b06      	ldr	r3, [pc, #24]	; (505c <port_event_handle+0xa0>)
    5042:	2200      	movs	r2, #0
    5044:	601a      	str	r2, [r3, #0]
    5046:	681b      	ldr	r3, [r3, #0]
        }

        /* All pins have been handled, clear PORT, check latch again in case
         * something came between deciding to exit and clearing PORT event. */
        nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
    } while (latch_pending_read_and_check(latch));
    5048:	a801      	add	r0, sp, #4
    504a:	f003 f9b6 	bl	83ba <latch_pending_read_and_check>
    504e:	b108      	cbz	r0, 5054 <port_event_handle+0x98>
        for (uint32_t i = 0; i < GPIO_COUNT; i++)
    5050:	2500      	movs	r5, #0
    5052:	e7f3      	b.n	503c <port_event_handle+0x80>
}
    5054:	b003      	add	sp, #12
    5056:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5058:	20000090 	.word	0x20000090
    505c:	4000617c 	.word	0x4000617c

00005060 <gpiote_evt_handle>:
    } while (input_read_and_check(input, pins_to_check));
}
#endif // defined(NRF_GPIO_LATCH_PRESENT)

static void gpiote_evt_handle(uint32_t mask)
{
    5060:	b538      	push	{r3, r4, r5, lr}
    5062:	4604      	mov	r4, r0
    while (mask)
    5064:	b1cc      	cbz	r4, 509a <gpiote_evt_handle+0x3a>
    {
        uint32_t ch = NRF_CTZ(mask);
    5066:	fa94 f3a4 	rbit	r3, r4
    506a:	fab3 f383 	clz	r3, r3
        mask &= ~NRFX_BIT(ch);
    506e:	2201      	movs	r2, #1
    5070:	409a      	lsls	r2, r3
    5072:	ea24 0402 	bic.w	r4, r4, r2
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    5076:	4a09      	ldr	r2, [pc, #36]	; (509c <gpiote_evt_handle+0x3c>)
    5078:	f503 73a2 	add.w	r3, r3, #324	; 0x144
    507c:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
    5080:	f3c5 2504 	ubfx	r5, r5, #8, #5
    return (nrf_gpiote_polarity_t)((p_reg->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >>
    5084:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
        nrfx_gpiote_pin_t pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, ch);
        nrf_gpiote_polarity_t polarity = nrf_gpiote_event_polarity_get(NRF_GPIOTE, ch);

        call_handler(pin, gpiote_polarity_to_trigger(polarity));
    5088:	f3c0 4001 	ubfx	r0, r0, #16, #2
    508c:	f003 f940 	bl	8310 <gpiote_polarity_to_trigger>
    5090:	4601      	mov	r1, r0
    5092:	4628      	mov	r0, r5
    5094:	f7ff ff08 	bl	4ea8 <call_handler>
    5098:	e7e4      	b.n	5064 <gpiote_evt_handle+0x4>
    }
}
    509a:	bd38      	pop	{r3, r4, r5, pc}
    509c:	40006000 	.word	0x40006000

000050a0 <nrfx_gpiote_input_configure>:
{
    50a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    50a4:	4604      	mov	r4, r0
    50a6:	4615      	mov	r5, r2
    50a8:	461e      	mov	r6, r3
    if (p_input_config)
    50aa:	b359      	cbz	r1, 5104 <nrfx_gpiote_input_configure+0x64>
    50ac:	460f      	mov	r7, r1
        if (pin_is_task_output(pin))
    50ae:	f003 f919 	bl	82e4 <pin_is_task_output>
    50b2:	2800      	cmp	r0, #0
    50b4:	f040 8094 	bne.w	51e0 <nrfx_gpiote_input_configure+0x140>
    *p_pin = pin_number & 0x1F;
    50b8:	f004 021f 	and.w	r2, r4, #31
    uint32_t cnf = reg->PIN_CNF[pin_number];
    50bc:	f502 71e0 	add.w	r1, r2, #448	; 0x1c0
    50c0:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    50c4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    50c8:	2f00      	cmp	r7, #0
    50ca:	d03c      	beq.n	5146 <nrfx_gpiote_input_configure+0xa6>
    50cc:	210c      	movs	r1, #12
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    50ce:	f041 0103 	orr.w	r1, r1, #3
    cnf &= ~to_update;
    50d2:	ea23 0301 	bic.w	r3, r3, r1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    50d6:	2f00      	cmp	r7, #0
    50d8:	d037      	beq.n	514a <nrfx_gpiote_input_configure+0xaa>
    50da:	7839      	ldrb	r1, [r7, #0]
    50dc:	0089      	lsls	r1, r1, #2
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    50de:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
    50e0:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    50e4:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    50e8:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        m_cb.pin_flags[pin] &= ~PIN_FLAG_OUTPUT;
    50ec:	4a40      	ldr	r2, [pc, #256]	; (51f0 <nrfx_gpiote_input_configure+0x150>)
    50ee:	f104 0108 	add.w	r1, r4, #8
    50f2:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    50f6:	f023 0302 	bic.w	r3, r3, #2
    50fa:	b29b      	uxth	r3, r3
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE;
    50fc:	f043 0301 	orr.w	r3, r3, #1
    5100:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_trigger_config)
    5104:	b1b5      	cbz	r5, 5134 <nrfx_gpiote_input_configure+0x94>
        nrfx_gpiote_trigger_t trigger = p_trigger_config->trigger;
    5106:	f895 8000 	ldrb.w	r8, [r5]
        bool use_evt = p_trigger_config->p_in_channel ? true : false;
    510a:	f8d5 9004 	ldr.w	r9, [r5, #4]
        if (pin_is_output(pin))
    510e:	4620      	mov	r0, r4
    5110:	f7ff fe78 	bl	4e04 <pin_is_output>
    5114:	b1d8      	cbz	r0, 514e <nrfx_gpiote_input_configure+0xae>
            if (use_evt)
    5116:	f1b9 0f00 	cmp.w	r9, #0
    511a:	d163      	bne.n	51e4 <nrfx_gpiote_input_configure+0x144>
        m_cb.pin_flags[pin] &= ~PIN_FLAG_TRIG_MODE_MASK;
    511c:	4b34      	ldr	r3, [pc, #208]	; (51f0 <nrfx_gpiote_input_configure+0x150>)
    511e:	f104 0208 	add.w	r2, r4, #8
    5122:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
    5126:	f020 001c 	bic.w	r0, r0, #28
    512a:	b280      	uxth	r0, r0
        m_cb.pin_flags[pin] |= PIN_FLAG_TRIG_MODE_SET(trigger);
    512c:	ea40 0088 	orr.w	r0, r0, r8, lsl #2
    5130:	f823 0012 	strh.w	r0, [r3, r2, lsl #1]
    if (p_handler_config)
    5134:	2e00      	cmp	r6, #0
    5136:	d059      	beq.n	51ec <nrfx_gpiote_input_configure+0x14c>
        err = pin_handler_set(pin, p_handler_config->handler, p_handler_config->p_context);
    5138:	6872      	ldr	r2, [r6, #4]
    513a:	6831      	ldr	r1, [r6, #0]
    513c:	4620      	mov	r0, r4
    513e:	f7ff ff07 	bl	4f50 <pin_handler_set>
}
    5142:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    5146:	2100      	movs	r1, #0
    5148:	e7c1      	b.n	50ce <nrfx_gpiote_input_configure+0x2e>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    514a:	2100      	movs	r1, #0
    514c:	e7c7      	b.n	50de <nrfx_gpiote_input_configure+0x3e>
            m_cb.pin_flags[pin] &= ~(PIN_TE_ID_MASK | PIN_FLAG_TE_USED);
    514e:	4b28      	ldr	r3, [pc, #160]	; (51f0 <nrfx_gpiote_input_configure+0x150>)
    5150:	f104 0208 	add.w	r2, r4, #8
    5154:	f833 7012 	ldrh.w	r7, [r3, r2, lsl #1]
    5158:	f027 0720 	bic.w	r7, r7, #32
    515c:	04ff      	lsls	r7, r7, #19
    515e:	0cff      	lsrs	r7, r7, #19
    5160:	f823 7012 	strh.w	r7, [r3, r2, lsl #1]
            if (use_evt)
    5164:	f1b9 0f00 	cmp.w	r9, #0
    5168:	d0d8      	beq.n	511c <nrfx_gpiote_input_configure+0x7c>
                if (!edge)
    516a:	f1b8 0f03 	cmp.w	r8, #3
    516e:	d83b      	bhi.n	51e8 <nrfx_gpiote_input_configure+0x148>
                uint8_t ch = *p_trigger_config->p_in_channel;
    5170:	686b      	ldr	r3, [r5, #4]
    5172:	781d      	ldrb	r5, [r3, #0]
                if (trigger == NRFX_GPIOTE_TRIGGER_NONE)
    5174:	f1b8 0f00 	cmp.w	r8, #0
    5178:	d106      	bne.n	5188 <nrfx_gpiote_input_configure+0xe8>
    p_reg->CONFIG[idx] = 0;
    517a:	f505 75a2 	add.w	r5, r5, #324	; 0x144
    517e:	4b1d      	ldr	r3, [pc, #116]	; (51f4 <nrfx_gpiote_input_configure+0x154>)
    5180:	2200      	movs	r2, #0
    5182:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
#if defined(NRF9160_XXAA) || defined(NRF5340_XXAA)
    p_reg->CONFIG[idx] = 0;
#endif
}
    5186:	e7c9      	b.n	511c <nrfx_gpiote_input_configure+0x7c>
                    nrf_gpiote_polarity_t polarity = gpiote_trigger_to_polarity(trigger);
    5188:	4640      	mov	r0, r8
    518a:	f003 f8c2 	bl	8312 <gpiote_trigger_to_polarity>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    518e:	4b19      	ldr	r3, [pc, #100]	; (51f4 <nrfx_gpiote_input_configure+0x154>)
    5190:	f505 72a2 	add.w	r2, r5, #324	; 0x144
    5194:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    5198:	f021 0103 	bic.w	r1, r1, #3
    519c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    51a0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    51a4:	f421 3147 	bic.w	r1, r1, #203776	; 0x31c00
    51a8:	f421 7140 	bic.w	r1, r1, #768	; 0x300
    51ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    51b0:	f853 c022 	ldr.w	ip, [r3, r2, lsl #2]
    51b4:	0221      	lsls	r1, r4, #8
    51b6:	f401 51f8 	and.w	r1, r1, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
    51ba:	0400      	lsls	r0, r0, #16
    51bc:	f400 3040 	and.w	r0, r0, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    51c0:	4301      	orrs	r1, r0
    51c2:	ea4c 0101 	orr.w	r1, ip, r1
    51c6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                    m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    51ca:	036d      	lsls	r5, r5, #13
    51cc:	b2ad      	uxth	r5, r5
    51ce:	f104 0308 	add.w	r3, r4, #8
    51d2:	432f      	orrs	r7, r5
    51d4:	f047 0720 	orr.w	r7, r7, #32
    51d8:	4a05      	ldr	r2, [pc, #20]	; (51f0 <nrfx_gpiote_input_configure+0x150>)
    51da:	f822 7013 	strh.w	r7, [r2, r3, lsl #1]
    51de:	e79d      	b.n	511c <nrfx_gpiote_input_configure+0x7c>
            return NRFX_ERROR_INVALID_PARAM;
    51e0:	4805      	ldr	r0, [pc, #20]	; (51f8 <nrfx_gpiote_input_configure+0x158>)
    51e2:	e7ae      	b.n	5142 <nrfx_gpiote_input_configure+0xa2>
                return NRFX_ERROR_INVALID_PARAM;
    51e4:	4804      	ldr	r0, [pc, #16]	; (51f8 <nrfx_gpiote_input_configure+0x158>)
    51e6:	e7ac      	b.n	5142 <nrfx_gpiote_input_configure+0xa2>
                    return NRFX_ERROR_INVALID_PARAM;
    51e8:	4803      	ldr	r0, [pc, #12]	; (51f8 <nrfx_gpiote_input_configure+0x158>)
    51ea:	e7aa      	b.n	5142 <nrfx_gpiote_input_configure+0xa2>
        err = NRFX_SUCCESS;
    51ec:	4803      	ldr	r0, [pc, #12]	; (51fc <nrfx_gpiote_input_configure+0x15c>)
    51ee:	e7a8      	b.n	5142 <nrfx_gpiote_input_configure+0xa2>
    51f0:	20000090 	.word	0x20000090
    51f4:	40006000 	.word	0x40006000
    51f8:	0bad0004 	.word	0x0bad0004
    51fc:	0bad0000 	.word	0x0bad0000

00005200 <nrfx_gpiote_output_configure>:
{
    5200:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5202:	4604      	mov	r4, r0
    5204:	4616      	mov	r6, r2
    if (p_config)
    5206:	2900      	cmp	r1, #0
    5208:	d04d      	beq.n	52a6 <nrfx_gpiote_output_configure+0xa6>
    520a:	460d      	mov	r5, r1
        if (pin_is_input(pin) && pin_in_use_by_te(pin))
    520c:	f003 f879 	bl	8302 <pin_is_input>
    5210:	b128      	cbz	r0, 521e <nrfx_gpiote_output_configure+0x1e>
    5212:	4620      	mov	r0, r4
    5214:	f7ff fde0 	bl	4dd8 <pin_in_use_by_te>
    5218:	2800      	cmp	r0, #0
    521a:	f040 8096 	bne.w	534a <nrfx_gpiote_output_configure+0x14a>
        if (pin_has_trigger(pin) && (p_config->input_connect == NRF_GPIO_PIN_INPUT_DISCONNECT))
    521e:	4620      	mov	r0, r4
    5220:	f7ff fde4 	bl	4dec <pin_has_trigger>
    5224:	b118      	cbz	r0, 522e <nrfx_gpiote_output_configure+0x2e>
    5226:	786b      	ldrb	r3, [r5, #1]
    5228:	2b01      	cmp	r3, #1
    522a:	f000 8090 	beq.w	534e <nrfx_gpiote_output_configure+0x14e>
        nrf_gpio_reconfigure(pin, &dir, &p_config->input_connect, &p_config->pull,
    522e:	1ca8      	adds	r0, r5, #2
    *p_pin = pin_number & 0x1F;
    5230:	f004 021f 	and.w	r2, r4, #31
    uint32_t cnf = reg->PIN_CNF[pin_number];
    5234:	f502 71e0 	add.w	r1, r2, #448	; 0x1c0
    5238:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    523c:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    5240:	1c6f      	adds	r7, r5, #1
    5242:	d074      	beq.n	532e <nrfx_gpiote_output_configure+0x12e>
    5244:	2302      	movs	r3, #2
    uint32_t to_update = (p_dir   ? GPIO_PIN_CNF_DIR_Msk   : 0) |
    5246:	f043 0301 	orr.w	r3, r3, #1
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    524a:	2800      	cmp	r0, #0
    524c:	d071      	beq.n	5332 <nrfx_gpiote_output_configure+0x132>
    524e:	f04f 0c0c 	mov.w	ip, #12
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    5252:	ea43 030c 	orr.w	r3, r3, ip
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
    5256:	2d00      	cmp	r5, #0
    5258:	d06e      	beq.n	5338 <nrfx_gpiote_output_configure+0x138>
    525a:	f44f 6ce0 	mov.w	ip, #1792	; 0x700
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    525e:	ea43 030c 	orr.w	r3, r3, ip
    cnf &= ~to_update;
    5262:	ea21 0103 	bic.w	r1, r1, r3
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    5266:	2f00      	cmp	r7, #0
    5268:	d069      	beq.n	533e <nrfx_gpiote_output_configure+0x13e>
    526a:	786b      	ldrb	r3, [r5, #1]
    526c:	005b      	lsls	r3, r3, #1
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    526e:	f043 0301 	orr.w	r3, r3, #1
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    5272:	2800      	cmp	r0, #0
    5274:	d065      	beq.n	5342 <nrfx_gpiote_output_configure+0x142>
    5276:	78a8      	ldrb	r0, [r5, #2]
    5278:	0080      	lsls	r0, r0, #2
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    527a:	4303      	orrs	r3, r0
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
    527c:	2d00      	cmp	r5, #0
    527e:	d062      	beq.n	5346 <nrfx_gpiote_output_configure+0x146>
    5280:	7828      	ldrb	r0, [r5, #0]
    5282:	0200      	lsls	r0, r0, #8
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    5284:	4303      	orrs	r3, r0
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    5286:	430b      	orrs	r3, r1
    reg->PIN_CNF[pin_number] = cnf;
    5288:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    528c:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    5290:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        m_cb.pin_flags[pin] |= PIN_FLAG_IN_USE | PIN_FLAG_OUTPUT;
    5294:	4a32      	ldr	r2, [pc, #200]	; (5360 <nrfx_gpiote_output_configure+0x160>)
    5296:	f104 0108 	add.w	r1, r4, #8
    529a:	f832 3011 	ldrh.w	r3, [r2, r1, lsl #1]
    529e:	f043 0303 	orr.w	r3, r3, #3
    52a2:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    if (p_task_config)
    52a6:	2e00      	cmp	r6, #0
    52a8:	d053      	beq.n	5352 <nrfx_gpiote_output_configure+0x152>
        if (pin_is_input(pin))
    52aa:	4620      	mov	r0, r4
    52ac:	f003 f829 	bl	8302 <pin_is_input>
    52b0:	2800      	cmp	r0, #0
    52b2:	d150      	bne.n	5356 <nrfx_gpiote_output_configure+0x156>
        uint32_t ch = p_task_config->task_ch;
    52b4:	7832      	ldrb	r2, [r6, #0]
    p_reg->CONFIG[idx] = 0;
    52b6:	f502 71a2 	add.w	r1, r2, #324	; 0x144
    52ba:	4b2a      	ldr	r3, [pc, #168]	; (5364 <nrfx_gpiote_output_configure+0x164>)
    52bc:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
        m_cb.pin_flags[pin] &= ~(PIN_FLAG_TE_USED | PIN_TE_ID_MASK);
    52c0:	4927      	ldr	r1, [pc, #156]	; (5360 <nrfx_gpiote_output_configure+0x160>)
    52c2:	f104 0008 	add.w	r0, r4, #8
    52c6:	f831 3010 	ldrh.w	r3, [r1, r0, lsl #1]
    52ca:	f023 0320 	bic.w	r3, r3, #32
    52ce:	04db      	lsls	r3, r3, #19
    52d0:	0cdb      	lsrs	r3, r3, #19
    52d2:	f821 3010 	strh.w	r3, [r1, r0, lsl #1]
        if (p_task_config->polarity != NRF_GPIOTE_POLARITY_NONE)
    52d6:	7871      	ldrb	r1, [r6, #1]
    52d8:	2900      	cmp	r1, #0
    52da:	d03e      	beq.n	535a <nrfx_gpiote_output_configure+0x15a>
            nrf_gpiote_task_configure(NRF_GPIOTE, ch, pin,
    52dc:	f896 c002 	ldrb.w	ip, [r6, #2]
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
    52e0:	4d20      	ldr	r5, [pc, #128]	; (5364 <nrfx_gpiote_output_configure+0x164>)
    52e2:	f502 76a2 	add.w	r6, r2, #324	; 0x144
    52e6:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
    52ea:	f420 1098 	bic.w	r0, r0, #1245184	; 0x130000
    52ee:	f420 50f8 	bic.w	r0, r0, #7936	; 0x1f00
    52f2:	f845 0026 	str.w	r0, [r5, r6, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    52f6:	f855 7026 	ldr.w	r7, [r5, r6, lsl #2]
    52fa:	0220      	lsls	r0, r4, #8
    52fc:	f400 50f8 	and.w	r0, r0, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    5300:	0409      	lsls	r1, r1, #16
    5302:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    5306:	4301      	orrs	r1, r0
                        ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
    5308:	ea4f 500c 	mov.w	r0, ip, lsl #20
    530c:	f400 1080 	and.w	r0, r0, #1048576	; 0x100000
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
    5310:	4301      	orrs	r1, r0
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    5312:	4339      	orrs	r1, r7
    5314:	f845 1026 	str.w	r1, [r5, r6, lsl #2]
            m_cb.pin_flags[pin] |= PIN_FLAG_TE_ID(ch);
    5318:	0352      	lsls	r2, r2, #13
    531a:	b292      	uxth	r2, r2
    531c:	3408      	adds	r4, #8
    531e:	431a      	orrs	r2, r3
    5320:	f042 0220 	orr.w	r2, r2, #32
    5324:	4b0e      	ldr	r3, [pc, #56]	; (5360 <nrfx_gpiote_output_configure+0x160>)
    5326:	f823 2014 	strh.w	r2, [r3, r4, lsl #1]
    return NRFX_SUCCESS;
    532a:	480f      	ldr	r0, [pc, #60]	; (5368 <nrfx_gpiote_output_configure+0x168>)
    532c:	e012      	b.n	5354 <nrfx_gpiote_output_configure+0x154>
                         (p_input ? GPIO_PIN_CNF_INPUT_Msk : 0) |
    532e:	2300      	movs	r3, #0
    5330:	e789      	b.n	5246 <nrfx_gpiote_output_configure+0x46>
                         (p_pull  ? GPIO_PIN_CNF_PULL_Msk  : 0) |
    5332:	f04f 0c00 	mov.w	ip, #0
    5336:	e78c      	b.n	5252 <nrfx_gpiote_output_configure+0x52>
                         (p_drive ? GPIO_PIN_CNF_DRIVE_Msk : 0) |
    5338:	f04f 0c00 	mov.w	ip, #0
    533c:	e78f      	b.n	525e <nrfx_gpiote_output_configure+0x5e>
           ((uint32_t)(p_input ? *p_input : 0) << GPIO_PIN_CNF_INPUT_Pos) |
    533e:	2300      	movs	r3, #0
    5340:	e795      	b.n	526e <nrfx_gpiote_output_configure+0x6e>
           ((uint32_t)(p_pull  ? *p_pull  : 0) << GPIO_PIN_CNF_PULL_Pos)  |
    5342:	2000      	movs	r0, #0
    5344:	e799      	b.n	527a <nrfx_gpiote_output_configure+0x7a>
           ((uint32_t)(p_drive ? *p_drive : 0) << GPIO_PIN_CNF_DRIVE_Pos) |
    5346:	2000      	movs	r0, #0
    5348:	e79c      	b.n	5284 <nrfx_gpiote_output_configure+0x84>
    534a:	4808      	ldr	r0, [pc, #32]	; (536c <nrfx_gpiote_output_configure+0x16c>)
    534c:	e002      	b.n	5354 <nrfx_gpiote_output_configure+0x154>
    534e:	4807      	ldr	r0, [pc, #28]	; (536c <nrfx_gpiote_output_configure+0x16c>)
    5350:	e000      	b.n	5354 <nrfx_gpiote_output_configure+0x154>
    5352:	4805      	ldr	r0, [pc, #20]	; (5368 <nrfx_gpiote_output_configure+0x168>)
}
    5354:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return NRFX_ERROR_INVALID_PARAM;
    5356:	4805      	ldr	r0, [pc, #20]	; (536c <nrfx_gpiote_output_configure+0x16c>)
    5358:	e7fc      	b.n	5354 <nrfx_gpiote_output_configure+0x154>
    return NRFX_SUCCESS;
    535a:	4803      	ldr	r0, [pc, #12]	; (5368 <nrfx_gpiote_output_configure+0x168>)
    535c:	e7fa      	b.n	5354 <nrfx_gpiote_output_configure+0x154>
    535e:	bf00      	nop
    5360:	20000090 	.word	0x20000090
    5364:	40006000 	.word	0x40006000
    5368:	0bad0000 	.word	0x0bad0000
    536c:	0bad0004 	.word	0x0bad0004

00005370 <nrfx_gpiote_global_callback_set>:
    m_cb.global_handler.handler = handler;
    5370:	4b01      	ldr	r3, [pc, #4]	; (5378 <nrfx_gpiote_global_callback_set+0x8>)
    5372:	6098      	str	r0, [r3, #8]
    m_cb.global_handler.p_context = p_context;
    5374:	60d9      	str	r1, [r3, #12]
}
    5376:	4770      	bx	lr
    5378:	20000090 	.word	0x20000090

0000537c <nrfx_gpiote_channel_get>:
{
    537c:	b538      	push	{r3, r4, r5, lr}
    537e:	4604      	mov	r4, r0
    5380:	460d      	mov	r5, r1
    if (pin_in_use_by_te(pin))
    5382:	f7ff fd29 	bl	4dd8 <pin_in_use_by_te>
    5386:	b140      	cbz	r0, 539a <nrfx_gpiote_channel_get+0x1e>
        *p_channel = PIN_GET_TE_ID(m_cb.pin_flags[pin]);
    5388:	f104 0008 	add.w	r0, r4, #8
    538c:	4b04      	ldr	r3, [pc, #16]	; (53a0 <nrfx_gpiote_channel_get+0x24>)
    538e:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    5392:	0b5b      	lsrs	r3, r3, #13
    5394:	702b      	strb	r3, [r5, #0]
        return NRFX_SUCCESS;
    5396:	4803      	ldr	r0, [pc, #12]	; (53a4 <nrfx_gpiote_channel_get+0x28>)
}
    5398:	bd38      	pop	{r3, r4, r5, pc}
        return NRFX_ERROR_INVALID_PARAM;
    539a:	4803      	ldr	r0, [pc, #12]	; (53a8 <nrfx_gpiote_channel_get+0x2c>)
    539c:	e7fc      	b.n	5398 <nrfx_gpiote_channel_get+0x1c>
    539e:	bf00      	nop
    53a0:	20000090 	.word	0x20000090
    53a4:	0bad0000 	.word	0x0bad0000
    53a8:	0bad0004 	.word	0x0bad0004

000053ac <nrfx_gpiote_init>:
    if (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
    53ac:	4b0f      	ldr	r3, [pc, #60]	; (53ec <nrfx_gpiote_init+0x40>)
    53ae:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
    53b2:	b10b      	cbz	r3, 53b8 <nrfx_gpiote_init+0xc>
        return err_code;
    53b4:	480e      	ldr	r0, [pc, #56]	; (53f0 <nrfx_gpiote_init+0x44>)
}
    53b6:	4770      	bx	lr
{
    53b8:	b510      	push	{r4, lr}
    memset(m_cb.pin_flags, 0, sizeof(m_cb.pin_flags));
    53ba:	4c0c      	ldr	r4, [pc, #48]	; (53ec <nrfx_gpiote_init+0x40>)
    53bc:	2240      	movs	r2, #64	; 0x40
    53be:	2100      	movs	r1, #0
    53c0:	f104 0010 	add.w	r0, r4, #16
    53c4:	f002 fd04 	bl	7dd0 <memset>
    NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_GPIOTE));
    53c8:	2006      	movs	r0, #6
    53ca:	f7fd f995 	bl	26f8 <arch_irq_enable>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    53ce:	4b09      	ldr	r3, [pc, #36]	; (53f4 <nrfx_gpiote_init+0x48>)
    53d0:	2200      	movs	r2, #0
    53d2:	601a      	str	r2, [r3, #0]
    53d4:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    53d6:	4b08      	ldr	r3, [pc, #32]	; (53f8 <nrfx_gpiote_init+0x4c>)
    53d8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    53dc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    m_cb.state = NRFX_DRV_STATE_INITIALIZED;
    53e0:	2301      	movs	r3, #1
    53e2:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    m_cb.available_evt_handlers = NRFX_BIT_MASK(NRFX_GPIOTE_CONFIG_NUM_OF_EVT_HANDLERS);
    53e6:	6563      	str	r3, [r4, #84]	; 0x54
    return err_code;
    53e8:	4804      	ldr	r0, [pc, #16]	; (53fc <nrfx_gpiote_init+0x50>)
}
    53ea:	bd10      	pop	{r4, pc}
    53ec:	20000090 	.word	0x20000090
    53f0:	0bad0005 	.word	0x0bad0005
    53f4:	4000617c 	.word	0x4000617c
    53f8:	40006000 	.word	0x40006000
    53fc:	0bad0000 	.word	0x0bad0000

00005400 <nrfx_gpiote_is_init>:
    return (m_cb.state != NRFX_DRV_STATE_UNINITIALIZED) ? true : false;
    5400:	4b03      	ldr	r3, [pc, #12]	; (5410 <nrfx_gpiote_is_init+0x10>)
    5402:	f893 0058 	ldrb.w	r0, [r3, #88]	; 0x58
}
    5406:	3800      	subs	r0, #0
    5408:	bf18      	it	ne
    540a:	2001      	movne	r0, #1
    540c:	4770      	bx	lr
    540e:	bf00      	nop
    5410:	20000090 	.word	0x20000090

00005414 <nrfx_gpiote_channel_free>:
{
    5414:	b508      	push	{r3, lr}
    5416:	4601      	mov	r1, r0
    return nrfx_flag32_free(&m_cb.available_channels_mask, channel);
    5418:	4801      	ldr	r0, [pc, #4]	; (5420 <nrfx_gpiote_channel_free+0xc>)
    541a:	f7ff fb77 	bl	4b0c <nrfx_flag32_free>
}
    541e:	bd08      	pop	{r3, pc}
    5420:	200000e0 	.word	0x200000e0

00005424 <nrfx_gpiote_channel_alloc>:
{
    5424:	b508      	push	{r3, lr}
    5426:	4601      	mov	r1, r0
    return nrfx_flag32_alloc(&m_cb.available_channels_mask, p_channel);
    5428:	4801      	ldr	r0, [pc, #4]	; (5430 <nrfx_gpiote_channel_alloc+0xc>)
    542a:	f7ff fb4b 	bl	4ac4 <nrfx_flag32_alloc>
}
    542e:	bd08      	pop	{r3, pc}
    5430:	200000e0 	.word	0x200000e0

00005434 <nrfx_gpiote_trigger_enable>:
{
    5434:	b538      	push	{r3, r4, r5, lr}
    5436:	4604      	mov	r4, r0
    5438:	460d      	mov	r5, r1
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    543a:	f7ff fccd 	bl	4dd8 <pin_in_use_by_te>
    543e:	b308      	cbz	r0, 5484 <nrfx_gpiote_trigger_enable+0x50>
    5440:	4620      	mov	r0, r4
    5442:	f002 ff5e 	bl	8302 <pin_is_input>
    5446:	b1e8      	cbz	r0, 5484 <nrfx_gpiote_trigger_enable+0x50>
        uint8_t ch = pin_te_get(pin);
    5448:	4620      	mov	r0, r4
    544a:	f7ff fce5 	bl	4e18 <pin_te_get>
#endif

NRF_STATIC_INLINE nrf_gpiote_event_t nrf_gpiote_in_event_get(uint8_t index)
{
    NRFX_ASSERT(index < GPIOTE_CH_NUM);
    return (nrf_gpiote_event_t)NRFX_OFFSETOF(NRF_GPIOTE_Type, EVENTS_IN[index]);
    544e:	0083      	lsls	r3, r0, #2
    5450:	f503 7380 	add.w	r3, r3, #256	; 0x100
    return ((uint32_t)p_reg + event);
    5454:	b29b      	uxth	r3, r3
    5456:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    545a:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    545e:	2200      	movs	r2, #0
    5460:	601a      	str	r2, [r3, #0]
    5462:	681b      	ldr	r3, [r3, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    5464:	4a1d      	ldr	r2, [pc, #116]	; (54dc <nrfx_gpiote_trigger_enable+0xa8>)
    5466:	f500 71a2 	add.w	r1, r0, #324	; 0x144
    546a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
    546e:	f043 0301 	orr.w	r3, r3, #1
    5472:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        if (int_enable)
    5476:	b365      	cbz	r5, 54d2 <nrfx_gpiote_trigger_enable+0x9e>
            nrf_gpiote_int_enable(NRF_GPIOTE, NRFX_BIT(ch));
    5478:	2301      	movs	r3, #1
    547a:	fa03 f000 	lsl.w	r0, r3, r0
    p_reg->INTENSET = mask;
    547e:	f8c2 0304 	str.w	r0, [r2, #772]	; 0x304
}
    5482:	e026      	b.n	54d2 <nrfx_gpiote_trigger_enable+0x9e>
    nrfx_gpiote_trigger_t trigger = PIN_FLAG_TRIG_MODE_GET(m_cb.pin_flags[pin]);
    5484:	f104 0308 	add.w	r3, r4, #8
    5488:	4a15      	ldr	r2, [pc, #84]	; (54e0 <nrfx_gpiote_trigger_enable+0xac>)
    548a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
    548e:	f3c3 0382 	ubfx	r3, r3, #2, #3
    if (trigger == NRFX_GPIOTE_TRIGGER_LOW)
    5492:	2b04      	cmp	r3, #4
    5494:	d00e      	beq.n	54b4 <nrfx_gpiote_trigger_enable+0x80>
    else if (trigger == NRFX_GPIOTE_TRIGGER_HIGH)
    5496:	2b05      	cmp	r3, #5
    5498:	d01c      	beq.n	54d4 <nrfx_gpiote_trigger_enable+0xa0>
    *p_pin = pin_number & 0x1F;
    549a:	f004 031f 	and.w	r3, r4, #31
    return p_reg->IN;
    549e:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    54a2:	f8d2 2510 	ldr.w	r2, [r2, #1296]	; 0x510
    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
    54a6:	fa22 f303 	lsr.w	r3, r2, r3
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    54aa:	f013 0f01 	tst.w	r3, #1
    54ae:	d013      	beq.n	54d8 <nrfx_gpiote_trigger_enable+0xa4>
    54b0:	2103      	movs	r1, #3
    54b2:	e000      	b.n	54b6 <nrfx_gpiote_trigger_enable+0x82>
        sense = NRF_GPIO_PIN_SENSE_LOW;
    54b4:	2103      	movs	r1, #3
    *p_pin = pin_number & 0x1F;
    54b6:	f004 041f 	and.w	r4, r4, #31
    uint32_t cnf = reg->PIN_CNF[pin_number];
    54ba:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    54be:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
    54c2:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
    cnf &= ~to_update;
    54c6:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    54ca:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
    54ce:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
}
    54d2:	bd38      	pop	{r3, r4, r5, pc}
        sense = NRF_GPIO_PIN_SENSE_HIGH;
    54d4:	2102      	movs	r1, #2
    54d6:	e7ee      	b.n	54b6 <nrfx_gpiote_trigger_enable+0x82>
        sense = nrf_gpio_pin_read(pin) ? NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    54d8:	2102      	movs	r1, #2
    54da:	e7ec      	b.n	54b6 <nrfx_gpiote_trigger_enable+0x82>
    54dc:	40006000 	.word	0x40006000
    54e0:	20000090 	.word	0x20000090

000054e4 <nrfx_gpiote_trigger_disable>:
{
    54e4:	b510      	push	{r4, lr}
    54e6:	4604      	mov	r4, r0
    if (pin_in_use_by_te(pin) && pin_is_input(pin))
    54e8:	f7ff fc76 	bl	4dd8 <pin_in_use_by_te>
    54ec:	b1a0      	cbz	r0, 5518 <nrfx_gpiote_trigger_disable+0x34>
    54ee:	4620      	mov	r0, r4
    54f0:	f002 ff07 	bl	8302 <pin_is_input>
    54f4:	b180      	cbz	r0, 5518 <nrfx_gpiote_trigger_disable+0x34>
        uint8_t ch = pin_te_get(pin);
    54f6:	4620      	mov	r0, r4
    54f8:	f7ff fc8e 	bl	4e18 <pin_te_get>
        nrf_gpiote_int_disable(NRF_GPIOTE, NRFX_BIT(ch));
    54fc:	2201      	movs	r2, #1
    54fe:	4082      	lsls	r2, r0
    p_reg->INTENCLR = mask;
    5500:	4b0c      	ldr	r3, [pc, #48]	; (5534 <nrfx_gpiote_trigger_disable+0x50>)
    5502:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Msk;
    5506:	f500 70a2 	add.w	r0, r0, #324	; 0x144
    550a:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
    550e:	f022 0203 	bic.w	r2, r2, #3
    5512:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
}
    5516:	e00b      	b.n	5530 <nrfx_gpiote_trigger_disable+0x4c>
    *p_pin = pin_number & 0x1F;
    5518:	f004 041f 	and.w	r4, r4, #31
    uint32_t cnf = reg->PIN_CNF[pin_number];
    551c:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    5520:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
    5524:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
    cnf &= ~to_update;
    5528:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf;
    552c:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
}
    5530:	bd10      	pop	{r4, pc}
    5532:	bf00      	nop
    5534:	40006000 	.word	0x40006000

00005538 <nrfx_gpiote_pin_uninit>:
{
    5538:	b510      	push	{r4, lr}
    553a:	4604      	mov	r4, r0
    if (!pin_in_use(pin))
    553c:	f7ff fc42 	bl	4dc4 <pin_in_use>
    5540:	b908      	cbnz	r0, 5546 <nrfx_gpiote_pin_uninit+0xe>
        return NRFX_ERROR_INVALID_PARAM;
    5542:	4809      	ldr	r0, [pc, #36]	; (5568 <nrfx_gpiote_pin_uninit+0x30>)
}
    5544:	bd10      	pop	{r4, pc}
    nrfx_gpiote_trigger_disable(pin);
    5546:	4620      	mov	r0, r4
    5548:	f7ff ffcc 	bl	54e4 <nrfx_gpiote_trigger_disable>
    pin_handler_trigger_uninit(pin);
    554c:	4620      	mov	r0, r4
    554e:	f7ff fce3 	bl	4f18 <pin_handler_trigger_uninit>
    *p_pin = pin_number & 0x1F;
    5552:	f004 041f 	and.w	r4, r4, #31
    reg->PIN_CNF[pin_number] = cnf;
    5556:	f504 74e0 	add.w	r4, r4, #448	; 0x1c0
    555a:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    555e:	2202      	movs	r2, #2
    5560:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    return NRFX_SUCCESS;
    5564:	4801      	ldr	r0, [pc, #4]	; (556c <nrfx_gpiote_pin_uninit+0x34>)
    5566:	e7ed      	b.n	5544 <nrfx_gpiote_pin_uninit+0xc>
    5568:	0bad0004 	.word	0x0bad0004
    556c:	0bad0000 	.word	0x0bad0000

00005570 <nrfx_gpiote_irq_handler>:

void nrfx_gpiote_irq_handler(void)
{
    5570:	b538      	push	{r3, r4, r5, lr}
    uint32_t status = 0;
    uint32_t i;
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    uint32_t mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
    5572:	2001      	movs	r0, #1
    nrf_gpiote_event_t event = NRF_GPIOTE_EVENT_IN_0;
    5574:	f44f 7380 	mov.w	r3, #256	; 0x100

    /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    5578:	2100      	movs	r1, #0
    uint32_t status = 0;
    557a:	460d      	mov	r5, r1
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    557c:	e003      	b.n	5586 <nrfx_gpiote_irq_handler+0x16>
            nrf_gpiote_int_enable_check(NRF_GPIOTE, mask))
        {
            nrf_gpiote_event_clear(NRF_GPIOTE, event);
            status |= mask;
        }
        mask <<= 1;
    557e:	0040      	lsls	r0, r0, #1
        /* Incrementing to next event, utilizing the fact that events are grouped together
         * in ascending order. */
        event = (nrf_gpiote_event_t)((uint32_t)event + sizeof(uint32_t));
    5580:	3304      	adds	r3, #4
    5582:	b29b      	uxth	r3, r3
    for (i = 0; i < GPIOTE_CH_NUM; i++)
    5584:	3101      	adds	r1, #1
    5586:	2907      	cmp	r1, #7
    5588:	d814      	bhi.n	55b4 <nrfx_gpiote_irq_handler+0x44>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    558a:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
    558e:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    5592:	6812      	ldr	r2, [r2, #0]
        if (nrf_gpiote_event_check(NRF_GPIOTE, event) &&
    5594:	2a00      	cmp	r2, #0
    5596:	d0f2      	beq.n	557e <nrfx_gpiote_irq_handler+0xe>
    return p_reg->INTENSET & mask;
    5598:	4a0b      	ldr	r2, [pc, #44]	; (55c8 <nrfx_gpiote_irq_handler+0x58>)
    559a:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
    559e:	4210      	tst	r0, r2
    55a0:	d0ed      	beq.n	557e <nrfx_gpiote_irq_handler+0xe>
    return ((uint32_t)p_reg + event);
    55a2:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
    55a6:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    55aa:	2400      	movs	r4, #0
    55ac:	6014      	str	r4, [r2, #0]
    55ae:	6812      	ldr	r2, [r2, #0]
            status |= mask;
    55b0:	4305      	orrs	r5, r0
    55b2:	e7e4      	b.n	557e <nrfx_gpiote_irq_handler+0xe>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    55b4:	4b05      	ldr	r3, [pc, #20]	; (55cc <nrfx_gpiote_irq_handler+0x5c>)
    55b6:	681b      	ldr	r3, [r3, #0]
    }

    /* handle PORT event */
    if (nrf_gpiote_event_check(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT))
    55b8:	b91b      	cbnz	r3, 55c2 <nrfx_gpiote_irq_handler+0x52>
    {
        port_event_handle();
    }

    /* Process pin events. */
    gpiote_evt_handle(status);
    55ba:	4628      	mov	r0, r5
    55bc:	f7ff fd50 	bl	5060 <gpiote_evt_handle>
}
    55c0:	bd38      	pop	{r3, r4, r5, pc}
        port_event_handle();
    55c2:	f7ff fcfb 	bl	4fbc <port_event_handle>
    55c6:	e7f8      	b.n	55ba <nrfx_gpiote_irq_handler+0x4a>
    55c8:	40006000 	.word	0x40006000
    55cc:	4000617c 	.word	0x4000617c

000055d0 <nrfx_spi_init>:

nrfx_err_t nrfx_spi_init(nrfx_spi_t const *        p_instance,
                         nrfx_spi_config_t const * p_config,
                         nrfx_spi_evt_handler_t    handler,
                         void *                    p_context)
{
    55d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    55d2:	4606      	mov	r6, r0
    55d4:	460d      	mov	r5, r1
    NRFX_ASSERT(p_config);
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    55d6:	7904      	ldrb	r4, [r0, #4]
    NRF_SPI_Type * p_spi = p_instance->p_reg;
    55d8:	6807      	ldr	r7, [r0, #0]
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
    55da:	eb04 0084 	add.w	r0, r4, r4, lsl #2
    55de:	4926      	ldr	r1, [pc, #152]	; (5678 <nrfx_spi_init+0xa8>)
    55e0:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
    55e4:	7f09      	ldrb	r1, [r1, #28]
    55e6:	b109      	cbz	r1, 55ec <nrfx_spi_init+0x1c>
    {
        err_code = NRFX_ERROR_INVALID_STATE;
        NRFX_LOG_WARNING("Function: %s, error code: %s.",
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    55e8:	4824      	ldr	r0, [pc, #144]	; (567c <nrfx_spi_init+0xac>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    55ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    p_cb->handler = handler;
    55ec:	4822      	ldr	r0, [pc, #136]	; (5678 <nrfx_spi_init+0xa8>)
    55ee:	eb04 0c84 	add.w	ip, r4, r4, lsl #2
    55f2:	eb00 01cc 	add.w	r1, r0, ip, lsl #3
    55f6:	f840 203c 	str.w	r2, [r0, ip, lsl #3]
    p_cb->p_context = p_context;
    55fa:	604b      	str	r3, [r1, #4]
    p_cb->skip_gpio_cfg = p_config->skip_gpio_cfg;
    55fc:	7beb      	ldrb	r3, [r5, #15]
    55fe:	f881 3025 	strb.w	r3, [r1, #37]	; 0x25
    p_cb->ss_pin = p_config->ss_pin;
    5602:	78eb      	ldrb	r3, [r5, #3]
    5604:	778b      	strb	r3, [r1, #30]
    p_cb->orc = p_config->orc;
    5606:	796b      	ldrb	r3, [r5, #5]
    5608:	77cb      	strb	r3, [r1, #31]
    configure_pins(p_spi, p_config);
    560a:	4629      	mov	r1, r5
    560c:	4638      	mov	r0, r7
    560e:	f002 feee 	bl	83ee <configure_pins>
    nrf_spi_frequency_set(p_spi, p_config->frequency);
    5612:	68ab      	ldr	r3, [r5, #8]
}

NRF_STATIC_INLINE void nrf_spi_frequency_set(NRF_SPI_Type *      p_reg,
                                             nrf_spi_frequency_t frequency)
{
    p_reg->FREQUENCY = (uint32_t)frequency;
    5614:	f8c7 3524 	str.w	r3, [r7, #1316]	; 0x524
    nrf_spi_configure(p_spi, p_config->mode, p_config->bit_order);
    5618:	7b2a      	ldrb	r2, [r5, #12]
    561a:	7b6b      	ldrb	r3, [r5, #13]
NRF_STATIC_INLINE void nrf_spi_configure(NRF_SPI_Type *      p_reg,
                                         nrf_spi_mode_t      spi_mode,
                                         nrf_spi_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPI_BIT_ORDER_MSB_FIRST ?
        SPI_CONFIG_ORDER_MsbFirst : SPI_CONFIG_ORDER_LsbFirst);
    561c:	3b00      	subs	r3, #0
    561e:	bf18      	it	ne
    5620:	2301      	movne	r3, #1
    switch (spi_mode)
    5622:	2a02      	cmp	r2, #2
    5624:	d021      	beq.n	566a <nrfx_spi_init+0x9a>
    5626:	2a03      	cmp	r2, #3
    5628:	d022      	beq.n	5670 <nrfx_spi_init+0xa0>
    562a:	2a01      	cmp	r2, #1
    562c:	d01a      	beq.n	5664 <nrfx_spi_init+0x94>
    case NRF_SPI_MODE_3:
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
                  (SPI_CONFIG_CPHA_Trailing   << SPI_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
    562e:	f8c7 3554 	str.w	r3, [r7, #1364]	; 0x554
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Enabled << SPI_ENABLE_ENABLE_Pos);
    5632:	2301      	movs	r3, #1
    5634:	f8c7 3500 	str.w	r3, [r7, #1280]	; 0x500
    if (p_cb->handler)
    5638:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    563c:	4a0e      	ldr	r2, [pc, #56]	; (5678 <nrfx_spi_init+0xa8>)
    563e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    5642:	b123      	cbz	r3, 564e <nrfx_spi_init+0x7e>
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
    5644:	6830      	ldr	r0, [r6, #0]
    5646:	f340 3007 	sbfx	r0, r0, #12, #8
    564a:	f7fd f855 	bl	26f8 <arch_irq_enable>
    p_cb->transfer_in_progress = false;
    564e:	4b0a      	ldr	r3, [pc, #40]	; (5678 <nrfx_spi_init+0xa8>)
    5650:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    5654:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    5658:	2100      	movs	r1, #0
    565a:	7751      	strb	r1, [r2, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
    565c:	2301      	movs	r3, #1
    565e:	7713      	strb	r3, [r2, #28]
    return err_code;
    5660:	4807      	ldr	r0, [pc, #28]	; (5680 <nrfx_spi_init+0xb0>)
    5662:	e7c2      	b.n	55ea <nrfx_spi_init+0x1a>
        config |= (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos) |
    5664:	f043 0302 	orr.w	r3, r3, #2
        break;
    5668:	e7e1      	b.n	562e <nrfx_spi_init+0x5e>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    566a:	f043 0304 	orr.w	r3, r3, #4
        break;
    566e:	e7de      	b.n	562e <nrfx_spi_init+0x5e>
        config |= (SPI_CONFIG_CPOL_ActiveLow  << SPI_CONFIG_CPOL_Pos) |
    5670:	f043 0306 	orr.w	r3, r3, #6
        break;
    5674:	e7db      	b.n	562e <nrfx_spi_init+0x5e>
    5676:	bf00      	nop
    5678:	200004dc 	.word	0x200004dc
    567c:	0bad0005 	.word	0x0bad0005
    5680:	0bad0000 	.word	0x0bad0000

00005684 <nrfx_spi_uninit>:

void nrfx_spi_uninit(nrfx_spi_t const * p_instance)
{
    5684:	b538      	push	{r3, r4, r5, lr}
    spi_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    5686:	7904      	ldrb	r4, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
    NRF_SPI_Type * p_spi = p_instance->p_reg;
    5688:	6805      	ldr	r5, [r0, #0]

    if (p_cb->handler)
    568a:	eb04 0284 	add.w	r2, r4, r4, lsl #2
    568e:	4b29      	ldr	r3, [pc, #164]	; (5734 <nrfx_spi_uninit+0xb0>)
    5690:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    5694:	b133      	cbz	r3, 56a4 <nrfx_spi_uninit+0x20>
    {
        NRFX_IRQ_DISABLE(nrfx_get_irq_number(p_instance->p_reg));
    5696:	f345 3007 	sbfx	r0, r5, #12, #8
    569a:	f7fd f83d 	bl	2718 <arch_irq_disable>
    p_reg->INTENCLR = mask;
    569e:	2304      	movs	r3, #4
    56a0:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
    p_reg->ENABLE = (SPI_ENABLE_ENABLE_Disabled << SPI_ENABLE_ENABLE_Pos);
    56a4:	2300      	movs	r3, #0
    56a6:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
        nrf_spi_int_disable(p_spi, NRF_SPI_ALL_INTS_MASK);
    }

    nrf_spi_disable(p_spi);

    if (!p_cb->skip_gpio_cfg)
    56aa:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    56ae:	4a21      	ldr	r2, [pc, #132]	; (5734 <nrfx_spi_uninit+0xb0>)
    56b0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    56b4:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    56b8:	bba3      	cbnz	r3, 5724 <nrfx_spi_uninit+0xa0>
    return p_reg->PSELSCK;
    56ba:	f8d5 3508 	ldr.w	r3, [r5, #1288]	; 0x508
    *p_pin = pin_number & 0x1F;
    56be:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    56c2:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    56c6:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    56ca:	2102      	movs	r1, #2
    56cc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    return p_reg->PSELMISO;
    56d0:	f8d5 3510 	ldr.w	r3, [r5, #1296]	; 0x510
    {
        nrf_gpio_cfg_default(nrf_spi_sck_pin_get(p_spi));

        uint32_t miso_pin = nrf_spi_miso_pin_get(p_spi);
        if (miso_pin != NRF_SPI_PIN_NOT_CONNECTED)
    56d4:	f1b3 3fff 	cmp.w	r3, #4294967295
    56d8:	d005      	beq.n	56e6 <nrfx_spi_uninit+0x62>
    *p_pin = pin_number & 0x1F;
    56da:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    56de:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    56e2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    return p_reg->PSELMOSI;
    56e6:	f8d5 350c 	ldr.w	r3, [r5, #1292]	; 0x50c
        {
            nrf_gpio_cfg_default(miso_pin);
        }

        uint32_t mosi_pin = nrf_spi_mosi_pin_get(p_spi);
        if (mosi_pin != NRF_SPI_PIN_NOT_CONNECTED)
    56ea:	f1b3 3fff 	cmp.w	r3, #4294967295
    56ee:	d008      	beq.n	5702 <nrfx_spi_uninit+0x7e>
    *p_pin = pin_number & 0x1F;
    56f0:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    56f4:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    56f8:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    56fc:	2102      	movs	r1, #2
    56fe:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        {
            nrf_gpio_cfg_default(mosi_pin);
        }

        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    5702:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    5706:	4a0b      	ldr	r2, [pc, #44]	; (5734 <nrfx_spi_uninit+0xb0>)
    5708:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    570c:	7f9b      	ldrb	r3, [r3, #30]
    570e:	2bff      	cmp	r3, #255	; 0xff
    5710:	d008      	beq.n	5724 <nrfx_spi_uninit+0xa0>
    *p_pin = pin_number & 0x1F;
    5712:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    5716:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    571a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    571e:	2102      	movs	r1, #2
    5720:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

#if NRFX_CHECK(NRFX_PRS_ENABLED)
    nrfx_prs_release(p_instance->p_reg);
#endif

    p_cb->state = NRFX_DRV_STATE_UNINITIALIZED;
    5724:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    5728:	4b02      	ldr	r3, [pc, #8]	; (5734 <nrfx_spi_uninit+0xb0>)
    572a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    572e:	2300      	movs	r3, #0
    5730:	7723      	strb	r3, [r4, #28]
}
    5732:	bd38      	pop	{r3, r4, r5, pc}
    5734:	200004dc 	.word	0x200004dc

00005738 <nrfx_spi_xfer>:
}

nrfx_err_t nrfx_spi_xfer(nrfx_spi_t const *           p_instance,
                         nrfx_spi_xfer_desc_t const * p_xfer_desc,
                         uint32_t                     flags)
{
    5738:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    spi_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    573c:	7904      	ldrb	r4, [r0, #4]
    573e:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    5742:	4f21      	ldr	r7, [pc, #132]	; (57c8 <nrfx_spi_xfer+0x90>)
    5744:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
    5748:	7f7b      	ldrb	r3, [r7, #29]
    574a:	2b00      	cmp	r3, #0
    574c:	d139      	bne.n	57c2 <nrfx_spi_xfer+0x8a>
    574e:	4606      	mov	r6, r0
    5750:	460d      	mov	r5, r1
    5752:	4696      	mov	lr, r2
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler)
    5754:	eb04 0384 	add.w	r3, r4, r4, lsl #2
    5758:	4a1b      	ldr	r2, [pc, #108]	; (57c8 <nrfx_spi_xfer+0x90>)
    575a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    575e:	b10b      	cbz	r3, 5764 <nrfx_spi_xfer+0x2c>
        {
            p_cb->transfer_in_progress = true;
    5760:	2201      	movs	r2, #1
    5762:	777a      	strb	r2, [r7, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
    5764:	eb04 0c84 	add.w	ip, r4, r4, lsl #2
    5768:	4b17      	ldr	r3, [pc, #92]	; (57c8 <nrfx_spi_xfer+0x90>)
    576a:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
    576e:	f10c 080c 	add.w	r8, ip, #12
    5772:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    5776:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}
    p_cb->abort = false;
    577a:	2300      	movs	r3, #0
    577c:	f88c 3024 	strb.w	r3, [ip, #36]	; 0x24

    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    5780:	f89c 301e 	ldrb.w	r3, [ip, #30]
    5784:	2bff      	cmp	r3, #255	; 0xff
    5786:	d008      	beq.n	579a <nrfx_spi_xfer+0x62>
    *p_pin = pin_number & 0x1F;
    5788:	f003 031f 	and.w	r3, r3, #31
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    578c:	2201      	movs	r2, #1
    578e:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTCLR = clr_mask;
    5792:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    5796:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
    {
        nrf_gpio_pin_write(p_cb->ss_pin, 0);
    }
    if (flags)
    579a:	f1be 0f00 	cmp.w	lr, #0
    579e:	d009      	beq.n	57b4 <nrfx_spi_xfer+0x7c>
    {
        p_cb->transfer_in_progress = false;
    57a0:	eb04 0484 	add.w	r4, r4, r4, lsl #2
    57a4:	4b08      	ldr	r3, [pc, #32]	; (57c8 <nrfx_spi_xfer+0x90>)
    57a6:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    57aa:	2300      	movs	r3, #0
    57ac:	7763      	strb	r3, [r4, #29]
        err_code = NRFX_ERROR_NOT_SUPPORTED;
    57ae:	4807      	ldr	r0, [pc, #28]	; (57cc <nrfx_spi_xfer+0x94>)
    }
    NRFX_LOG_INFO("Function: %s, error code: %s.",
                  __func__,
                  NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    57b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        spi_xfer(p_instance->p_reg, p_cb, p_xfer_desc);
    57b4:	462a      	mov	r2, r5
    57b6:	4639      	mov	r1, r7
    57b8:	6830      	ldr	r0, [r6, #0]
    57ba:	f002 fef3 	bl	85a4 <spi_xfer>
    nrfx_err_t err_code = NRFX_SUCCESS;
    57be:	4804      	ldr	r0, [pc, #16]	; (57d0 <nrfx_spi_xfer+0x98>)
    57c0:	e7f6      	b.n	57b0 <nrfx_spi_xfer+0x78>
        return err_code;
    57c2:	4804      	ldr	r0, [pc, #16]	; (57d4 <nrfx_spi_xfer+0x9c>)
    57c4:	e7f4      	b.n	57b0 <nrfx_spi_xfer+0x78>
    57c6:	bf00      	nop
    57c8:	200004dc 	.word	0x200004dc
    57cc:	0bad0003 	.word	0x0bad0003
    57d0:	0bad0000 	.word	0x0bad0000
    57d4:	0bad000b 	.word	0x0bad000b

000057d8 <nrfx_spi_0_irq_handler>:
    }
}

#if NRFX_CHECK(NRFX_SPI0_ENABLED)
void nrfx_spi_0_irq_handler(void)
{
    57d8:	b508      	push	{r3, lr}
    irq_handler(NRF_SPI0, &m_cb[NRFX_SPI0_INST_IDX]);
    57da:	4902      	ldr	r1, [pc, #8]	; (57e4 <nrfx_spi_0_irq_handler+0xc>)
    57dc:	4802      	ldr	r0, [pc, #8]	; (57e8 <nrfx_spi_0_irq_handler+0x10>)
    57de:	f002 ff25 	bl	862c <irq_handler>
}
    57e2:	bd08      	pop	{r3, pc}
    57e4:	200004dc 	.word	0x200004dc
    57e8:	40003000 	.word	0x40003000

000057ec <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
    57ec:	b510      	push	{r4, lr}
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    57ee:	4c11      	ldr	r4, [pc, #68]	; (5834 <_DoInit+0x48>)
    57f0:	2303      	movs	r3, #3
    57f2:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    57f4:	6163      	str	r3, [r4, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    57f6:	4a10      	ldr	r2, [pc, #64]	; (5838 <_DoInit+0x4c>)
    57f8:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    57fa:	4b10      	ldr	r3, [pc, #64]	; (583c <_DoInit+0x50>)
    57fc:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    57fe:	f44f 6380 	mov.w	r3, #1024	; 0x400
    5802:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
    5804:	2300      	movs	r3, #0
    5806:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    5808:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    580a:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    580c:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    580e:	4a0c      	ldr	r2, [pc, #48]	; (5840 <_DoInit+0x54>)
    5810:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    5812:	2210      	movs	r2, #16
    5814:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    5816:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    5818:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    581a:	6763      	str	r3, [r4, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
    581c:	4909      	ldr	r1, [pc, #36]	; (5844 <_DoInit+0x58>)
    581e:	1de0      	adds	r0, r4, #7
    5820:	f002 fa73 	bl	7d0a <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
    5824:	4908      	ldr	r1, [pc, #32]	; (5848 <_DoInit+0x5c>)
    5826:	4620      	mov	r0, r4
    5828:	f002 fa6f 	bl	7d0a <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
    582c:	2320      	movs	r3, #32
    582e:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
    5830:	bd10      	pop	{r4, pc}
    5832:	bf00      	nop
    5834:	20000504 	.word	0x20000504
    5838:	00009850 	.word	0x00009850
    583c:	200005bc 	.word	0x200005bc
    5840:	200005ac 	.word	0x200005ac
    5844:	0000985c 	.word	0x0000985c
    5848:	00009860 	.word	0x00009860

0000584c <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    584c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5850:	4604      	mov	r4, r0
    5852:	460e      	mov	r6, r1
    5854:	4615      	mov	r5, r2
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
    5856:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    585a:	4a2d      	ldr	r2, [pc, #180]	; (5910 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    585c:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    5860:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
    5862:	6a57      	ldr	r7, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    5864:	42bb      	cmp	r3, r7
    5866:	d84b      	bhi.n	5900 <SEGGER_RTT_WriteSkipNoLock+0xb4>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
    5868:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    586c:	4928      	ldr	r1, [pc, #160]	; (5910 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    586e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
    5872:	f8d2 8020 	ldr.w	r8, [r2, #32]
    5876:	eba8 0907 	sub.w	r9, r8, r7
    587a:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
    587e:	4295      	cmp	r5, r2
    5880:	d904      	bls.n	588c <SEGGER_RTT_WriteSkipNoLock+0x40>
      memcpy((void*)pDst, pData, NumBytes);
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
      return 1;
    }
    Avail += RdOff;                                     // Space incl. wrap-around
    5882:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
    5884:	429d      	cmp	r5, r3
    5886:	d916      	bls.n	58b6 <SEGGER_RTT_WriteSkipNoLock+0x6a>
    Avail = RdOff - WrOff - 1u;
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
    5888:	2000      	movs	r0, #0
    588a:	e03e      	b.n	590a <SEGGER_RTT_WriteSkipNoLock+0xbe>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    588c:	f8df 8080 	ldr.w	r8, [pc, #128]	; 5910 <SEGGER_RTT_WriteSkipNoLock+0xc4>
    5890:	1c63      	adds	r3, r4, #1
    5892:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    5896:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
    589a:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
    589c:	462a      	mov	r2, r5
    589e:	4631      	mov	r1, r6
    58a0:	4438      	add	r0, r7
    58a2:	f002 fa71 	bl	7d88 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
    58a6:	443d      	add	r5, r7
    58a8:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    58ac:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
    58b0:	6265      	str	r5, [r4, #36]	; 0x24
      return 1;
    58b2:	2001      	movs	r0, #1
    58b4:	e029      	b.n	590a <SEGGER_RTT_WriteSkipNoLock+0xbe>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    58b6:	1c43      	adds	r3, r0, #1
    58b8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    58bc:	4a14      	ldr	r2, [pc, #80]	; (5910 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    58be:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    58c2:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
    58c4:	464a      	mov	r2, r9
    58c6:	4631      	mov	r1, r6
    58c8:	4438      	add	r0, r7
    58ca:	f002 fa5d 	bl	7d88 <memcpy>
      NumBytes -= Rem;
    58ce:	eba7 0708 	sub.w	r7, r7, r8
      if (NumBytes) {
    58d2:	197f      	adds	r7, r7, r5
    58d4:	d107      	bne.n	58e6 <SEGGER_RTT_WriteSkipNoLock+0x9a>
      pRing->WrOff = NumBytes;
    58d6:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    58da:	4b0d      	ldr	r3, [pc, #52]	; (5910 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    58dc:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    58e0:	6267      	str	r7, [r4, #36]	; 0x24
      return 1;
    58e2:	2001      	movs	r0, #1
    58e4:	e011      	b.n	590a <SEGGER_RTT_WriteSkipNoLock+0xbe>
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
    58e6:	1c63      	adds	r3, r4, #1
    58e8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    58ec:	4a08      	ldr	r2, [pc, #32]	; (5910 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    58ee:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
        memcpy((void*)pDst, pData + Rem, NumBytes);
    58f2:	463a      	mov	r2, r7
    58f4:	eb06 0109 	add.w	r1, r6, r9
    58f8:	6858      	ldr	r0, [r3, #4]
    58fa:	f002 fa45 	bl	7d88 <memcpy>
    58fe:	e7ea      	b.n	58d6 <SEGGER_RTT_WriteSkipNoLock+0x8a>
    Avail = RdOff - WrOff - 1u;
    5900:	1bdb      	subs	r3, r3, r7
    5902:	3b01      	subs	r3, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
    5904:	42ab      	cmp	r3, r5
    5906:	d2c1      	bcs.n	588c <SEGGER_RTT_WriteSkipNoLock+0x40>
  return 0;     // No space in buffer
    5908:	2000      	movs	r0, #0
}
    590a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    590e:	bf00      	nop
    5910:	20000504 	.word	0x20000504

00005914 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    5914:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5916:	460f      	mov	r7, r1
    5918:	4616      	mov	r6, r2
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
    591a:	4b18      	ldr	r3, [pc, #96]	; (597c <SEGGER_RTT_WriteNoLock+0x68>)
    591c:	1c45      	adds	r5, r0, #1
    591e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
    5922:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
    5926:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    592a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    592e:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
    5930:	2c01      	cmp	r4, #1
    5932:	d011      	beq.n	5958 <SEGGER_RTT_WriteNoLock+0x44>
    5934:	2c02      	cmp	r4, #2
    5936:	d01c      	beq.n	5972 <SEGGER_RTT_WriteNoLock+0x5e>
    5938:	b114      	cbz	r4, 5940 <SEGGER_RTT_WriteNoLock+0x2c>
    593a:	2400      	movs	r4, #0
  }
  //
  // Finish up.
  //
  return Status;
}
    593c:	4620      	mov	r0, r4
    593e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Avail = _GetAvailWriteSpace(pRing);
    5940:	4628      	mov	r0, r5
    5942:	f002 fe82 	bl	864a <_GetAvailWriteSpace>
    if (Avail < NumBytes) {
    5946:	4286      	cmp	r6, r0
    5948:	d8f8      	bhi.n	593c <SEGGER_RTT_WriteNoLock+0x28>
      _WriteNoCheck(pRing, pData, NumBytes);
    594a:	4632      	mov	r2, r6
    594c:	4639      	mov	r1, r7
    594e:	4628      	mov	r0, r5
    5950:	f002 fe87 	bl	8662 <_WriteNoCheck>
      Status = NumBytes;
    5954:	4634      	mov	r4, r6
    5956:	e7f1      	b.n	593c <SEGGER_RTT_WriteNoLock+0x28>
    Avail = _GetAvailWriteSpace(pRing);
    5958:	4628      	mov	r0, r5
    595a:	f002 fe76 	bl	864a <_GetAvailWriteSpace>
    Status = Avail < NumBytes ? Avail : NumBytes;
    595e:	4634      	mov	r4, r6
    5960:	4286      	cmp	r6, r0
    5962:	bf28      	it	cs
    5964:	4604      	movcs	r4, r0
    _WriteNoCheck(pRing, pData, Status);
    5966:	4622      	mov	r2, r4
    5968:	4639      	mov	r1, r7
    596a:	4628      	mov	r0, r5
    596c:	f002 fe79 	bl	8662 <_WriteNoCheck>
    break;
    5970:	e7e4      	b.n	593c <SEGGER_RTT_WriteNoLock+0x28>
    Status = _WriteBlocking(pRing, pData, NumBytes);
    5972:	4628      	mov	r0, r5
    5974:	f002 fe97 	bl	86a6 <_WriteBlocking>
    5978:	4604      	mov	r4, r0
    break;
    597a:	e7df      	b.n	593c <SEGGER_RTT_WriteNoLock+0x28>
    597c:	20000504 	.word	0x20000504

00005980 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
    5980:	4b06      	ldr	r3, [pc, #24]	; (599c <SEGGER_RTT_HasDataUp+0x1c>)
    5982:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    5986:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    598a:	6a92      	ldr	r2, [r2, #40]	; 0x28
  return pRing->WrOff - v;
    598c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    5990:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5994:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
    5996:	1a80      	subs	r0, r0, r2
    5998:	4770      	bx	lr
    599a:	bf00      	nop
    599c:	20000504 	.word	0x20000504

000059a0 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	const struct device *dev = __device_start;
    59a0:	4b03      	ldr	r3, [pc, #12]	; (59b0 <z_device_state_init+0x10>)

	while (dev < __device_end) {
    59a2:	4a04      	ldr	r2, [pc, #16]	; (59b4 <z_device_state_init+0x14>)
    59a4:	4293      	cmp	r3, r2
    59a6:	d201      	bcs.n	59ac <z_device_state_init+0xc>
		z_object_init(dev);
		++dev;
    59a8:	3318      	adds	r3, #24
    59aa:	e7fa      	b.n	59a2 <z_device_state_init+0x2>
	}
}
    59ac:	4770      	bx	lr
    59ae:	bf00      	nop
    59b0:	00008cc8 	.word	0x00008cc8
    59b4:	00008d10 	.word	0x00008d10

000059b8 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    59b8:	b570      	push	{r4, r5, r6, lr}
    59ba:	4606      	mov	r6, r0
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    59bc:	4b11      	ldr	r3, [pc, #68]	; (5a04 <z_sys_init_run_level+0x4c>)
    59be:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    59c2:	e009      	b.n	59d8 <z_sys_init_run_level+0x20>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
				if (rc < 0) {
					rc = -rc;
    59c4:	4240      	negs	r0, r0
    59c6:	e017      	b.n	59f8 <z_sys_init_run_level+0x40>
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    59c8:	68eb      	ldr	r3, [r5, #12]
    59ca:	7018      	strb	r0, [r3, #0]
			}
			dev->state->initialized = true;
    59cc:	68ea      	ldr	r2, [r5, #12]
    59ce:	7853      	ldrb	r3, [r2, #1]
    59d0:	f043 0301 	orr.w	r3, r3, #1
    59d4:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    59d6:	3408      	adds	r4, #8
    59d8:	1c73      	adds	r3, r6, #1
    59da:	4a0a      	ldr	r2, [pc, #40]	; (5a04 <z_sys_init_run_level+0x4c>)
    59dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59e0:	42a3      	cmp	r3, r4
    59e2:	d90d      	bls.n	5a00 <z_sys_init_run_level+0x48>
		const struct device *dev = entry->dev;
    59e4:	6865      	ldr	r5, [r4, #4]
		int rc = entry->init(dev);
    59e6:	6823      	ldr	r3, [r4, #0]
    59e8:	4628      	mov	r0, r5
    59ea:	4798      	blx	r3
		if (dev != NULL) {
    59ec:	2d00      	cmp	r5, #0
    59ee:	d0f2      	beq.n	59d6 <z_sys_init_run_level+0x1e>
			if (rc != 0) {
    59f0:	2800      	cmp	r0, #0
    59f2:	d0eb      	beq.n	59cc <z_sys_init_run_level+0x14>
				if (rc < 0) {
    59f4:	2800      	cmp	r0, #0
    59f6:	dbe5      	blt.n	59c4 <z_sys_init_run_level+0xc>
				if (rc > UINT8_MAX) {
    59f8:	28ff      	cmp	r0, #255	; 0xff
    59fa:	dde5      	ble.n	59c8 <z_sys_init_run_level+0x10>
					rc = UINT8_MAX;
    59fc:	20ff      	movs	r0, #255	; 0xff
    59fe:	e7e3      	b.n	59c8 <z_sys_init_run_level+0x10>
		}
	}
}
    5a00:	bd70      	pop	{r4, r5, r6, pc}
    5a02:	bf00      	nop
    5a04:	00009868 	.word	0x00009868

00005a08 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    5a08:	b538      	push	{r3, r4, r5, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    5a0a:	4605      	mov	r5, r0
    5a0c:	b328      	cbz	r0, 5a5a <z_impl_device_get_binding+0x52>
    5a0e:	7803      	ldrb	r3, [r0, #0]
    5a10:	b32b      	cbz	r3, 5a5e <z_impl_device_get_binding+0x56>
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
    5a12:	4c14      	ldr	r4, [pc, #80]	; (5a64 <z_impl_device_get_binding+0x5c>)
    5a14:	e000      	b.n	5a18 <z_impl_device_get_binding+0x10>
    5a16:	3418      	adds	r4, #24
    5a18:	4b13      	ldr	r3, [pc, #76]	; (5a68 <z_impl_device_get_binding+0x60>)
    5a1a:	429c      	cmp	r4, r3
    5a1c:	d008      	beq.n	5a30 <z_impl_device_get_binding+0x28>
		if (z_device_ready(dev) && (dev->name == name)) {
    5a1e:	4620      	mov	r0, r4
    5a20:	f002 fe79 	bl	8716 <z_device_ready>
    5a24:	2800      	cmp	r0, #0
    5a26:	d0f6      	beq.n	5a16 <z_impl_device_get_binding+0xe>
    5a28:	6823      	ldr	r3, [r4, #0]
    5a2a:	42ab      	cmp	r3, r5
    5a2c:	d1f3      	bne.n	5a16 <z_impl_device_get_binding+0xe>
    5a2e:	e012      	b.n	5a56 <z_impl_device_get_binding+0x4e>
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
    5a30:	4c0c      	ldr	r4, [pc, #48]	; (5a64 <z_impl_device_get_binding+0x5c>)
    5a32:	e000      	b.n	5a36 <z_impl_device_get_binding+0x2e>
    5a34:	3418      	adds	r4, #24
    5a36:	4b0c      	ldr	r3, [pc, #48]	; (5a68 <z_impl_device_get_binding+0x60>)
    5a38:	429c      	cmp	r4, r3
    5a3a:	d00b      	beq.n	5a54 <z_impl_device_get_binding+0x4c>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    5a3c:	4620      	mov	r0, r4
    5a3e:	f002 fe6a 	bl	8716 <z_device_ready>
    5a42:	2800      	cmp	r0, #0
    5a44:	d0f6      	beq.n	5a34 <z_impl_device_get_binding+0x2c>
    5a46:	6821      	ldr	r1, [r4, #0]
    5a48:	4628      	mov	r0, r5
    5a4a:	f002 f993 	bl	7d74 <strcmp>
    5a4e:	2800      	cmp	r0, #0
    5a50:	d1f0      	bne.n	5a34 <z_impl_device_get_binding+0x2c>
    5a52:	e000      	b.n	5a56 <z_impl_device_get_binding+0x4e>
			return dev;
		}
	}

	return NULL;
    5a54:	2400      	movs	r4, #0
}
    5a56:	4620      	mov	r0, r4
    5a58:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
    5a5a:	4604      	mov	r4, r0
    5a5c:	e7fb      	b.n	5a56 <z_impl_device_get_binding+0x4e>
    5a5e:	2400      	movs	r4, #0
    5a60:	e7f9      	b.n	5a56 <z_impl_device_get_binding+0x4e>
    5a62:	bf00      	nop
    5a64:	00008cc8 	.word	0x00008cc8
    5a68:	00008d10 	.word	0x00008d10

00005a6c <reason_to_str>:
	return thread_name;
}

static const char *reason_to_str(unsigned int reason)
{
	switch (reason) {
    5a6c:	2804      	cmp	r0, #4
    5a6e:	d80c      	bhi.n	5a8a <reason_to_str+0x1e>
    5a70:	e8df f000 	tbb	[pc, r0]
    5a74:	07050d03 	.word	0x07050d03
    5a78:	09          	.byte	0x09
    5a79:	00          	.byte	0x00
	case K_ERR_STACK_CHK_FAIL:
		return "Stack overflow";
	case K_ERR_KERNEL_OOPS:
		return "Kernel oops";
	case K_ERR_KERNEL_PANIC:
		return "Kernel panic";
    5a7a:	4806      	ldr	r0, [pc, #24]	; (5a94 <reason_to_str+0x28>)
    5a7c:	4770      	bx	lr
		return "Stack overflow";
    5a7e:	4806      	ldr	r0, [pc, #24]	; (5a98 <reason_to_str+0x2c>)
    5a80:	4770      	bx	lr
		return "Kernel oops";
    5a82:	4806      	ldr	r0, [pc, #24]	; (5a9c <reason_to_str+0x30>)
    5a84:	4770      	bx	lr
		return "Kernel panic";
    5a86:	4806      	ldr	r0, [pc, #24]	; (5aa0 <reason_to_str+0x34>)
    5a88:	4770      	bx	lr
	default:
		return "Unknown error";
    5a8a:	4806      	ldr	r0, [pc, #24]	; (5aa4 <reason_to_str+0x38>)
    5a8c:	4770      	bx	lr
		return "Unhandled interrupt";
    5a8e:	4806      	ldr	r0, [pc, #24]	; (5aa8 <reason_to_str+0x3c>)
	}
}
    5a90:	4770      	bx	lr
    5a92:	bf00      	nop
    5a94:	000098d0 	.word	0x000098d0
    5a98:	000098a4 	.word	0x000098a4
    5a9c:	000098b4 	.word	0x000098b4
    5aa0:	000098c0 	.word	0x000098c0
    5aa4:	00009880 	.word	0x00009880
    5aa8:	00009890 	.word	0x00009890

00005aac <thread_name_get>:
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    5aac:	b130      	cbz	r0, 5abc <thread_name_get+0x10>
{
    5aae:	b508      	push	{r3, lr}
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    5ab0:	f002 fea7 	bl	8802 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
    5ab4:	b120      	cbz	r0, 5ac0 <thread_name_get+0x14>
    5ab6:	7803      	ldrb	r3, [r0, #0]
    5ab8:	b123      	cbz	r3, 5ac4 <thread_name_get+0x18>
}
    5aba:	bd08      	pop	{r3, pc}
		thread_name = "unknown";
    5abc:	4802      	ldr	r0, [pc, #8]	; (5ac8 <thread_name_get+0x1c>)
}
    5abe:	4770      	bx	lr
		thread_name = "unknown";
    5ac0:	4801      	ldr	r0, [pc, #4]	; (5ac8 <thread_name_get+0x1c>)
    5ac2:	e7fa      	b.n	5aba <thread_name_get+0xe>
    5ac4:	4800      	ldr	r0, [pc, #0]	; (5ac8 <thread_name_get+0x1c>)
	return thread_name;
    5ac6:	e7f8      	b.n	5aba <thread_name_get+0xe>
    5ac8:	000098e0 	.word	0x000098e0

00005acc <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    5acc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5ad0:	b082      	sub	sp, #8
    5ad2:	4605      	mov	r5, r0
    5ad4:	460e      	mov	r6, r1
	__asm__ volatile(
    5ad6:	f04f 0320 	mov.w	r3, #32
    5ada:	f3ef 8711 	mrs	r7, BASEPRI
    5ade:	f383 8812 	msr	BASEPRI_MAX, r3
    5ae2:	f3bf 8f6f 	isb	sy
	return z_impl_z_current_get();
    5ae6:	f000 ff83 	bl	69f0 <z_impl_z_current_get>
    5aea:	4604      	mov	r4, r0
    5aec:	4b29      	ldr	r3, [pc, #164]	; (5b94 <z_fatal_error+0xc8>)
    5aee:	4a2a      	ldr	r2, [pc, #168]	; (5b98 <z_fatal_error+0xcc>)
    5af0:	1a9b      	subs	r3, r3, r2
    5af2:	08db      	lsrs	r3, r3, #3
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    5af4:	f04f 0800 	mov.w	r8, #0
    5af8:	2201      	movs	r2, #1
    5afa:	f362 0802 	bfi	r8, r2, #0, #3
    5afe:	f36f 08c5 	bfc	r8, #3, #3
    5b02:	f363 188f 	bfi	r8, r3, #6, #10
    5b06:	4628      	mov	r0, r5
    5b08:	f7ff ffb0 	bl	5a6c <reason_to_str>
    5b0c:	4602      	mov	r2, r0
    5b0e:	f8ad 8000 	strh.w	r8, [sp]
    5b12:	2300      	movs	r3, #0
    5b14:	4629      	mov	r1, r5
    5b16:	4821      	ldr	r0, [pc, #132]	; (5b9c <z_fatal_error+0xd0>)
    5b18:	f7fb ffae 	bl	1a78 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    5b1c:	b11e      	cbz	r6, 5b26 <z_fatal_error+0x5a>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    5b1e:	69f3      	ldr	r3, [r6, #28]
    5b20:	f3c3 0308 	ubfx	r3, r3, #0, #9
    5b24:	bb2b      	cbnz	r3, 5b72 <z_fatal_error+0xa6>
    5b26:	4b1b      	ldr	r3, [pc, #108]	; (5b94 <z_fatal_error+0xc8>)
    5b28:	4a1b      	ldr	r2, [pc, #108]	; (5b98 <z_fatal_error+0xcc>)
    5b2a:	1a9b      	subs	r3, r3, r2
    5b2c:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    5b2e:	f04f 0800 	mov.w	r8, #0
    5b32:	2201      	movs	r2, #1
    5b34:	f362 0802 	bfi	r8, r2, #0, #3
    5b38:	f36f 08c5 	bfc	r8, #3, #3
    5b3c:	f363 188f 	bfi	r8, r3, #6, #10
    5b40:	4620      	mov	r0, r4
    5b42:	f7ff ffb3 	bl	5aac <thread_name_get>
{
	if (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
    5b46:	f7fb fe5d 	bl	1804 <z_log_strdup>
    5b4a:	4602      	mov	r2, r0
    5b4c:	4643      	mov	r3, r8
    5b4e:	4621      	mov	r1, r4
    5b50:	4813      	ldr	r0, [pc, #76]	; (5ba0 <z_fatal_error+0xd4>)
    5b52:	f7fc f805 	bl	1b60 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    5b56:	4631      	mov	r1, r6
    5b58:	4628      	mov	r0, r5
    5b5a:	f7fe fdb9 	bl	46d0 <k_sys_fatal_error_handler>
	__asm__ volatile(
    5b5e:	f387 8811 	msr	BASEPRI, r7
    5b62:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    5b66:	4620      	mov	r0, r4
    5b68:	f7fd fb5c 	bl	3224 <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    5b6c:	b002      	add	sp, #8
    5b6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5b72:	4b08      	ldr	r3, [pc, #32]	; (5b94 <z_fatal_error+0xc8>)
    5b74:	4a08      	ldr	r2, [pc, #32]	; (5b98 <z_fatal_error+0xcc>)
    5b76:	1a9b      	subs	r3, r3, r2
    5b78:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Fault during interrupt handling\n");
    5b7a:	f04f 0100 	mov.w	r1, #0
    5b7e:	2201      	movs	r2, #1
    5b80:	f362 0102 	bfi	r1, r2, #0, #3
    5b84:	f36f 01c5 	bfc	r1, #3, #3
    5b88:	f363 118f 	bfi	r1, r3, #6, #10
    5b8c:	4805      	ldr	r0, [pc, #20]	; (5ba4 <z_fatal_error+0xd8>)
    5b8e:	f7fc f823 	bl	1bd8 <log_0>
    5b92:	e7c8      	b.n	5b26 <z_fatal_error+0x5a>
    5b94:	00008e70 	.word	0x00008e70
    5b98:	00008e48 	.word	0x00008e48
    5b9c:	000098e8 	.word	0x000098e8
    5ba0:	00009934 	.word	0x00009934
    5ba4:	00009910 	.word	0x00009910

00005ba8 <init_idle_thread>:
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    5ba8:	b5f0      	push	{r4, r5, r6, r7, lr}
    5baa:	b089      	sub	sp, #36	; 0x24
    5bac:	4604      	mov	r4, r0
	struct k_thread *thread = &z_idle_threads[i];
    5bae:	4b15      	ldr	r3, [pc, #84]	; (5c04 <init_idle_thread+0x5c>)
    5bb0:	25b0      	movs	r5, #176	; 0xb0
    5bb2:	fb05 3500 	mla	r5, r5, r0, r3
	k_thread_stack_t *stack = z_idle_stacks[i];
    5bb6:	4b14      	ldr	r3, [pc, #80]	; (5c08 <init_idle_thread+0x60>)
    5bb8:	f44f 76b0 	mov.w	r6, #352	; 0x160
    5bbc:	fb06 3600 	mla	r6, r6, r0, r3

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
    5bc0:	af06      	add	r7, sp, #24
    5bc2:	4603      	mov	r3, r0
    5bc4:	4a11      	ldr	r2, [pc, #68]	; (5c0c <init_idle_thread+0x64>)
    5bc6:	2108      	movs	r1, #8
    5bc8:	4638      	mov	r0, r7
    5bca:	f001 fae6 	bl	719a <snprintk>
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    5bce:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    5bd2:	480f      	ldr	r0, [pc, #60]	; (5c10 <init_idle_thread+0x68>)
    5bd4:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
	z_setup_new_thread(thread, stack,
    5bd8:	9705      	str	r7, [sp, #20]
    5bda:	2301      	movs	r3, #1
    5bdc:	9304      	str	r3, [sp, #16]
    5bde:	230f      	movs	r3, #15
    5be0:	9303      	str	r3, [sp, #12]
    5be2:	2300      	movs	r3, #0
    5be4:	9302      	str	r3, [sp, #8]
    5be6:	9301      	str	r3, [sp, #4]
    5be8:	9400      	str	r4, [sp, #0]
    5bea:	4b0a      	ldr	r3, [pc, #40]	; (5c14 <init_idle_thread+0x6c>)
    5bec:	f44f 72a0 	mov.w	r2, #320	; 0x140
    5bf0:	4631      	mov	r1, r6
    5bf2:	4628      	mov	r0, r5
    5bf4:	f000 f95a 	bl	5eac <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    5bf8:	7b6b      	ldrb	r3, [r5, #13]
    5bfa:	f023 0304 	bic.w	r3, r3, #4
    5bfe:	736b      	strb	r3, [r5, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    5c00:	b009      	add	sp, #36	; 0x24
    5c02:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5c04:	20000230 	.word	0x20000230
    5c08:	20001d40 	.word	0x20001d40
    5c0c:	0000994c 	.word	0x0000994c
    5c10:	200009bc 	.word	0x200009bc
    5c14:	00006011 	.word	0x00006011

00005c18 <prepare_multithreading>:
 *
 * @return initial stack pointer for the main thread
 */
__boot_func
static char *prepare_multithreading(void)
{
    5c18:	b570      	push	{r4, r5, r6, lr}
    5c1a:	b086      	sub	sp, #24
	char *stack_ptr;

	/* _kernel.ready_q is all zeroes */
	z_sched_init();
    5c1c:	f000 fe1c 	bl	6858 <z_sched_init>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_kernel.ready_q.cache = &z_main_thread;
    5c20:	4d1b      	ldr	r5, [pc, #108]	; (5c90 <prepare_multithreading+0x78>)
    5c22:	4b1c      	ldr	r3, [pc, #112]	; (5c94 <prepare_multithreading+0x7c>)
    5c24:	61dd      	str	r5, [r3, #28]
#endif
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    5c26:	4b1c      	ldr	r3, [pc, #112]	; (5c98 <prepare_multithreading+0x80>)
    5c28:	9305      	str	r3, [sp, #20]
    5c2a:	2301      	movs	r3, #1
    5c2c:	9304      	str	r3, [sp, #16]
    5c2e:	2400      	movs	r4, #0
    5c30:	9403      	str	r4, [sp, #12]
    5c32:	9402      	str	r4, [sp, #8]
    5c34:	9401      	str	r4, [sp, #4]
    5c36:	9400      	str	r4, [sp, #0]
    5c38:	4b18      	ldr	r3, [pc, #96]	; (5c9c <prepare_multithreading+0x84>)
    5c3a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    5c3e:	4918      	ldr	r1, [pc, #96]	; (5ca0 <prepare_multithreading+0x88>)
    5c40:	4628      	mov	r0, r5
    5c42:	f000 f933 	bl	5eac <z_setup_new_thread>
    5c46:	4606      	mov	r6, r0
    5c48:	7b6b      	ldrb	r3, [r5, #13]
    5c4a:	f023 0304 	bic.w	r3, r3, #4
    5c4e:	736b      	strb	r3, [r5, #13]
				       CONFIG_MAIN_STACK_SIZE, bg_thread_main,
				       NULL, NULL, NULL,
				       CONFIG_MAIN_THREAD_PRIORITY,
				       K_ESSENTIAL, "main");
	z_mark_thread_as_started(&z_main_thread);
	z_ready_thread(&z_main_thread);
    5c50:	4628      	mov	r0, r5
    5c52:	f002 fe76 	bl	8942 <z_ready_thread>

	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    5c56:	2c00      	cmp	r4, #0
    5c58:	dd02      	ble.n	5c60 <prepare_multithreading+0x48>
			(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]) +
			 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[i]));
	}

	return stack_ptr;
}
    5c5a:	4630      	mov	r0, r6
    5c5c:	b006      	add	sp, #24
    5c5e:	bd70      	pop	{r4, r5, r6, pc}
		init_idle_thread(i);
    5c60:	4620      	mov	r0, r4
    5c62:	f7ff ffa1 	bl	5ba8 <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    5c66:	4b0f      	ldr	r3, [pc, #60]	; (5ca4 <prepare_multithreading+0x8c>)
    5c68:	22b0      	movs	r2, #176	; 0xb0
    5c6a:	fb02 3204 	mla	r2, r2, r4, r3
    5c6e:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    5c72:	4b08      	ldr	r3, [pc, #32]	; (5c94 <prepare_multithreading+0x7c>)
    5c74:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    5c78:	60da      	str	r2, [r3, #12]
		_kernel.cpus[i].id = i;
    5c7a:	751c      	strb	r4, [r3, #20]
			(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]) +
    5c7c:	eb04 1184 	add.w	r1, r4, r4, lsl #6
    5c80:	4a09      	ldr	r2, [pc, #36]	; (5ca8 <prepare_multithreading+0x90>)
    5c82:	eb02 1241 	add.w	r2, r2, r1, lsl #5
    5c86:	f502 6202 	add.w	r2, r2, #2080	; 0x820
		_kernel.cpus[i].irq_stack =
    5c8a:	605a      	str	r2, [r3, #4]
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    5c8c:	3401      	adds	r4, #1
    5c8e:	e7e2      	b.n	5c56 <prepare_multithreading+0x3e>
    5c90:	200002e0 	.word	0x200002e0
    5c94:	200009bc 	.word	0x200009bc
    5c98:	00009958 	.word	0x00009958
    5c9c:	00005cad 	.word	0x00005cad
    5ca0:	20000d20 	.word	0x20000d20
    5ca4:	20000230 	.word	0x20000230
    5ca8:	20001ea0 	.word	0x20001ea0

00005cac <bg_thread_main>:
{
    5cac:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    5cae:	4b0a      	ldr	r3, [pc, #40]	; (5cd8 <bg_thread_main+0x2c>)
    5cb0:	2201      	movs	r2, #1
    5cb2:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    5cb4:	2002      	movs	r0, #2
    5cb6:	f7ff fe7f 	bl	59b8 <z_sys_init_run_level>
	boot_banner();
    5cba:	f001 f90f 	bl	6edc <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    5cbe:	2003      	movs	r0, #3
    5cc0:	f7ff fe7a 	bl	59b8 <z_sys_init_run_level>
	z_init_static_threads();
    5cc4:	f000 f956 	bl	5f74 <z_init_static_threads>
	main();
    5cc8:	f7fa fd44 	bl	754 <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    5ccc:	4a03      	ldr	r2, [pc, #12]	; (5cdc <bg_thread_main+0x30>)
    5cce:	7b13      	ldrb	r3, [r2, #12]
    5cd0:	f023 0301 	bic.w	r3, r3, #1
    5cd4:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    5cd6:	bd08      	pop	{r3, pc}
    5cd8:	200009ff 	.word	0x200009ff
    5cdc:	200002e0 	.word	0x200002e0

00005ce0 <switch_to_main_thread>:

__boot_func
static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
    5ce0:	b508      	push	{r3, lr}
    5ce2:	4601      	mov	r1, r0
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    5ce4:	4a01      	ldr	r2, [pc, #4]	; (5cec <switch_to_main_thread+0xc>)
    5ce6:	4802      	ldr	r0, [pc, #8]	; (5cf0 <switch_to_main_thread+0x10>)
    5ce8:	f7fc fe16 	bl	2918 <arch_switch_to_main_thread>
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
#endif
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    5cec:	00005cad 	.word	0x00005cad
    5cf0:	200002e0 	.word	0x200002e0

00005cf4 <z_bss_zero>:
{
    5cf4:	b508      	push	{r3, lr}
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    5cf6:	4803      	ldr	r0, [pc, #12]	; (5d04 <z_bss_zero+0x10>)
    5cf8:	4a03      	ldr	r2, [pc, #12]	; (5d08 <z_bss_zero+0x14>)
    5cfa:	1a12      	subs	r2, r2, r0
    5cfc:	2100      	movs	r1, #0
    5cfe:	f002 f867 	bl	7dd0 <memset>
}
    5d02:	bd08      	pop	{r3, pc}
    5d04:	20000128 	.word	0x20000128
    5d08:	20000a00 	.word	0x20000a00

00005d0c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    5d0c:	b500      	push	{lr}
    5d0e:	b0ad      	sub	sp, #180	; 0xb4
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
    5d10:	f7fb fcd6 	bl	16c0 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
    5d14:	4b1c      	ldr	r3, [pc, #112]	; (5d88 <z_cstart+0x7c>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    5d16:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    5d1a:	4c1c      	ldr	r4, [pc, #112]	; (5d8c <z_cstart+0x80>)
    5d1c:	6963      	ldr	r3, [r4, #20]
    5d1e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    5d22:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    5d24:	23e0      	movs	r3, #224	; 0xe0
    5d26:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    5d2a:	2500      	movs	r5, #0
    5d2c:	77e5      	strb	r5, [r4, #31]
    5d2e:	7625      	strb	r5, [r4, #24]
    5d30:	7665      	strb	r5, [r4, #25]
    5d32:	76a5      	strb	r5, [r4, #26]
    5d34:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    5d38:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5d3a:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    5d3e:	6263      	str	r3, [r4, #36]	; 0x24
    5d40:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    5d44:	f7fd f9de 	bl	3104 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    5d48:	f7fc fc6a 	bl	2620 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    5d4c:	f04f 33ff 	mov.w	r3, #4294967295
    5d50:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    5d52:	62e3      	str	r3, [r4, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
    5d54:	f7fd fb42 	bl	33dc <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    5d58:	f7fd fa7a 	bl	3250 <z_arm_configure_static_mpu_regions>
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    5d5c:	2401      	movs	r4, #1
    5d5e:	f88d 400d 	strb.w	r4, [sp, #13]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    5d62:	f88d 400c 	strb.w	r4, [sp, #12]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
    5d66:	9526      	str	r5, [sp, #152]	; 0x98
	dummy_thread->stack_info.size = 0U;
    5d68:	9527      	str	r5, [sp, #156]	; 0x9c
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    5d6a:	4b09      	ldr	r3, [pc, #36]	; (5d90 <z_cstart+0x84>)
    5d6c:	f8c3 d008 	str.w	sp, [r3, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    5d70:	f7ff fe16 	bl	59a0 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    5d74:	4628      	mov	r0, r5
    5d76:	f7ff fe1f 	bl	59b8 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    5d7a:	4620      	mov	r0, r4
    5d7c:	f7ff fe1c 	bl	59b8 <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
    5d80:	f7ff ff4a 	bl	5c18 <prepare_multithreading>
    5d84:	f7ff ffac 	bl	5ce0 <switch_to_main_thread>
    5d88:	200026c0 	.word	0x200026c0
    5d8c:	e000ed00 	.word	0xe000ed00
    5d90:	200009bc 	.word	0x200009bc

00005d94 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
    5d94:	b510      	push	{r4, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    5d96:	4c06      	ldr	r4, [pc, #24]	; (5db0 <init_mem_slab_module+0x1c>)
	int rc = 0;
    5d98:	2000      	movs	r0, #0
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    5d9a:	4b06      	ldr	r3, [pc, #24]	; (5db4 <init_mem_slab_module+0x20>)
    5d9c:	429c      	cmp	r4, r3
    5d9e:	d206      	bcs.n	5dae <init_mem_slab_module+0x1a>
		rc = create_free_list(slab);
    5da0:	4620      	mov	r0, r4
    5da2:	f002 fcc5 	bl	8730 <create_free_list>
		if (rc < 0) {
    5da6:	2800      	cmp	r0, #0
    5da8:	db01      	blt.n	5dae <init_mem_slab_module+0x1a>
	STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    5daa:	341c      	adds	r4, #28
    5dac:	e7f5      	b.n	5d9a <init_mem_slab_module+0x6>
		z_object_init(slab);
	}

out:
	return rc;
}
    5dae:	bd10      	pop	{r4, pc}
    5db0:	20000100 	.word	0x20000100
    5db4:	20000100 	.word	0x20000100

00005db8 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    5db8:	b5f0      	push	{r4, r5, r6, r7, lr}
    5dba:	b083      	sub	sp, #12
    5dbc:	460c      	mov	r4, r1
    5dbe:	461f      	mov	r7, r3
	__asm__ volatile(
    5dc0:	f04f 0320 	mov.w	r3, #32
    5dc4:	f3ef 8111 	mrs	r1, BASEPRI
    5dc8:	f383 8812 	msr	BASEPRI_MAX, r3
    5dcc:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
    5dd0:	6943      	ldr	r3, [r0, #20]
    5dd2:	b16b      	cbz	r3, 5df0 <k_mem_slab_alloc+0x38>
		/* take a free block */
		*mem = slab->free_list;
    5dd4:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    5dd6:	6943      	ldr	r3, [r0, #20]
    5dd8:	681b      	ldr	r3, [r3, #0]
    5dda:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    5ddc:	6983      	ldr	r3, [r0, #24]
    5dde:	3301      	adds	r3, #1
    5de0:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    5de2:	2000      	movs	r0, #0
	__asm__ volatile(
    5de4:	f381 8811 	msr	BASEPRI, r1
    5de8:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
    5dec:	b003      	add	sp, #12
    5dee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    5df0:	4616      	mov	r6, r2
    5df2:	f100 0508 	add.w	r5, r0, #8
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
    5df6:	ea56 0307 	orrs.w	r3, r6, r7
    5dfa:	d104      	bne.n	5e06 <k_mem_slab_alloc+0x4e>
		*mem = NULL;
    5dfc:	2300      	movs	r3, #0
    5dfe:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    5e00:	f06f 000b 	mvn.w	r0, #11
    5e04:	e7ee      	b.n	5de4 <k_mem_slab_alloc+0x2c>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    5e06:	e9cd 6700 	strd	r6, r7, [sp]
    5e0a:	4602      	mov	r2, r0
    5e0c:	4628      	mov	r0, r5
    5e0e:	f000 fbf9 	bl	6604 <z_pend_curr>
		if (result == 0) {
    5e12:	2800      	cmp	r0, #0
    5e14:	d1ea      	bne.n	5dec <k_mem_slab_alloc+0x34>
			*mem = _current->base.swap_data;
    5e16:	4b02      	ldr	r3, [pc, #8]	; (5e20 <k_mem_slab_alloc+0x68>)
    5e18:	689b      	ldr	r3, [r3, #8]
    5e1a:	695b      	ldr	r3, [r3, #20]
    5e1c:	6023      	str	r3, [r4, #0]
		return result;
    5e1e:	e7e5      	b.n	5dec <k_mem_slab_alloc+0x34>
    5e20:	200009bc 	.word	0x200009bc

00005e24 <z_thread_monitor_exit>:
	__asm__ volatile(
    5e24:	f04f 0320 	mov.w	r3, #32
    5e28:	f3ef 8111 	mrs	r1, BASEPRI
    5e2c:	f383 8812 	msr	BASEPRI_MAX, r3
    5e30:	f3bf 8f6f 	isb	sy
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
    5e34:	4b0a      	ldr	r3, [pc, #40]	; (5e60 <z_thread_monitor_exit+0x3c>)
    5e36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    5e38:	4283      	cmp	r3, r0
    5e3a:	d104      	bne.n	5e46 <z_thread_monitor_exit+0x22>
		_kernel.threads = _kernel.threads->next_thread;
    5e3c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    5e3e:	4b08      	ldr	r3, [pc, #32]	; (5e60 <z_thread_monitor_exit+0x3c>)
    5e40:	629a      	str	r2, [r3, #40]	; 0x28
    5e42:	e007      	b.n	5e54 <z_thread_monitor_exit+0x30>
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while ((prev_thread != NULL) &&
			(thread != prev_thread->next_thread)) {
			prev_thread = prev_thread->next_thread;
    5e44:	4613      	mov	r3, r2
		while ((prev_thread != NULL) &&
    5e46:	b113      	cbz	r3, 5e4e <z_thread_monitor_exit+0x2a>
			(thread != prev_thread->next_thread)) {
    5e48:	6f1a      	ldr	r2, [r3, #112]	; 0x70
		while ((prev_thread != NULL) &&
    5e4a:	4282      	cmp	r2, r0
    5e4c:	d1fa      	bne.n	5e44 <z_thread_monitor_exit+0x20>
		}
		if (prev_thread != NULL) {
    5e4e:	b10b      	cbz	r3, 5e54 <z_thread_monitor_exit+0x30>
			prev_thread->next_thread = thread->next_thread;
    5e50:	6f02      	ldr	r2, [r0, #112]	; 0x70
    5e52:	671a      	str	r2, [r3, #112]	; 0x70
	__asm__ volatile(
    5e54:	f381 8811 	msr	BASEPRI, r1
    5e58:	f3bf 8f6f 	isb	sy
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
    5e5c:	4770      	bx	lr
    5e5e:	bf00      	nop
    5e60:	200009bc 	.word	0x200009bc

00005e64 <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
    5e64:	b510      	push	{r4, lr}
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
    5e66:	4604      	mov	r4, r0
    5e68:	b140      	cbz	r0, 5e7c <z_impl_k_thread_name_set+0x18>
		thread = _current;
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
    5e6a:	2220      	movs	r2, #32
    5e6c:	f104 0074 	add.w	r0, r4, #116	; 0x74
    5e70:	f001 ff54 	bl	7d1c <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    5e74:	2000      	movs	r0, #0
    5e76:	f884 0093 	strb.w	r0, [r4, #147]	; 0x93

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    5e7a:	bd10      	pop	{r4, pc}
		thread = _current;
    5e7c:	4b01      	ldr	r3, [pc, #4]	; (5e84 <z_impl_k_thread_name_set+0x20>)
    5e7e:	689c      	ldr	r4, [r3, #8]
    5e80:	e7f3      	b.n	5e6a <z_impl_k_thread_name_set+0x6>
    5e82:	bf00      	nop
    5e84:	200009bc 	.word	0x200009bc

00005e88 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
    5e88:	b538      	push	{r3, r4, r5, lr}
    5e8a:	4614      	mov	r4, r2
    5e8c:	461d      	mov	r5, r3
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    5e8e:	ea54 0305 	orrs.w	r3, r4, r5
    5e92:	d102      	bne.n	5e9a <schedule_new_thread+0x12>
	z_impl_k_thread_start(thread);
    5e94:	f002 fcb7 	bl	8806 <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
    5e98:	bd38      	pop	{r3, r4, r5, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    5e9a:	462b      	mov	r3, r5
    5e9c:	4902      	ldr	r1, [pc, #8]	; (5ea8 <schedule_new_thread+0x20>)
    5e9e:	3018      	adds	r0, #24
    5ea0:	f000 fe36 	bl	6b10 <z_add_timeout>
    5ea4:	e7f8      	b.n	5e98 <schedule_new_thread+0x10>
    5ea6:	bf00      	nop
    5ea8:	0000897b 	.word	0x0000897b

00005eac <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    5eac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5eb0:	b085      	sub	sp, #20
    5eb2:	4604      	mov	r4, r0
    5eb4:	460f      	mov	r7, r1
    5eb6:	4615      	mov	r5, r2
    5eb8:	461e      	mov	r6, r3
    5eba:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
    5ebe:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    5ec2:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    5ec6:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    5eca:	f100 0358 	add.w	r3, r0, #88	; 0x58
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    5ece:	6583      	str	r3, [r0, #88]	; 0x58
	list->tail = (sys_dnode_t *)list;
    5ed0:	65c3      	str	r3, [r0, #92]	; 0x5c
	k_object_access_grant(new_thread, new_thread);
#endif
	z_waitq_init(&new_thread->join_queue);

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    5ed2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    5ed4:	2204      	movs	r2, #4
    5ed6:	9911      	ldr	r1, [sp, #68]	; 0x44
    5ed8:	f002 fc99 	bl	880e <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
    5edc:	462a      	mov	r2, r5
    5ede:	4639      	mov	r1, r7
    5ee0:	4620      	mov	r0, r4
    5ee2:	f002 fc76 	bl	87d2 <setup_thread_stack>
    5ee6:	4605      	mov	r5, r0
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    5ee8:	f8cd 8008 	str.w	r8, [sp, #8]
    5eec:	f8cd 9004 	str.w	r9, [sp, #4]
    5ef0:	f8cd a000 	str.w	sl, [sp]
    5ef4:	4633      	mov	r3, r6
    5ef6:	4602      	mov	r2, r0
    5ef8:	4639      	mov	r1, r7
    5efa:	4620      	mov	r0, r4
    5efc:	f7fc fcbc 	bl	2878 <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
    5f00:	2300      	movs	r3, #0
    5f02:	6563      	str	r3, [r4, #84]	; 0x54
#ifdef CONFIG_THREAD_CUSTOM_DATA
	/* Initialize custom data field (value is opaque to kernel) */
	new_thread->custom_data = NULL;
#endif
#ifdef CONFIG_THREAD_MONITOR
	new_thread->entry.pEntry = entry;
    5f04:	6626      	str	r6, [r4, #96]	; 0x60
	new_thread->entry.parameter1 = p1;
    5f06:	f8c4 a064 	str.w	sl, [r4, #100]	; 0x64
	new_thread->entry.parameter2 = p2;
    5f0a:	f8c4 9068 	str.w	r9, [r4, #104]	; 0x68
	new_thread->entry.parameter3 = p3;
    5f0e:	f8c4 806c 	str.w	r8, [r4, #108]	; 0x6c
	__asm__ volatile(
    5f12:	f04f 0320 	mov.w	r3, #32
    5f16:	f3ef 8211 	mrs	r2, BASEPRI
    5f1a:	f383 8812 	msr	BASEPRI_MAX, r3
    5f1e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	new_thread->next_thread = _kernel.threads;
    5f22:	4b13      	ldr	r3, [pc, #76]	; (5f70 <z_setup_new_thread+0xc4>)
    5f24:	6a99      	ldr	r1, [r3, #40]	; 0x28
    5f26:	6721      	str	r1, [r4, #112]	; 0x70
	_kernel.threads = new_thread;
    5f28:	629c      	str	r4, [r3, #40]	; 0x28
	__asm__ volatile(
    5f2a:	f382 8811 	msr	BASEPRI, r2
    5f2e:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
#ifdef CONFIG_THREAD_NAME
	if (name != NULL) {
    5f32:	f1bb 0f00 	cmp.w	fp, #0
    5f36:	d013      	beq.n	5f60 <z_setup_new_thread+0xb4>
		strncpy(new_thread->name, name,
    5f38:	221f      	movs	r2, #31
    5f3a:	4659      	mov	r1, fp
    5f3c:	f104 0074 	add.w	r0, r4, #116	; 0x74
    5f40:	f001 feec 	bl	7d1c <strncpy>
			CONFIG_THREAD_MAX_NAME_LEN - 1);
		/* Ensure NULL termination, truncate if longer */
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    5f44:	2300      	movs	r3, #0
    5f46:	f884 3093 	strb.w	r3, [r4, #147]	; 0x93
		new_thread->base.cpu_mask = -1; /* allow all cpus */
	}
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    5f4a:	4b09      	ldr	r3, [pc, #36]	; (5f70 <z_setup_new_thread+0xc4>)
    5f4c:	689b      	ldr	r3, [r3, #8]
    5f4e:	b15b      	cbz	r3, 5f68 <z_setup_new_thread+0xbc>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    5f50:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    5f54:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, create, new_thread);

	return stack_ptr;
}
    5f58:	4628      	mov	r0, r5
    5f5a:	b005      	add	sp, #20
    5f5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		new_thread->name[0] = '\0';
    5f60:	2300      	movs	r3, #0
    5f62:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
    5f66:	e7f0      	b.n	5f4a <z_setup_new_thread+0x9e>
		new_thread->resource_pool = NULL;
    5f68:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
		return stack_ptr;
    5f6c:	e7f4      	b.n	5f58 <z_setup_new_thread+0xac>
    5f6e:	bf00      	nop
    5f70:	200009bc 	.word	0x200009bc

00005f74 <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    5f74:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
    5f78:	b086      	sub	sp, #24
	_FOREACH_STATIC_THREAD(thread_data) {
    5f7a:	4c23      	ldr	r4, [pc, #140]	; (6008 <z_init_static_threads+0x94>)
    5f7c:	4b23      	ldr	r3, [pc, #140]	; (600c <z_init_static_threads+0x98>)
    5f7e:	429c      	cmp	r4, r3
    5f80:	d215      	bcs.n	5fae <z_init_static_threads+0x3a>
		z_setup_new_thread(
    5f82:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    5f84:	9305      	str	r3, [sp, #20]
    5f86:	6a23      	ldr	r3, [r4, #32]
    5f88:	9304      	str	r3, [sp, #16]
    5f8a:	69e3      	ldr	r3, [r4, #28]
    5f8c:	9303      	str	r3, [sp, #12]
    5f8e:	69a3      	ldr	r3, [r4, #24]
    5f90:	9302      	str	r3, [sp, #8]
    5f92:	6963      	ldr	r3, [r4, #20]
    5f94:	9301      	str	r3, [sp, #4]
    5f96:	6923      	ldr	r3, [r4, #16]
    5f98:	9300      	str	r3, [sp, #0]
    5f9a:	68e3      	ldr	r3, [r4, #12]
    5f9c:	68a2      	ldr	r2, [r4, #8]
    5f9e:	6861      	ldr	r1, [r4, #4]
    5fa0:	6820      	ldr	r0, [r4, #0]
    5fa2:	f7ff ff83 	bl	5eac <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
    5fa6:	6823      	ldr	r3, [r4, #0]
    5fa8:	655c      	str	r4, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    5faa:	3430      	adds	r4, #48	; 0x30
    5fac:	e7e6      	b.n	5f7c <z_init_static_threads+0x8>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    5fae:	f000 f9e1 	bl	6374 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    5fb2:	4c15      	ldr	r4, [pc, #84]	; (6008 <z_init_static_threads+0x94>)
    5fb4:	e01b      	b.n	5fee <z_init_static_threads+0x7a>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
			schedule_new_thread(thread_data->init_thread,
    5fb6:	6826      	ldr	r6, [r4, #0]
					    K_MSEC(thread_data->init_delay));
    5fb8:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    5fbc:	ea4f 79e3 	mov.w	r9, r3, asr #31
    5fc0:	ea4f 31c9 	mov.w	r1, r9, lsl #15
    5fc4:	ea41 4153 	orr.w	r1, r1, r3, lsr #17
    5fc8:	03d8      	lsls	r0, r3, #15
    5fca:	f240 35e7 	movw	r5, #999	; 0x3e7
    5fce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    5fd2:	2300      	movs	r3, #0
    5fd4:	1940      	adds	r0, r0, r5
    5fd6:	f04f 0500 	mov.w	r5, #0
    5fda:	eb45 0101 	adc.w	r1, r5, r1
    5fde:	f7fa fa3f 	bl	460 <__aeabi_uldivmod>
    5fe2:	4602      	mov	r2, r0
    5fe4:	460b      	mov	r3, r1
			schedule_new_thread(thread_data->init_thread,
    5fe6:	4630      	mov	r0, r6
    5fe8:	f7ff ff4e 	bl	5e88 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
    5fec:	3430      	adds	r4, #48	; 0x30
    5fee:	4b07      	ldr	r3, [pc, #28]	; (600c <z_init_static_threads+0x98>)
    5ff0:	429c      	cmp	r4, r3
    5ff2:	d204      	bcs.n	5ffe <z_init_static_threads+0x8a>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    5ff4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5ff6:	f1b3 3fff 	cmp.w	r3, #4294967295
    5ffa:	d0f7      	beq.n	5fec <z_init_static_threads+0x78>
    5ffc:	e7db      	b.n	5fb6 <z_init_static_threads+0x42>
		}
	}
	k_sched_unlock();
    5ffe:	f000 fbb7 	bl	6770 <k_sched_unlock>
}
    6002:	b006      	add	sp, #24
    6004:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    6008:	20000100 	.word	0x20000100
    600c:	20000100 	.word	0x20000100

00006010 <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
    6010:	b508      	push	{r3, lr}
    6012:	e001      	b.n	6018 <idle+0x8>
	arch_cpu_idle();
    6014:	f7fc fb0a 	bl	262c <arch_cpu_idle>
	__asm__ volatile(
    6018:	f04f 0220 	mov.w	r2, #32
    601c:	f3ef 8311 	mrs	r3, BASEPRI
    6020:	f382 8812 	msr	BASEPRI_MAX, r2
    6024:	f3bf 8f6f 	isb	sy
		 * higher level construct.
		 */
		(void) arch_irq_lock();

#ifdef CONFIG_PM
		_kernel.idle = z_get_next_timeout_expiry();
    6028:	f002 fdb1 	bl	8b8e <z_get_next_timeout_expiry>
    602c:	4b03      	ldr	r3, [pc, #12]	; (603c <idle+0x2c>)
    602e:	6198      	str	r0, [r3, #24]
		 * processing in those cases i.e. skips k_cpu_idle().
		 * The kernel's idle processing re-enables interrupts
		 * which is essential for the kernel's scheduling
		 * logic.
		 */
		if (pm_system_suspend(_kernel.idle) == false) {
    6030:	f7fc fa38 	bl	24a4 <pm_system_suspend>
    6034:	2800      	cmp	r0, #0
    6036:	d1ef      	bne.n	6018 <idle+0x8>
    6038:	e7ec      	b.n	6014 <idle+0x4>
    603a:	bf00      	nop
    603c:	200009bc 	.word	0x200009bc

00006040 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    6040:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6044:	b083      	sub	sp, #12
    6046:	4604      	mov	r4, r0
    6048:	461d      	mov	r5, r3
    604a:	f04f 0320 	mov.w	r3, #32
    604e:	f3ef 8711 	mrs	r7, BASEPRI
    6052:	f383 8812 	msr	BASEPRI_MAX, r3
    6056:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    605a:	68c1      	ldr	r1, [r0, #12]
    605c:	b999      	cbnz	r1, 6086 <z_impl_k_mutex_lock+0x46>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
    605e:	2900      	cmp	r1, #0
    6060:	d14f      	bne.n	6102 <z_impl_k_mutex_lock+0xc2>
    6062:	4b3a      	ldr	r3, [pc, #232]	; (614c <z_impl_k_mutex_lock+0x10c>)
    6064:	689b      	ldr	r3, [r3, #8]
    6066:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    606a:	6123      	str	r3, [r4, #16]
					mutex->owner_orig_prio;

		mutex->lock_count++;
    606c:	3101      	adds	r1, #1
    606e:	60e1      	str	r1, [r4, #12]
		mutex->owner = _current;
    6070:	4b36      	ldr	r3, [pc, #216]	; (614c <z_impl_k_mutex_lock+0x10c>)
    6072:	689b      	ldr	r3, [r3, #8]
    6074:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
    6076:	f387 8811 	msr	BASEPRI, r7
    607a:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
    607e:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    6080:	b003      	add	sp, #12
    6082:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    6086:	4616      	mov	r6, r2
	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    6088:	6882      	ldr	r2, [r0, #8]
    608a:	4b30      	ldr	r3, [pc, #192]	; (614c <z_impl_k_mutex_lock+0x10c>)
    608c:	689b      	ldr	r3, [r3, #8]
    608e:	429a      	cmp	r2, r3
    6090:	d0e5      	beq.n	605e <z_impl_k_mutex_lock+0x1e>
	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    6092:	ea55 0106 	orrs.w	r1, r5, r6
    6096:	bf0c      	ite	eq
    6098:	f04f 0801 	moveq.w	r8, #1
    609c:	f04f 0800 	movne.w	r8, #0
    60a0:	d031      	beq.n	6106 <z_impl_k_mutex_lock+0xc6>
					    mutex->owner->base.prio);
    60a2:	f992 900e 	ldrsb.w	r9, [r2, #14]
	new_prio = new_prio_for_inheritance(_current->base.prio,
    60a6:	4649      	mov	r1, r9
    60a8:	f993 000e 	ldrsb.w	r0, [r3, #14]
    60ac:	f002 fbe2 	bl	8874 <new_prio_for_inheritance>
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    60b0:	4581      	cmp	r9, r0
    60b2:	dc2f      	bgt.n	6114 <z_impl_k_mutex_lock+0xd4>
	bool resched = false;
    60b4:	f04f 0900 	mov.w	r9, #0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    60b8:	9600      	str	r6, [sp, #0]
    60ba:	9501      	str	r5, [sp, #4]
    60bc:	4622      	mov	r2, r4
    60be:	4639      	mov	r1, r7
    60c0:	4823      	ldr	r0, [pc, #140]	; (6150 <z_impl_k_mutex_lock+0x110>)
    60c2:	f000 fa9f 	bl	6604 <z_pend_curr>
	if (got_mutex == 0) {
    60c6:	2800      	cmp	r0, #0
    60c8:	d0da      	beq.n	6080 <z_impl_k_mutex_lock+0x40>
	__asm__ volatile(
    60ca:	f04f 0320 	mov.w	r3, #32
    60ce:	f3ef 8511 	mrs	r5, BASEPRI
    60d2:	f383 8812 	msr	BASEPRI_MAX, r3
    60d6:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    60da:	6823      	ldr	r3, [r4, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    60dc:	42a3      	cmp	r3, r4
    60de:	d01f      	beq.n	6120 <z_impl_k_mutex_lock+0xe0>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    60e0:	b1f3      	cbz	r3, 6120 <z_impl_k_mutex_lock+0xe0>
    60e2:	6921      	ldr	r1, [r4, #16]
    60e4:	f993 000e 	ldrsb.w	r0, [r3, #14]
    60e8:	f002 fbc4 	bl	8874 <new_prio_for_inheritance>
    60ec:	4601      	mov	r1, r0
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    60ee:	4620      	mov	r0, r4
    60f0:	f002 fbcb 	bl	888a <adjust_owner_prio>
    60f4:	b9b0      	cbnz	r0, 6124 <z_impl_k_mutex_lock+0xe4>
    60f6:	f1b9 0f00 	cmp.w	r9, #0
    60fa:	d015      	beq.n	6128 <z_impl_k_mutex_lock+0xe8>
    60fc:	f04f 0801 	mov.w	r8, #1
    6100:	e012      	b.n	6128 <z_impl_k_mutex_lock+0xe8>
					_current->base.prio :
    6102:	6923      	ldr	r3, [r4, #16]
    6104:	e7b1      	b.n	606a <z_impl_k_mutex_lock+0x2a>
	__asm__ volatile(
    6106:	f387 8811 	msr	BASEPRI, r7
    610a:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    610e:	f06f 000f 	mvn.w	r0, #15
    6112:	e7b5      	b.n	6080 <z_impl_k_mutex_lock+0x40>
		resched = adjust_owner_prio(mutex, new_prio);
    6114:	4601      	mov	r1, r0
    6116:	4620      	mov	r0, r4
    6118:	f002 fbb7 	bl	888a <adjust_owner_prio>
    611c:	4681      	mov	r9, r0
    611e:	e7cb      	b.n	60b8 <z_impl_k_mutex_lock+0x78>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    6120:	6921      	ldr	r1, [r4, #16]
    6122:	e7e4      	b.n	60ee <z_impl_k_mutex_lock+0xae>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    6124:	f04f 0801 	mov.w	r8, #1
	if (resched) {
    6128:	f1b8 0f00 	cmp.w	r8, #0
    612c:	d106      	bne.n	613c <z_impl_k_mutex_lock+0xfc>
    612e:	f385 8811 	msr	BASEPRI, r5
    6132:	f3bf 8f6f 	isb	sy
	return -EAGAIN;
    6136:	f06f 000a 	mvn.w	r0, #10
    613a:	e7a1      	b.n	6080 <z_impl_k_mutex_lock+0x40>
		z_reschedule(&lock, key);
    613c:	4629      	mov	r1, r5
    613e:	4804      	ldr	r0, [pc, #16]	; (6150 <z_impl_k_mutex_lock+0x110>)
    6140:	f000 f8fc 	bl	633c <z_reschedule>
	return -EAGAIN;
    6144:	f06f 000a 	mvn.w	r0, #10
    6148:	e79a      	b.n	6080 <z_impl_k_mutex_lock+0x40>
    614a:	bf00      	nop
    614c:	200009bc 	.word	0x200009bc
    6150:	200009e8 	.word	0x200009e8

00006154 <z_impl_k_mutex_unlock>:

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    6154:	6882      	ldr	r2, [r0, #8]
    6156:	2a00      	cmp	r2, #0
    6158:	d035      	beq.n	61c6 <z_impl_k_mutex_unlock+0x72>
{
    615a:	b538      	push	{r3, r4, r5, lr}
    615c:	4604      	mov	r4, r0
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    615e:	4b1d      	ldr	r3, [pc, #116]	; (61d4 <z_impl_k_mutex_unlock+0x80>)
    6160:	689b      	ldr	r3, [r3, #8]
    6162:	429a      	cmp	r2, r3
    6164:	d132      	bne.n	61cc <z_impl_k_mutex_unlock+0x78>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    6166:	7bda      	ldrb	r2, [r3, #15]
    6168:	3a01      	subs	r2, #1
    616a:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    616c:	68c3      	ldr	r3, [r0, #12]
    616e:	2b01      	cmp	r3, #1
    6170:	d905      	bls.n	617e <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
    6172:	3b01      	subs	r3, #1
    6174:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    6176:	f000 fafb 	bl	6770 <k_sched_unlock>

	return 0;
    617a:	2000      	movs	r0, #0
}
    617c:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    617e:	f04f 0320 	mov.w	r3, #32
    6182:	f3ef 8511 	mrs	r5, BASEPRI
    6186:	f383 8812 	msr	BASEPRI_MAX, r3
    618a:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    618e:	6901      	ldr	r1, [r0, #16]
    6190:	f002 fb7b 	bl	888a <adjust_owner_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    6194:	4620      	mov	r0, r4
    6196:	f002 fc96 	bl	8ac6 <z_unpend_first_thread>
	mutex->owner = new_owner;
    619a:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    619c:	b160      	cbz	r0, 61b8 <z_impl_k_mutex_unlock+0x64>
		mutex->owner_orig_prio = new_owner->base.prio;
    619e:	f990 300e 	ldrsb.w	r3, [r0, #14]
    61a2:	6123      	str	r3, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    61a4:	2300      	movs	r3, #0
    61a6:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
		z_ready_thread(new_owner);
    61aa:	f002 fbca 	bl	8942 <z_ready_thread>
		z_reschedule(&lock, key);
    61ae:	4629      	mov	r1, r5
    61b0:	4809      	ldr	r0, [pc, #36]	; (61d8 <z_impl_k_mutex_unlock+0x84>)
    61b2:	f000 f8c3 	bl	633c <z_reschedule>
    61b6:	e7de      	b.n	6176 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
    61b8:	2300      	movs	r3, #0
    61ba:	60e3      	str	r3, [r4, #12]
	__asm__ volatile(
    61bc:	f385 8811 	msr	BASEPRI, r5
    61c0:	f3bf 8f6f 	isb	sy
    61c4:	e7d7      	b.n	6176 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
    61c6:	f06f 0015 	mvn.w	r0, #21
}
    61ca:	4770      	bx	lr
		return -EPERM;
    61cc:	f04f 30ff 	mov.w	r0, #4294967295
    61d0:	e7d4      	b.n	617c <z_impl_k_mutex_unlock+0x28>
    61d2:	bf00      	nop
    61d4:	200009bc 	.word	0x200009bc
    61d8:	200009e8 	.word	0x200009e8

000061dc <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    61dc:	b538      	push	{r3, r4, r5, lr}
    61de:	4604      	mov	r4, r0
	__asm__ volatile(
    61e0:	f04f 0320 	mov.w	r3, #32
    61e4:	f3ef 8511 	mrs	r5, BASEPRI
    61e8:	f383 8812 	msr	BASEPRI_MAX, r3
    61ec:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    61f0:	f002 fc69 	bl	8ac6 <z_unpend_first_thread>

	if (thread != NULL) {
    61f4:	b148      	cbz	r0, 620a <z_impl_k_sem_give+0x2e>
    61f6:	2200      	movs	r2, #0
    61f8:	f8c0 20ac 	str.w	r2, [r0, #172]	; 0xac
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    61fc:	f002 fba1 	bl	8942 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    6200:	4629      	mov	r1, r5
    6202:	4807      	ldr	r0, [pc, #28]	; (6220 <z_impl_k_sem_give+0x44>)
    6204:	f000 f89a 	bl	633c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    6208:	bd38      	pop	{r3, r4, r5, pc}
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    620a:	68a3      	ldr	r3, [r4, #8]
    620c:	68e2      	ldr	r2, [r4, #12]
    620e:	4293      	cmp	r3, r2
    6210:	d003      	beq.n	621a <z_impl_k_sem_give+0x3e>
    6212:	2201      	movs	r2, #1
    6214:	4413      	add	r3, r2
    6216:	60a3      	str	r3, [r4, #8]
}
    6218:	e7f2      	b.n	6200 <z_impl_k_sem_give+0x24>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    621a:	2200      	movs	r2, #0
    621c:	e7fa      	b.n	6214 <z_impl_k_sem_give+0x38>
    621e:	bf00      	nop
    6220:	200009e8 	.word	0x200009e8

00006224 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    6224:	b530      	push	{r4, r5, lr}
    6226:	b083      	sub	sp, #12
    6228:	461d      	mov	r5, r3
    622a:	f04f 0320 	mov.w	r3, #32
    622e:	f3ef 8111 	mrs	r1, BASEPRI
    6232:	f383 8812 	msr	BASEPRI_MAX, r3
    6236:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    623a:	6883      	ldr	r3, [r0, #8]
    623c:	b143      	cbz	r3, 6250 <z_impl_k_sem_take+0x2c>
		sem->count--;
    623e:	3b01      	subs	r3, #1
    6240:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
    6242:	f381 8811 	msr	BASEPRI, r1
    6246:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    624a:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    624c:	b003      	add	sp, #12
    624e:	bd30      	pop	{r4, r5, pc}
    6250:	4614      	mov	r4, r2
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    6252:	ea54 0305 	orrs.w	r3, r4, r5
    6256:	d006      	beq.n	6266 <z_impl_k_sem_take+0x42>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    6258:	e9cd 4500 	strd	r4, r5, [sp]
    625c:	4602      	mov	r2, r0
    625e:	4805      	ldr	r0, [pc, #20]	; (6274 <z_impl_k_sem_take+0x50>)
    6260:	f000 f9d0 	bl	6604 <z_pend_curr>
	return ret;
    6264:	e7f2      	b.n	624c <z_impl_k_sem_take+0x28>
    6266:	f381 8811 	msr	BASEPRI, r1
    626a:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    626e:	f06f 000f 	mvn.w	r0, #15
    6272:	e7eb      	b.n	624c <z_impl_k_sem_take+0x28>
    6274:	200009e8 	.word	0x200009e8

00006278 <add_thread_timeout>:
		z_priq_wait_add(&wait_q->waitq, thread);
	}
}

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
    6278:	b538      	push	{r3, r4, r5, lr}
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    627a:	f1b3 3fff 	cmp.w	r3, #4294967295
    627e:	bf08      	it	eq
    6280:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    6284:	d100      	bne.n	6288 <add_thread_timeout+0x10>
		z_add_thread_timeout(thread, timeout);
	}
}
    6286:	bd38      	pop	{r3, r4, r5, pc}
    6288:	4902      	ldr	r1, [pc, #8]	; (6294 <add_thread_timeout+0x1c>)
    628a:	3018      	adds	r0, #24
    628c:	f000 fc40 	bl	6b10 <z_add_timeout>
    6290:	e7f9      	b.n	6286 <add_thread_timeout+0xe>
    6292:	bf00      	nop
    6294:	0000897b 	.word	0x0000897b

00006298 <z_reset_time_slice>:
{
    6298:	b508      	push	{r3, lr}
	if (slice_time != 0) {
    629a:	4b08      	ldr	r3, [pc, #32]	; (62bc <z_reset_time_slice+0x24>)
    629c:	681b      	ldr	r3, [r3, #0]
    629e:	b903      	cbnz	r3, 62a2 <z_reset_time_slice+0xa>
}
    62a0:	bd08      	pop	{r3, pc}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    62a2:	f7fe fa0b 	bl	46bc <sys_clock_elapsed>
    62a6:	4603      	mov	r3, r0
    62a8:	4a04      	ldr	r2, [pc, #16]	; (62bc <z_reset_time_slice+0x24>)
    62aa:	6810      	ldr	r0, [r2, #0]
    62ac:	4403      	add	r3, r0
    62ae:	4a04      	ldr	r2, [pc, #16]	; (62c0 <z_reset_time_slice+0x28>)
    62b0:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    62b2:	2100      	movs	r1, #0
    62b4:	f002 fc81 	bl	8bba <z_set_timeout_expiry>
}
    62b8:	e7f2      	b.n	62a0 <z_reset_time_slice+0x8>
    62ba:	bf00      	nop
    62bc:	200009f0 	.word	0x200009f0
    62c0:	200009bc 	.word	0x200009bc

000062c4 <k_sched_time_slice_set>:
{
    62c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    62c8:	4606      	mov	r6, r0
    62ca:	4688      	mov	r8, r1
	LOCKED(&sched_spinlock) {
    62cc:	2300      	movs	r3, #0
	__asm__ volatile(
    62ce:	f04f 0220 	mov.w	r2, #32
    62d2:	f3ef 8711 	mrs	r7, BASEPRI
    62d6:	f382 8812 	msr	BASEPRI_MAX, r2
    62da:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    62de:	e009      	b.n	62f4 <k_sched_time_slice_set+0x30>
		slice_max_prio = prio;
    62e0:	4b13      	ldr	r3, [pc, #76]	; (6330 <k_sched_time_slice_set+0x6c>)
    62e2:	f8c3 8000 	str.w	r8, [r3]
		z_reset_time_slice();
    62e6:	f7ff ffd7 	bl	6298 <z_reset_time_slice>
	__asm__ volatile(
    62ea:	f387 8811 	msr	BASEPRI, r7
    62ee:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    62f2:	2301      	movs	r3, #1
    62f4:	b9cb      	cbnz	r3, 632a <k_sched_time_slice_set+0x66>
		_current_cpu->slice_ticks = 0;
    62f6:	2300      	movs	r3, #0
    62f8:	4a0e      	ldr	r2, [pc, #56]	; (6334 <k_sched_time_slice_set+0x70>)
    62fa:	6113      	str	r3, [r2, #16]
			return (uint32_t)((t * to_hz + off) / from_hz);
    62fc:	0c75      	lsrs	r5, r6, #17
    62fe:	03f4      	lsls	r4, r6, #15
    6300:	f240 30e7 	movw	r0, #999	; 0x3e7
    6304:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6308:	2300      	movs	r3, #0
    630a:	1820      	adds	r0, r4, r0
    630c:	f04f 0100 	mov.w	r1, #0
    6310:	eb45 0101 	adc.w	r1, r5, r1
    6314:	f7fa f8a4 	bl	460 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    6318:	4b07      	ldr	r3, [pc, #28]	; (6338 <k_sched_time_slice_set+0x74>)
    631a:	6018      	str	r0, [r3, #0]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    631c:	2e00      	cmp	r6, #0
    631e:	dddf      	ble.n	62e0 <k_sched_time_slice_set+0x1c>
			slice_time = MAX(2, slice_time);
    6320:	2802      	cmp	r0, #2
    6322:	bfb8      	it	lt
    6324:	2002      	movlt	r0, #2
    6326:	6018      	str	r0, [r3, #0]
    6328:	e7da      	b.n	62e0 <k_sched_time_slice_set+0x1c>
}
    632a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    632e:	bf00      	nop
    6330:	200009ec 	.word	0x200009ec
    6334:	200009bc 	.word	0x200009bc
    6338:	200009f0 	.word	0x200009f0

0000633c <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    633c:	b508      	push	{r3, lr}
	if (resched(key.key) && need_swap()) {
    633e:	4608      	mov	r0, r1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    6340:	b921      	cbnz	r1, 634c <z_reschedule+0x10>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    6342:	f3ef 8305 	mrs	r3, IPSR
    6346:	b913      	cbnz	r3, 634e <z_reschedule+0x12>
    6348:	2101      	movs	r1, #1
    634a:	e000      	b.n	634e <z_reschedule+0x12>
    634c:	2100      	movs	r1, #0
	if (resched(key.key) && need_swap()) {
    634e:	f011 0f01 	tst.w	r1, #1
    6352:	d007      	beq.n	6364 <z_reschedule+0x28>
	new_thread = _kernel.ready_q.cache;
    6354:	4b06      	ldr	r3, [pc, #24]	; (6370 <z_reschedule+0x34>)
    6356:	69da      	ldr	r2, [r3, #28]
	return new_thread != _current;
    6358:	689b      	ldr	r3, [r3, #8]
	if (resched(key.key) && need_swap()) {
    635a:	429a      	cmp	r2, r3
    635c:	d002      	beq.n	6364 <z_reschedule+0x28>
	ret = arch_swap(key);
    635e:	f7fc fa33 	bl	27c8 <arch_swap>
		z_swap(lock, key);
    6362:	e003      	b.n	636c <z_reschedule+0x30>
    6364:	f380 8811 	msr	BASEPRI, r0
    6368:	f3bf 8f6f 	isb	sy
	} else {
		k_spin_unlock(lock, key);
	}
}
    636c:	bd08      	pop	{r3, pc}
    636e:	bf00      	nop
    6370:	200009bc 	.word	0x200009bc

00006374 <k_sched_lock>:
	}
}

void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
    6374:	2300      	movs	r3, #0
	__asm__ volatile(
    6376:	f04f 0220 	mov.w	r2, #32
    637a:	f3ef 8111 	mrs	r1, BASEPRI
    637e:	f382 8812 	msr	BASEPRI_MAX, r2
    6382:	f3bf 8f6f 	isb	sy
    6386:	b953      	cbnz	r3, 639e <k_sched_lock+0x2a>
    6388:	4b05      	ldr	r3, [pc, #20]	; (63a0 <k_sched_lock+0x2c>)
    638a:	689a      	ldr	r2, [r3, #8]
    638c:	7bd3      	ldrb	r3, [r2, #15]
    638e:	3b01      	subs	r3, #1
    6390:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    6392:	f381 8811 	msr	BASEPRI, r1
    6396:	f3bf 8f6f 	isb	sy
    639a:	2301      	movs	r3, #1
    639c:	e7f3      	b.n	6386 <k_sched_lock+0x12>
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    639e:	4770      	bx	lr
    63a0:	200009bc 	.word	0x200009bc

000063a4 <update_cache>:
{
    63a4:	b538      	push	{r3, r4, r5, lr}
    63a6:	4604      	mov	r4, r0
	return _priq_run_best(curr_cpu_runq());
    63a8:	480f      	ldr	r0, [pc, #60]	; (63e8 <update_cache+0x44>)
    63aa:	f002 fac3 	bl	8934 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    63ae:	4605      	mov	r5, r0
    63b0:	b170      	cbz	r0, 63d0 <update_cache+0x2c>
	if (preempt_ok != 0) {
    63b2:	b984      	cbnz	r4, 63d6 <update_cache+0x32>
	if (z_is_thread_prevented_from_running(_current)) {
    63b4:	4b0d      	ldr	r3, [pc, #52]	; (63ec <update_cache+0x48>)
    63b6:	689b      	ldr	r3, [r3, #8]
	uint8_t state = thread->base.thread_state;
    63b8:	7b5a      	ldrb	r2, [r3, #13]
    63ba:	f012 0f1f 	tst.w	r2, #31
    63be:	d10a      	bne.n	63d6 <update_cache+0x32>
	return node->next != NULL;
    63c0:	69aa      	ldr	r2, [r5, #24]
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    63c2:	b942      	cbnz	r2, 63d6 <update_cache+0x32>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    63c4:	89da      	ldrh	r2, [r3, #14]
	if (is_preempt(_current) || is_metairq(thread)) {
    63c6:	2a7f      	cmp	r2, #127	; 0x7f
    63c8:	d905      	bls.n	63d6 <update_cache+0x32>
		_kernel.ready_q.cache = _current;
    63ca:	4a08      	ldr	r2, [pc, #32]	; (63ec <update_cache+0x48>)
    63cc:	61d3      	str	r3, [r2, #28]
    63ce:	e00a      	b.n	63e6 <update_cache+0x42>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    63d0:	4b06      	ldr	r3, [pc, #24]	; (63ec <update_cache+0x48>)
    63d2:	68dd      	ldr	r5, [r3, #12]
    63d4:	e7ed      	b.n	63b2 <update_cache+0xe>
		if (thread != _current) {
    63d6:	4b05      	ldr	r3, [pc, #20]	; (63ec <update_cache+0x48>)
    63d8:	689b      	ldr	r3, [r3, #8]
    63da:	42ab      	cmp	r3, r5
    63dc:	d001      	beq.n	63e2 <update_cache+0x3e>
			z_reset_time_slice();
    63de:	f7ff ff5b 	bl	6298 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    63e2:	4b02      	ldr	r3, [pc, #8]	; (63ec <update_cache+0x48>)
    63e4:	61dd      	str	r5, [r3, #28]
}
    63e6:	bd38      	pop	{r3, r4, r5, pc}
    63e8:	200009dc 	.word	0x200009dc
    63ec:	200009bc 	.word	0x200009bc

000063f0 <move_thread_to_end_of_prio_q>:
{
    63f0:	b538      	push	{r3, r4, r5, lr}
    63f2:	4605      	mov	r5, r0
	return (thread->base.thread_state & state) != 0U;
    63f4:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    63f6:	f990 300d 	ldrsb.w	r3, [r0, #13]
    63fa:	2b00      	cmp	r3, #0
    63fc:	db28      	blt.n	6450 <move_thread_to_end_of_prio_q+0x60>
	thread->base.thread_state |= _THREAD_QUEUED;
    63fe:	7b6b      	ldrb	r3, [r5, #13]
    6400:	f063 037f 	orn	r3, r3, #127	; 0x7f
    6404:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    6406:	4b1a      	ldr	r3, [pc, #104]	; (6470 <move_thread_to_end_of_prio_q+0x80>)
    6408:	f853 4f20 	ldr.w	r4, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    640c:	429c      	cmp	r4, r3
    640e:	d02d      	beq.n	646c <move_thread_to_end_of_prio_q+0x7c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6410:	b16c      	cbz	r4, 642e <move_thread_to_end_of_prio_q+0x3e>
		if (z_sched_prio_cmp(thread, t) > 0) {
    6412:	4621      	mov	r1, r4
    6414:	4628      	mov	r0, r5
    6416:	f002 fa47 	bl	88a8 <z_sched_prio_cmp>
    641a:	2800      	cmp	r0, #0
    641c:	dc20      	bgt.n	6460 <move_thread_to_end_of_prio_q+0x70>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    641e:	b134      	cbz	r4, 642e <move_thread_to_end_of_prio_q+0x3e>
	return (node == list->tail) ? NULL : node->next;
    6420:	4b13      	ldr	r3, [pc, #76]	; (6470 <move_thread_to_end_of_prio_q+0x80>)
    6422:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6424:	429c      	cmp	r4, r3
    6426:	d002      	beq.n	642e <move_thread_to_end_of_prio_q+0x3e>
    6428:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    642a:	2c00      	cmp	r4, #0
    642c:	d1f0      	bne.n	6410 <move_thread_to_end_of_prio_q+0x20>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;
    642e:	4b10      	ldr	r3, [pc, #64]	; (6470 <move_thread_to_end_of_prio_q+0x80>)
    6430:	6a5a      	ldr	r2, [r3, #36]	; 0x24

	node->next = list;
    6432:	f103 0120 	add.w	r1, r3, #32
    6436:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    6438:	606a      	str	r2, [r5, #4]

	tail->next = node;
    643a:	6015      	str	r5, [r2, #0]
	list->tail = node;
    643c:	625d      	str	r5, [r3, #36]	; 0x24
	update_cache(thread == _current);
    643e:	4b0c      	ldr	r3, [pc, #48]	; (6470 <move_thread_to_end_of_prio_q+0x80>)
    6440:	6898      	ldr	r0, [r3, #8]
    6442:	42a8      	cmp	r0, r5
    6444:	bf14      	ite	ne
    6446:	2000      	movne	r0, #0
    6448:	2001      	moveq	r0, #1
    644a:	f7ff ffab 	bl	63a4 <update_cache>
}
    644e:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6450:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    6454:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    6456:	4601      	mov	r1, r0
    6458:	4806      	ldr	r0, [pc, #24]	; (6474 <move_thread_to_end_of_prio_q+0x84>)
    645a:	f002 fa63 	bl	8924 <z_priq_dumb_remove>
}
    645e:	e7ce      	b.n	63fe <move_thread_to_end_of_prio_q+0xe>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
    6460:	6863      	ldr	r3, [r4, #4]

	node->prev = prev;
    6462:	606b      	str	r3, [r5, #4]
	node->next = successor;
    6464:	602c      	str	r4, [r5, #0]
	prev->next = node;
    6466:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    6468:	6065      	str	r5, [r4, #4]
}
    646a:	e7e8      	b.n	643e <move_thread_to_end_of_prio_q+0x4e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    646c:	2400      	movs	r4, #0
    646e:	e7cf      	b.n	6410 <move_thread_to_end_of_prio_q+0x20>
    6470:	200009bc 	.word	0x200009bc
    6474:	200009dc 	.word	0x200009dc

00006478 <z_time_slice>:
{
    6478:	b510      	push	{r4, lr}
	__asm__ volatile(
    647a:	f04f 0320 	mov.w	r3, #32
    647e:	f3ef 8411 	mrs	r4, BASEPRI
    6482:	f383 8812 	msr	BASEPRI_MAX, r3
    6486:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
    648a:	4b1c      	ldr	r3, [pc, #112]	; (64fc <z_time_slice+0x84>)
    648c:	689b      	ldr	r3, [r3, #8]
    648e:	4a1c      	ldr	r2, [pc, #112]	; (6500 <z_time_slice+0x88>)
    6490:	6812      	ldr	r2, [r2, #0]
    6492:	4293      	cmp	r3, r2
    6494:	d01d      	beq.n	64d2 <z_time_slice+0x5a>
	pending_current = NULL;
    6496:	4a1a      	ldr	r2, [pc, #104]	; (6500 <z_time_slice+0x88>)
    6498:	2100      	movs	r1, #0
    649a:	6011      	str	r1, [r2, #0]
	if (slice_time && sliceable(_current)) {
    649c:	4a19      	ldr	r2, [pc, #100]	; (6504 <z_time_slice+0x8c>)
    649e:	6812      	ldr	r2, [r2, #0]
    64a0:	b322      	cbz	r2, 64ec <z_time_slice+0x74>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    64a2:	89da      	ldrh	r2, [r3, #14]
		&& !z_is_idle_thread_object(thread);
    64a4:	2a7f      	cmp	r2, #127	; 0x7f
    64a6:	d821      	bhi.n	64ec <z_time_slice+0x74>
	uint8_t state = thread->base.thread_state;
    64a8:	7b5a      	ldrb	r2, [r3, #13]
		&& !z_is_thread_prevented_from_running(thread)
    64aa:	f012 0f1f 	tst.w	r2, #31
    64ae:	d11d      	bne.n	64ec <z_time_slice+0x74>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    64b0:	f993 100e 	ldrsb.w	r1, [r3, #14]
    64b4:	4a14      	ldr	r2, [pc, #80]	; (6508 <z_time_slice+0x90>)
    64b6:	6812      	ldr	r2, [r2, #0]
    64b8:	4291      	cmp	r1, r2
    64ba:	db17      	blt.n	64ec <z_time_slice+0x74>
		&& !z_is_idle_thread_object(thread);
    64bc:	4a13      	ldr	r2, [pc, #76]	; (650c <z_time_slice+0x94>)
    64be:	4293      	cmp	r3, r2
    64c0:	d014      	beq.n	64ec <z_time_slice+0x74>
		if (ticks >= _current_cpu->slice_ticks) {
    64c2:	4a0e      	ldr	r2, [pc, #56]	; (64fc <z_time_slice+0x84>)
    64c4:	6912      	ldr	r2, [r2, #16]
    64c6:	4282      	cmp	r2, r0
    64c8:	dd0a      	ble.n	64e0 <z_time_slice+0x68>
			_current_cpu->slice_ticks -= ticks;
    64ca:	1a10      	subs	r0, r2, r0
    64cc:	4b0b      	ldr	r3, [pc, #44]	; (64fc <z_time_slice+0x84>)
    64ce:	6118      	str	r0, [r3, #16]
    64d0:	e00f      	b.n	64f2 <z_time_slice+0x7a>
		z_reset_time_slice();
    64d2:	f7ff fee1 	bl	6298 <z_reset_time_slice>
	__asm__ volatile(
    64d6:	f384 8811 	msr	BASEPRI, r4
    64da:	f3bf 8f6f 	isb	sy
		return;
    64de:	e00c      	b.n	64fa <z_time_slice+0x82>
			move_thread_to_end_of_prio_q(_current);
    64e0:	4618      	mov	r0, r3
    64e2:	f7ff ff85 	bl	63f0 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    64e6:	f7ff fed7 	bl	6298 <z_reset_time_slice>
    64ea:	e002      	b.n	64f2 <z_time_slice+0x7a>
		_current_cpu->slice_ticks = 0;
    64ec:	4b03      	ldr	r3, [pc, #12]	; (64fc <z_time_slice+0x84>)
    64ee:	2200      	movs	r2, #0
    64f0:	611a      	str	r2, [r3, #16]
    64f2:	f384 8811 	msr	BASEPRI, r4
    64f6:	f3bf 8f6f 	isb	sy
}
    64fa:	bd10      	pop	{r4, pc}
    64fc:	200009bc 	.word	0x200009bc
    6500:	200009e8 	.word	0x200009e8
    6504:	200009f0 	.word	0x200009f0
    6508:	200009ec 	.word	0x200009ec
    650c:	20000230 	.word	0x20000230

00006510 <ready_thread>:
{
    6510:	b538      	push	{r3, r4, r5, lr}
	return (thread->base.thread_state & state) != 0U;
    6512:	7b43      	ldrb	r3, [r0, #13]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    6514:	f990 200d 	ldrsb.w	r2, [r0, #13]
    6518:	2a00      	cmp	r2, #0
    651a:	db2d      	blt.n	6578 <ready_thread+0x68>
    651c:	4604      	mov	r4, r0
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    651e:	f013 0f1f 	tst.w	r3, #31
    6522:	d105      	bne.n	6530 <ready_thread+0x20>
	return node->next != NULL;
    6524:	6982      	ldr	r2, [r0, #24]
    6526:	b10a      	cbz	r2, 652c <ready_thread+0x1c>
    6528:	2200      	movs	r2, #0
    652a:	e002      	b.n	6532 <ready_thread+0x22>
    652c:	2201      	movs	r2, #1
    652e:	e000      	b.n	6532 <ready_thread+0x22>
    6530:	2200      	movs	r2, #0
    6532:	b30a      	cbz	r2, 6578 <ready_thread+0x68>
	thread->base.thread_state |= _THREAD_QUEUED;
    6534:	f063 037f 	orn	r3, r3, #127	; 0x7f
    6538:	7363      	strb	r3, [r4, #13]
	return list->head == list;
    653a:	4b14      	ldr	r3, [pc, #80]	; (658c <ready_thread+0x7c>)
    653c:	f853 5f20 	ldr.w	r5, [r3, #32]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6540:	429d      	cmp	r5, r3
    6542:	d020      	beq.n	6586 <ready_thread+0x76>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6544:	b16d      	cbz	r5, 6562 <ready_thread+0x52>
		if (z_sched_prio_cmp(thread, t) > 0) {
    6546:	4629      	mov	r1, r5
    6548:	4620      	mov	r0, r4
    654a:	f002 f9ad 	bl	88a8 <z_sched_prio_cmp>
    654e:	2800      	cmp	r0, #0
    6550:	dc13      	bgt.n	657a <ready_thread+0x6a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    6552:	b135      	cbz	r5, 6562 <ready_thread+0x52>
	return (node == list->tail) ? NULL : node->next;
    6554:	4b0d      	ldr	r3, [pc, #52]	; (658c <ready_thread+0x7c>)
    6556:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6558:	429d      	cmp	r5, r3
    655a:	d002      	beq.n	6562 <ready_thread+0x52>
    655c:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    655e:	2d00      	cmp	r5, #0
    6560:	d1f0      	bne.n	6544 <ready_thread+0x34>
	sys_dnode_t *const tail = list->tail;
    6562:	4b0a      	ldr	r3, [pc, #40]	; (658c <ready_thread+0x7c>)
    6564:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
    6566:	f103 0120 	add.w	r1, r3, #32
    656a:	6021      	str	r1, [r4, #0]
	node->prev = tail;
    656c:	6062      	str	r2, [r4, #4]
	tail->next = node;
    656e:	6014      	str	r4, [r2, #0]
	list->tail = node;
    6570:	625c      	str	r4, [r3, #36]	; 0x24
		update_cache(0);
    6572:	2000      	movs	r0, #0
    6574:	f7ff ff16 	bl	63a4 <update_cache>
}
    6578:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const prev = successor->prev;
    657a:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
    657c:	6063      	str	r3, [r4, #4]
	node->next = successor;
    657e:	6025      	str	r5, [r4, #0]
	prev->next = node;
    6580:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    6582:	606c      	str	r4, [r5, #4]
}
    6584:	e7f5      	b.n	6572 <ready_thread+0x62>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6586:	2500      	movs	r5, #0
    6588:	e7dc      	b.n	6544 <ready_thread+0x34>
    658a:	bf00      	nop
    658c:	200009bc 	.word	0x200009bc

00006590 <z_sched_start>:
{
    6590:	b510      	push	{r4, lr}
	__asm__ volatile(
    6592:	f04f 0320 	mov.w	r3, #32
    6596:	f3ef 8411 	mrs	r4, BASEPRI
    659a:	f383 8812 	msr	BASEPRI_MAX, r3
    659e:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    65a2:	7b43      	ldrb	r3, [r0, #13]
	if (z_has_thread_started(thread)) {
    65a4:	f013 0f04 	tst.w	r3, #4
    65a8:	d104      	bne.n	65b4 <z_sched_start+0x24>
	__asm__ volatile(
    65aa:	f384 8811 	msr	BASEPRI, r4
    65ae:	f3bf 8f6f 	isb	sy
}
    65b2:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    65b4:	f023 0304 	bic.w	r3, r3, #4
    65b8:	7343      	strb	r3, [r0, #13]
	ready_thread(thread);
    65ba:	f7ff ffa9 	bl	6510 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    65be:	4621      	mov	r1, r4
    65c0:	4801      	ldr	r0, [pc, #4]	; (65c8 <z_sched_start+0x38>)
    65c2:	f7ff febb 	bl	633c <z_reschedule>
    65c6:	e7f4      	b.n	65b2 <z_sched_start+0x22>
    65c8:	200009ec 	.word	0x200009ec

000065cc <unready_thread>:
{
    65cc:	b510      	push	{r4, lr}
    65ce:	4604      	mov	r4, r0
	return (thread->base.thread_state & state) != 0U;
    65d0:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    65d2:	f990 300d 	ldrsb.w	r3, [r0, #13]
    65d6:	2b00      	cmp	r3, #0
    65d8:	db08      	blt.n	65ec <unready_thread+0x20>
	update_cache(thread == _current);
    65da:	4b08      	ldr	r3, [pc, #32]	; (65fc <unready_thread+0x30>)
    65dc:	6898      	ldr	r0, [r3, #8]
    65de:	42a0      	cmp	r0, r4
    65e0:	bf14      	ite	ne
    65e2:	2000      	movne	r0, #0
    65e4:	2001      	moveq	r0, #1
    65e6:	f7ff fedd 	bl	63a4 <update_cache>
}
    65ea:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    65ec:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    65f0:	7342      	strb	r2, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    65f2:	4601      	mov	r1, r0
    65f4:	4802      	ldr	r0, [pc, #8]	; (6600 <unready_thread+0x34>)
    65f6:	f002 f995 	bl	8924 <z_priq_dumb_remove>
}
    65fa:	e7ee      	b.n	65da <unready_thread+0xe>
    65fc:	200009bc 	.word	0x200009bc
    6600:	200009dc 	.word	0x200009dc

00006604 <z_pend_curr>:
{
    6604:	b510      	push	{r4, lr}
    6606:	460c      	mov	r4, r1
    6608:	4611      	mov	r1, r2
	pending_current = _current;
    660a:	4b06      	ldr	r3, [pc, #24]	; (6624 <z_pend_curr+0x20>)
    660c:	6898      	ldr	r0, [r3, #8]
    660e:	4b06      	ldr	r3, [pc, #24]	; (6628 <z_pend_curr+0x24>)
    6610:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
    6612:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    6616:	f002 fa0e 	bl	8a36 <pend>
    661a:	4620      	mov	r0, r4
    661c:	f7fc f8d4 	bl	27c8 <arch_swap>
}
    6620:	bd10      	pop	{r4, pc}
    6622:	bf00      	nop
    6624:	200009bc 	.word	0x200009bc
    6628:	200009e8 	.word	0x200009e8

0000662c <z_set_prio>:
{
    662c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6630:	4604      	mov	r4, r0
    6632:	460f      	mov	r7, r1
	LOCKED(&sched_spinlock) {
    6634:	2300      	movs	r3, #0
	__asm__ volatile(
    6636:	f04f 0220 	mov.w	r2, #32
    663a:	f3ef 8611 	mrs	r6, BASEPRI
    663e:	f382 8812 	msr	BASEPRI_MAX, r2
    6642:	f3bf 8f6f 	isb	sy
	bool need_sched = 0;
    6646:	4698      	mov	r8, r3
    6648:	e008      	b.n	665c <z_set_prio+0x30>
		if (need_sched) {
    664a:	f012 0801 	ands.w	r8, r2, #1
    664e:	d111      	bne.n	6674 <z_set_prio+0x48>
			thread->base.prio = prio;
    6650:	73a7      	strb	r7, [r4, #14]
	__asm__ volatile(
    6652:	f386 8811 	msr	BASEPRI, r6
    6656:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    665a:	2301      	movs	r3, #1
    665c:	461a      	mov	r2, r3
    665e:	2b00      	cmp	r3, #0
    6660:	d13d      	bne.n	66de <z_set_prio+0xb2>
	uint8_t state = thread->base.thread_state;
    6662:	7b63      	ldrb	r3, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    6664:	f013 0f1f 	tst.w	r3, #31
    6668:	d1ef      	bne.n	664a <z_set_prio+0x1e>
	return node->next != NULL;
    666a:	69a1      	ldr	r1, [r4, #24]
    666c:	2900      	cmp	r1, #0
    666e:	d1ec      	bne.n	664a <z_set_prio+0x1e>
    6670:	2201      	movs	r2, #1
    6672:	e7ea      	b.n	664a <z_set_prio+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6674:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    6678:	7363      	strb	r3, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
    667a:	f8df 906c 	ldr.w	r9, [pc, #108]	; 66e8 <z_set_prio+0xbc>
    667e:	4621      	mov	r1, r4
    6680:	4648      	mov	r0, r9
    6682:	f002 f94f 	bl	8924 <z_priq_dumb_remove>
				thread->base.prio = prio;
    6686:	73a7      	strb	r7, [r4, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
    6688:	7b63      	ldrb	r3, [r4, #13]
    668a:	f063 037f 	orn	r3, r3, #127	; 0x7f
    668e:	7363      	strb	r3, [r4, #13]
	return list->head == list;
    6690:	f8d9 5000 	ldr.w	r5, [r9]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6694:	454d      	cmp	r5, r9
    6696:	d020      	beq.n	66da <z_set_prio+0xae>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    6698:	b16d      	cbz	r5, 66b6 <z_set_prio+0x8a>
		if (z_sched_prio_cmp(thread, t) > 0) {
    669a:	4629      	mov	r1, r5
    669c:	4620      	mov	r0, r4
    669e:	f002 f903 	bl	88a8 <z_sched_prio_cmp>
    66a2:	2800      	cmp	r0, #0
    66a4:	dc13      	bgt.n	66ce <z_set_prio+0xa2>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    66a6:	b135      	cbz	r5, 66b6 <z_set_prio+0x8a>
	return (node == list->tail) ? NULL : node->next;
    66a8:	4b0e      	ldr	r3, [pc, #56]	; (66e4 <z_set_prio+0xb8>)
    66aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    66ac:	429d      	cmp	r5, r3
    66ae:	d002      	beq.n	66b6 <z_set_prio+0x8a>
    66b0:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    66b2:	2d00      	cmp	r5, #0
    66b4:	d1f0      	bne.n	6698 <z_set_prio+0x6c>
	sys_dnode_t *const tail = list->tail;
    66b6:	4b0b      	ldr	r3, [pc, #44]	; (66e4 <z_set_prio+0xb8>)
    66b8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
    66ba:	f103 0120 	add.w	r1, r3, #32
    66be:	6021      	str	r1, [r4, #0]
	node->prev = tail;
    66c0:	6062      	str	r2, [r4, #4]
	tail->next = node;
    66c2:	6014      	str	r4, [r2, #0]
	list->tail = node;
    66c4:	625c      	str	r4, [r3, #36]	; 0x24
			update_cache(1);
    66c6:	2001      	movs	r0, #1
    66c8:	f7ff fe6c 	bl	63a4 <update_cache>
    66cc:	e7c1      	b.n	6652 <z_set_prio+0x26>
	sys_dnode_t *const prev = successor->prev;
    66ce:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
    66d0:	6063      	str	r3, [r4, #4]
	node->next = successor;
    66d2:	6025      	str	r5, [r4, #0]
	prev->next = node;
    66d4:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    66d6:	606c      	str	r4, [r5, #4]
}
    66d8:	e7f5      	b.n	66c6 <z_set_prio+0x9a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    66da:	2500      	movs	r5, #0
    66dc:	e7dc      	b.n	6698 <z_set_prio+0x6c>
}
    66de:	4640      	mov	r0, r8
    66e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    66e4:	200009bc 	.word	0x200009bc
    66e8:	200009dc 	.word	0x200009dc

000066ec <z_impl_k_thread_suspend>:
{
    66ec:	b538      	push	{r3, r4, r5, lr}
    66ee:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    66f0:	3018      	adds	r0, #24
    66f2:	f002 fa2e 	bl	8b52 <z_abort_timeout>
	LOCKED(&sched_spinlock) {
    66f6:	2300      	movs	r3, #0
	__asm__ volatile(
    66f8:	f04f 0220 	mov.w	r2, #32
    66fc:	f3ef 8511 	mrs	r5, BASEPRI
    6700:	f382 8812 	msr	BASEPRI_MAX, r2
    6704:	f3bf 8f6f 	isb	sy
    6708:	e010      	b.n	672c <z_impl_k_thread_suspend+0x40>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    670a:	7b63      	ldrb	r3, [r4, #13]
    670c:	f043 0310 	orr.w	r3, r3, #16
    6710:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    6712:	4b15      	ldr	r3, [pc, #84]	; (6768 <z_impl_k_thread_suspend+0x7c>)
    6714:	6898      	ldr	r0, [r3, #8]
    6716:	42a0      	cmp	r0, r4
    6718:	bf14      	ite	ne
    671a:	2000      	movne	r0, #0
    671c:	2001      	moveq	r0, #1
    671e:	f7ff fe41 	bl	63a4 <update_cache>
	__asm__ volatile(
    6722:	f385 8811 	msr	BASEPRI, r5
    6726:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    672a:	2301      	movs	r3, #1
    672c:	b963      	cbnz	r3, 6748 <z_impl_k_thread_suspend+0x5c>
	return (thread->base.thread_state & state) != 0U;
    672e:	7b62      	ldrb	r2, [r4, #13]
		if (z_is_thread_queued(thread)) {
    6730:	f994 300d 	ldrsb.w	r3, [r4, #13]
    6734:	2b00      	cmp	r3, #0
    6736:	dae8      	bge.n	670a <z_impl_k_thread_suspend+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6738:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    673c:	7362      	strb	r2, [r4, #13]
	_priq_run_remove(thread_runq(thread), thread);
    673e:	4621      	mov	r1, r4
    6740:	480a      	ldr	r0, [pc, #40]	; (676c <z_impl_k_thread_suspend+0x80>)
    6742:	f002 f8ef 	bl	8924 <z_priq_dumb_remove>
}
    6746:	e7e0      	b.n	670a <z_impl_k_thread_suspend+0x1e>
	if (thread == _current) {
    6748:	4b07      	ldr	r3, [pc, #28]	; (6768 <z_impl_k_thread_suspend+0x7c>)
    674a:	689b      	ldr	r3, [r3, #8]
    674c:	42a3      	cmp	r3, r4
    674e:	d000      	beq.n	6752 <z_impl_k_thread_suspend+0x66>
}
    6750:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    6752:	f04f 0320 	mov.w	r3, #32
    6756:	f3ef 8011 	mrs	r0, BASEPRI
    675a:	f383 8812 	msr	BASEPRI_MAX, r3
    675e:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    6762:	f002 f8ca 	bl	88fa <z_reschedule_irqlock>
    6766:	e7f3      	b.n	6750 <z_impl_k_thread_suspend+0x64>
    6768:	200009bc 	.word	0x200009bc
    676c:	200009dc 	.word	0x200009dc

00006770 <k_sched_unlock>:

void k_sched_unlock(void)
{
    6770:	b510      	push	{r4, lr}
	LOCKED(&sched_spinlock) {
    6772:	2300      	movs	r3, #0
    6774:	f04f 0220 	mov.w	r2, #32
    6778:	f3ef 8411 	mrs	r4, BASEPRI
    677c:	f382 8812 	msr	BASEPRI_MAX, r2
    6780:	f3bf 8f6f 	isb	sy
    6784:	b96b      	cbnz	r3, 67a2 <k_sched_unlock+0x32>
		__ASSERT(_current->base.sched_locked != 0U, "");
		__ASSERT(!arch_is_in_isr(), "");

		++_current->base.sched_locked;
    6786:	4b0c      	ldr	r3, [pc, #48]	; (67b8 <k_sched_unlock+0x48>)
    6788:	689a      	ldr	r2, [r3, #8]
    678a:	7bd3      	ldrb	r3, [r2, #15]
    678c:	3301      	adds	r3, #1
    678e:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    6790:	2000      	movs	r0, #0
    6792:	f7ff fe07 	bl	63a4 <update_cache>
	__asm__ volatile(
    6796:	f384 8811 	msr	BASEPRI, r4
    679a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    679e:	2301      	movs	r3, #1
    67a0:	e7f0      	b.n	6784 <k_sched_unlock+0x14>
	__asm__ volatile(
    67a2:	f04f 0320 	mov.w	r3, #32
    67a6:	f3ef 8011 	mrs	r0, BASEPRI
    67aa:	f383 8812 	msr	BASEPRI_MAX, r3
    67ae:	f3bf 8f6f 	isb	sy
    67b2:	f002 f8a2 	bl	88fa <z_reschedule_irqlock>
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
}
    67b6:	bd10      	pop	{r4, pc}
    67b8:	200009bc 	.word	0x200009bc

000067bc <end_thread>:
#ifdef CONFIG_CMSIS_RTOS_V1
extern void z_thread_cmsis_status_mask_clear(struct k_thread *thread);
#endif

static void end_thread(struct k_thread *thread)
{
    67bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* We hold the lock, and the thread is known not to be running
	 * anywhere.
	 */
	if ((thread->base.thread_state & _THREAD_DEAD) == 0U) {
    67be:	7b43      	ldrb	r3, [r0, #13]
    67c0:	f013 0f08 	tst.w	r3, #8
    67c4:	d145      	bne.n	6852 <end_thread+0x96>
    67c6:	4605      	mov	r5, r0
		thread->base.thread_state |= _THREAD_DEAD;
    67c8:	f043 0308 	orr.w	r3, r3, #8
		thread->base.thread_state &= ~_THREAD_ABORTING;
    67cc:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    67d0:	7343      	strb	r3, [r0, #13]
		if (z_is_thread_queued(thread)) {
    67d2:	f013 0f80 	tst.w	r3, #128	; 0x80
    67d6:	d114      	bne.n	6802 <end_thread+0x46>
			dequeue_thread(thread);
		}
		if (thread->base.pended_on != NULL) {
    67d8:	68ab      	ldr	r3, [r5, #8]
    67da:	b15b      	cbz	r3, 67f4 <end_thread+0x38>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    67dc:	4628      	mov	r0, r5
    67de:	f002 f861 	bl	88a4 <pended_on_thread>
    67e2:	4629      	mov	r1, r5
    67e4:	f002 f89e 	bl	8924 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    67e8:	7b6b      	ldrb	r3, [r5, #13]
    67ea:	f023 0302 	bic.w	r3, r3, #2
    67ee:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
    67f0:	2300      	movs	r3, #0
    67f2:	60ab      	str	r3, [r5, #8]
    67f4:	f105 0018 	add.w	r0, r5, #24
    67f8:	f002 f9ab 	bl	8b52 <z_abort_timeout>
			unpend_thread_no_timeout(thread);
		}
		(void)z_abort_thread_timeout(thread);
		unpend_all(&thread->join_queue);
    67fc:	f105 0758 	add.w	r7, r5, #88	; 0x58
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    6800:	e01c      	b.n	683c <end_thread+0x80>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6802:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    6806:	7343      	strb	r3, [r0, #13]
	_priq_run_remove(thread_runq(thread), thread);
    6808:	4601      	mov	r1, r0
    680a:	4812      	ldr	r0, [pc, #72]	; (6854 <end_thread+0x98>)
    680c:	f002 f88a 	bl	8924 <z_priq_dumb_remove>
}
    6810:	e7e2      	b.n	67d8 <end_thread+0x1c>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    6812:	4620      	mov	r0, r4
    6814:	f002 f846 	bl	88a4 <pended_on_thread>
    6818:	4621      	mov	r1, r4
    681a:	f002 f883 	bl	8924 <z_priq_dumb_remove>
    681e:	7b63      	ldrb	r3, [r4, #13]
    6820:	f023 0302 	bic.w	r3, r3, #2
    6824:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    6826:	2600      	movs	r6, #0
    6828:	60a6      	str	r6, [r4, #8]
    682a:	f104 0018 	add.w	r0, r4, #24
    682e:	f002 f990 	bl	8b52 <z_abort_timeout>
    6832:	f8c4 60ac 	str.w	r6, [r4, #172]	; 0xac
		ready_thread(thread);
    6836:	4620      	mov	r0, r4
    6838:	f7ff fe6a 	bl	6510 <ready_thread>
	return list->head == list;
    683c:	683c      	ldr	r4, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    683e:	42bc      	cmp	r4, r7
    6840:	d001      	beq.n	6846 <end_thread+0x8a>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    6842:	2c00      	cmp	r4, #0
    6844:	d1e5      	bne.n	6812 <end_thread+0x56>
		update_cache(1);
    6846:	2001      	movs	r0, #1
    6848:	f7ff fdac 	bl	63a4 <update_cache>

		SYS_PORT_TRACING_FUNC(k_thread, sched_abort, thread);

		z_thread_monitor_exit(thread);
    684c:	4628      	mov	r0, r5
    684e:	f7ff fae9 	bl	5e24 <z_thread_monitor_exit>
		z_thread_perms_all_clear(thread);
		z_object_uninit(thread->stack_obj);
		z_object_uninit(thread);
#endif
	}
}
    6852:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6854:	200009dc 	.word	0x200009dc

00006858 <z_sched_init>:
{
    6858:	b508      	push	{r3, lr}
	init_ready_q(&_kernel.ready_q);
    685a:	4804      	ldr	r0, [pc, #16]	; (686c <z_sched_init+0x14>)
    685c:	f002 f95e 	bl	8b1c <init_ready_q>
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    6860:	2100      	movs	r1, #0
    6862:	4608      	mov	r0, r1
    6864:	f7ff fd2e 	bl	62c4 <k_sched_time_slice_set>
}
    6868:	bd08      	pop	{r3, pc}
    686a:	bf00      	nop
    686c:	200009d8 	.word	0x200009d8

00006870 <z_impl_k_yield>:
{
    6870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6872:	f04f 0320 	mov.w	r3, #32
    6876:	f3ef 8611 	mrs	r6, BASEPRI
    687a:	f383 8812 	msr	BASEPRI_MAX, r3
    687e:	f3bf 8f6f 	isb	sy
		dequeue_thread(_current);
    6882:	4c1c      	ldr	r4, [pc, #112]	; (68f4 <z_impl_k_yield+0x84>)
    6884:	68a1      	ldr	r1, [r4, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    6886:	7b4b      	ldrb	r3, [r1, #13]
    6888:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    688c:	734b      	strb	r3, [r1, #13]
	_priq_run_remove(thread_runq(thread), thread);
    688e:	f104 0720 	add.w	r7, r4, #32
    6892:	4638      	mov	r0, r7
    6894:	f002 f846 	bl	8924 <z_priq_dumb_remove>
	queue_thread(_current);
    6898:	68a5      	ldr	r5, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    689a:	7b6b      	ldrb	r3, [r5, #13]
    689c:	f063 037f 	orn	r3, r3, #127	; 0x7f
    68a0:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    68a2:	6a24      	ldr	r4, [r4, #32]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    68a4:	42bc      	cmp	r4, r7
    68a6:	d023      	beq.n	68f0 <z_impl_k_yield+0x80>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    68a8:	b16c      	cbz	r4, 68c6 <z_impl_k_yield+0x56>
		if (z_sched_prio_cmp(thread, t) > 0) {
    68aa:	4621      	mov	r1, r4
    68ac:	4628      	mov	r0, r5
    68ae:	f001 fffb 	bl	88a8 <z_sched_prio_cmp>
    68b2:	2800      	cmp	r0, #0
    68b4:	dc16      	bgt.n	68e4 <z_impl_k_yield+0x74>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    68b6:	b134      	cbz	r4, 68c6 <z_impl_k_yield+0x56>
	return (node == list->tail) ? NULL : node->next;
    68b8:	4b0e      	ldr	r3, [pc, #56]	; (68f4 <z_impl_k_yield+0x84>)
    68ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    68bc:	429c      	cmp	r4, r3
    68be:	d002      	beq.n	68c6 <z_impl_k_yield+0x56>
    68c0:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    68c2:	2c00      	cmp	r4, #0
    68c4:	d1f0      	bne.n	68a8 <z_impl_k_yield+0x38>
	sys_dnode_t *const tail = list->tail;
    68c6:	4b0b      	ldr	r3, [pc, #44]	; (68f4 <z_impl_k_yield+0x84>)
    68c8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	node->next = list;
    68ca:	f103 0120 	add.w	r1, r3, #32
    68ce:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    68d0:	606a      	str	r2, [r5, #4]
	tail->next = node;
    68d2:	6015      	str	r5, [r2, #0]
	list->tail = node;
    68d4:	625d      	str	r5, [r3, #36]	; 0x24
	update_cache(1);
    68d6:	2001      	movs	r0, #1
    68d8:	f7ff fd64 	bl	63a4 <update_cache>
    68dc:	4630      	mov	r0, r6
    68de:	f7fb ff73 	bl	27c8 <arch_swap>
}
    68e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	sys_dnode_t *const prev = successor->prev;
    68e4:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    68e6:	606b      	str	r3, [r5, #4]
	node->next = successor;
    68e8:	602c      	str	r4, [r5, #0]
	prev->next = node;
    68ea:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    68ec:	6065      	str	r5, [r4, #4]
}
    68ee:	e7f2      	b.n	68d6 <z_impl_k_yield+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    68f0:	2400      	movs	r4, #0
    68f2:	e7d9      	b.n	68a8 <z_impl_k_yield+0x38>
    68f4:	200009bc 	.word	0x200009bc

000068f8 <z_tick_sleep>:
{
    68f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    68fc:	4604      	mov	r4, r0
    68fe:	460d      	mov	r5, r1
	if (ticks == 0) {
    6900:	ea54 0105 	orrs.w	r1, r4, r5
    6904:	d037      	beq.n	6976 <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
    6906:	f06f 0101 	mvn.w	r1, #1
    690a:	1a0a      	subs	r2, r1, r0
    690c:	f04f 31ff 	mov.w	r1, #4294967295
    6910:	eb61 0305 	sbc.w	r3, r1, r5
    6914:	2a01      	cmp	r2, #1
    6916:	f173 0300 	sbcs.w	r3, r3, #0
    691a:	db30      	blt.n	697e <z_tick_sleep+0x86>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    691c:	f06f 0601 	mvn.w	r6, #1
    6920:	1a36      	subs	r6, r6, r0
    6922:	f04f 0320 	mov.w	r3, #32
    6926:	f3ef 8811 	mrs	r8, BASEPRI
    692a:	f383 8812 	msr	BASEPRI_MAX, r3
    692e:	f3bf 8f6f 	isb	sy
	pending_current = _current;
    6932:	4f16      	ldr	r7, [pc, #88]	; (698c <z_tick_sleep+0x94>)
    6934:	68b8      	ldr	r0, [r7, #8]
    6936:	4b16      	ldr	r3, [pc, #88]	; (6990 <z_tick_sleep+0x98>)
    6938:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
    693a:	f7ff fe47 	bl	65cc <unready_thread>
	z_add_thread_timeout(_current, timeout);
    693e:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    6940:	4622      	mov	r2, r4
    6942:	462b      	mov	r3, r5
    6944:	4913      	ldr	r1, [pc, #76]	; (6994 <z_tick_sleep+0x9c>)
    6946:	3018      	adds	r0, #24
    6948:	f000 f8e2 	bl	6b10 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    694c:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    694e:	7b53      	ldrb	r3, [r2, #13]
    6950:	f043 0310 	orr.w	r3, r3, #16
    6954:	7353      	strb	r3, [r2, #13]
    6956:	4640      	mov	r0, r8
    6958:	f7fb ff36 	bl	27c8 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    695c:	2500      	movs	r5, #0
    695e:	f002 f957 	bl	8c10 <sys_clock_tick_get_32>
    6962:	1a34      	subs	r4, r6, r0
    6964:	f165 0500 	sbc.w	r5, r5, #0
	if (ticks > 0) {
    6968:	2c01      	cmp	r4, #1
    696a:	f175 0300 	sbcs.w	r3, r5, #0
    696e:	da0a      	bge.n	6986 <z_tick_sleep+0x8e>
	return 0;
    6970:	2000      	movs	r0, #0
}
    6972:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	z_impl_k_yield();
    6976:	f7ff ff7b 	bl	6870 <z_impl_k_yield>
		return 0;
    697a:	2000      	movs	r0, #0
    697c:	e7f9      	b.n	6972 <z_tick_sleep+0x7a>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    697e:	f002 f947 	bl	8c10 <sys_clock_tick_get_32>
    6982:	1906      	adds	r6, r0, r4
    6984:	e7cd      	b.n	6922 <z_tick_sleep+0x2a>
		return ticks;
    6986:	4620      	mov	r0, r4
    6988:	e7f3      	b.n	6972 <z_tick_sleep+0x7a>
    698a:	bf00      	nop
    698c:	200009bc 	.word	0x200009bc
    6990:	200009e8 	.word	0x200009e8
    6994:	0000897b 	.word	0x0000897b

00006998 <z_impl_k_sleep>:
{
    6998:	b538      	push	{r3, r4, r5, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    699a:	f1b1 3fff 	cmp.w	r1, #4294967295
    699e:	bf08      	it	eq
    69a0:	f1b0 3fff 	cmpeq.w	r0, #4294967295
    69a4:	d01a      	beq.n	69dc <z_impl_k_sleep+0x44>
	ticks = z_tick_sleep(ticks);
    69a6:	f7ff ffa7 	bl	68f8 <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    69aa:	4604      	mov	r4, r0
    69ac:	17c5      	asrs	r5, r0, #31
			return (t * to_hz + off) / from_hz;
    69ae:	0169      	lsls	r1, r5, #5
    69b0:	0143      	lsls	r3, r0, #5
    69b2:	ea41 62d0 	orr.w	r2, r1, r0, lsr #27
    69b6:	1a18      	subs	r0, r3, r0
    69b8:	eb62 0305 	sbc.w	r3, r2, r5
    69bc:	009a      	lsls	r2, r3, #2
    69be:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
    69c2:	0081      	lsls	r1, r0, #2
    69c4:	4613      	mov	r3, r2
    69c6:	1908      	adds	r0, r1, r4
    69c8:	eb45 0303 	adc.w	r3, r5, r3
    69cc:	00da      	lsls	r2, r3, #3
    69ce:	ea42 7250 	orr.w	r2, r2, r0, lsr #29
    69d2:	00c1      	lsls	r1, r0, #3
    69d4:	0bc8      	lsrs	r0, r1, #15
    69d6:	ea40 4042 	orr.w	r0, r0, r2, lsl #17
}
    69da:	bd38      	pop	{r3, r4, r5, pc}
		k_thread_suspend(_current);
    69dc:	4b03      	ldr	r3, [pc, #12]	; (69ec <z_impl_k_sleep+0x54>)
    69de:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    69e0:	f7ff fe84 	bl	66ec <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    69e4:	f04f 30ff 	mov.w	r0, #4294967295
    69e8:	e7f7      	b.n	69da <z_impl_k_sleep+0x42>
    69ea:	bf00      	nop
    69ec:	200009bc 	.word	0x200009bc

000069f0 <z_impl_z_current_get>:
}
    69f0:	4b01      	ldr	r3, [pc, #4]	; (69f8 <z_impl_z_current_get+0x8>)
    69f2:	6898      	ldr	r0, [r3, #8]
    69f4:	4770      	bx	lr
    69f6:	bf00      	nop
    69f8:	200009bc 	.word	0x200009bc

000069fc <z_thread_abort>:

void z_thread_abort(struct k_thread *thread)
{
    69fc:	b538      	push	{r3, r4, r5, lr}
    69fe:	f04f 0320 	mov.w	r3, #32
    6a02:	f3ef 8511 	mrs	r5, BASEPRI
    6a06:	f383 8812 	msr	BASEPRI_MAX, r3
    6a0a:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    6a0e:	7b43      	ldrb	r3, [r0, #13]
    6a10:	f013 0f08 	tst.w	r3, #8
    6a14:	d004      	beq.n	6a20 <z_thread_abort+0x24>
	__asm__ volatile(
    6a16:	f385 8811 	msr	BASEPRI, r5
    6a1a:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    6a1e:	bd38      	pop	{r3, r4, r5, pc}
    6a20:	4604      	mov	r4, r0
	end_thread(thread);
    6a22:	f7ff fecb 	bl	67bc <end_thread>
	if (thread == _current && !arch_is_in_isr()) {
    6a26:	4b08      	ldr	r3, [pc, #32]	; (6a48 <z_thread_abort+0x4c>)
    6a28:	689b      	ldr	r3, [r3, #8]
    6a2a:	42a3      	cmp	r3, r4
    6a2c:	d004      	beq.n	6a38 <z_thread_abort+0x3c>
    6a2e:	f385 8811 	msr	BASEPRI, r5
    6a32:	f3bf 8f6f 	isb	sy
    6a36:	e7f2      	b.n	6a1e <z_thread_abort+0x22>
    6a38:	f3ef 8305 	mrs	r3, IPSR
    6a3c:	2b00      	cmp	r3, #0
    6a3e:	d1f6      	bne.n	6a2e <z_thread_abort+0x32>
    6a40:	4628      	mov	r0, r5
    6a42:	f7fb fec1 	bl	27c8 <arch_swap>
	return ret;
    6a46:	e7f2      	b.n	6a2e <z_thread_abort+0x32>
    6a48:	200009bc 	.word	0x200009bc

00006a4c <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    6a4c:	b508      	push	{r3, lr}
	(void)memcpy(&__data_region_start, &__data_region_load_start,
		 __data_region_end - __data_region_start);
    6a4e:	4806      	ldr	r0, [pc, #24]	; (6a68 <z_data_copy+0x1c>)
	(void)memcpy(&__data_region_start, &__data_region_load_start,
    6a50:	4a06      	ldr	r2, [pc, #24]	; (6a6c <z_data_copy+0x20>)
    6a52:	1a12      	subs	r2, r2, r0
    6a54:	4906      	ldr	r1, [pc, #24]	; (6a70 <z_data_copy+0x24>)
    6a56:	f001 f997 	bl	7d88 <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&__ramfunc_start, &__ramfunc_load_start,
    6a5a:	4a06      	ldr	r2, [pc, #24]	; (6a74 <z_data_copy+0x28>)
    6a5c:	4906      	ldr	r1, [pc, #24]	; (6a78 <z_data_copy+0x2c>)
    6a5e:	4807      	ldr	r0, [pc, #28]	; (6a7c <z_data_copy+0x30>)
    6a60:	f001 f992 	bl	7d88 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    6a64:	bd08      	pop	{r3, pc}
    6a66:	bf00      	nop
    6a68:	20000000 	.word	0x20000000
    6a6c:	20000124 	.word	0x20000124
    6a70:	0000999c 	.word	0x0000999c
    6a74:	00000000 	.word	0x00000000
    6a78:	0000999c 	.word	0x0000999c
    6a7c:	20000000 	.word	0x20000000

00006a80 <first>:
	return list->head == list;
    6a80:	4b03      	ldr	r3, [pc, #12]	; (6a90 <first+0x10>)
    6a82:	6818      	ldr	r0, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6a84:	4298      	cmp	r0, r3
    6a86:	d000      	beq.n	6a8a <first+0xa>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
    6a88:	4770      	bx	lr
    6a8a:	2000      	movs	r0, #0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    6a8c:	e7fc      	b.n	6a88 <first+0x8>
    6a8e:	bf00      	nop
    6a90:	200000ec 	.word	0x200000ec

00006a94 <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    6a94:	b130      	cbz	r0, 6aa4 <next+0x10>
	return (node == list->tail) ? NULL : node->next;
    6a96:	4a04      	ldr	r2, [pc, #16]	; (6aa8 <next+0x14>)
    6a98:	6852      	ldr	r2, [r2, #4]
    6a9a:	4290      	cmp	r0, r2
    6a9c:	d001      	beq.n	6aa2 <next+0xe>
    6a9e:	6800      	ldr	r0, [r0, #0]
    6aa0:	4770      	bx	lr
    6aa2:	2000      	movs	r0, #0
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
    6aa4:	4770      	bx	lr
    6aa6:	bf00      	nop
    6aa8:	200000ec 	.word	0x200000ec

00006aac <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
    6aac:	b508      	push	{r3, lr}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    6aae:	4b04      	ldr	r3, [pc, #16]	; (6ac0 <elapsed+0x14>)
    6ab0:	681b      	ldr	r3, [r3, #0]
    6ab2:	b10b      	cbz	r3, 6ab8 <elapsed+0xc>
    6ab4:	2000      	movs	r0, #0
}
    6ab6:	bd08      	pop	{r3, pc}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    6ab8:	f7fd fe00 	bl	46bc <sys_clock_elapsed>
    6abc:	e7fb      	b.n	6ab6 <elapsed+0xa>
    6abe:	bf00      	nop
    6ac0:	200009f4 	.word	0x200009f4

00006ac4 <next_timeout>:

static int32_t next_timeout(void)
{
    6ac4:	b510      	push	{r4, lr}
	struct _timeout *to = first();
    6ac6:	f7ff ffdb 	bl	6a80 <first>
    6aca:	4604      	mov	r4, r0
	int32_t ticks_elapsed = elapsed();
    6acc:	f7ff ffee 	bl	6aac <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    6ad0:	b18c      	cbz	r4, 6af6 <next_timeout+0x32>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    6ad2:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    6ad6:	1a12      	subs	r2, r2, r0
    6ad8:	eb63 73e0 	sbc.w	r3, r3, r0, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
    6adc:	2a01      	cmp	r2, #1
    6ade:	f173 0100 	sbcs.w	r1, r3, #0
    6ae2:	db11      	blt.n	6b08 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    6ae4:	4610      	mov	r0, r2
    6ae6:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    6aea:	f173 0300 	sbcs.w	r3, r3, #0
    6aee:	db04      	blt.n	6afa <next_timeout+0x36>
    6af0:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    6af4:	e001      	b.n	6afa <next_timeout+0x36>
	int32_t ret = to == NULL ? MAX_WAIT
    6af6:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    6afa:	4b04      	ldr	r3, [pc, #16]	; (6b0c <next_timeout+0x48>)
    6afc:	691b      	ldr	r3, [r3, #16]
    6afe:	b113      	cbz	r3, 6b06 <next_timeout+0x42>
    6b00:	4283      	cmp	r3, r0
    6b02:	da00      	bge.n	6b06 <next_timeout+0x42>
		ret = _current_cpu->slice_ticks;
    6b04:	4618      	mov	r0, r3
	}
#endif
	return ret;
}
    6b06:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
    6b08:	2000      	movs	r0, #0
    6b0a:	e7f6      	b.n	6afa <next_timeout+0x36>
    6b0c:	200009bc 	.word	0x200009bc

00006b10 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    6b10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6b14:	b083      	sub	sp, #12
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    6b16:	f1b3 3fff 	cmp.w	r3, #4294967295
    6b1a:	bf08      	it	eq
    6b1c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    6b20:	f000 8096 	beq.w	6c50 <z_add_timeout+0x140>
    6b24:	4682      	mov	sl, r0
    6b26:	4614      	mov	r4, r2
    6b28:	461d      	mov	r5, r3
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    6b2a:	6081      	str	r1, [r0, #8]

	LOCKED(&timeout_lock) {
    6b2c:	2300      	movs	r3, #0
	__asm__ volatile(
    6b2e:	f04f 0220 	mov.w	r2, #32
    6b32:	f3ef 8b11 	mrs	fp, BASEPRI
    6b36:	f382 8812 	msr	BASEPRI_MAX, r2
    6b3a:	f3bf 8f6f 	isb	sy
    6b3e:	e02e      	b.n	6b9e <z_add_timeout+0x8e>

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;

			to->dticks = MAX(1, ticks);
    6b40:	2201      	movs	r2, #1
    6b42:	2300      	movs	r3, #0
    6b44:	e04b      	b.n	6bde <z_add_timeout+0xce>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    6b46:	f7ff ffb1 	bl	6aac <elapsed>
    6b4a:	1822      	adds	r2, r4, r0
    6b4c:	eb45 73e0 	adc.w	r3, r5, r0, asr #31
    6b50:	3201      	adds	r2, #1
    6b52:	f143 0300 	adc.w	r3, r3, #0
    6b56:	f8ca 2010 	str.w	r2, [sl, #16]
    6b5a:	f8ca 3014 	str.w	r3, [sl, #20]
    6b5e:	e042      	b.n	6be6 <z_add_timeout+0xd6>
		}

		for (t = first(); t != NULL; t = next(t)) {
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
    6b60:	9b00      	ldr	r3, [sp, #0]
    6b62:	1ac2      	subs	r2, r0, r3
    6b64:	9b01      	ldr	r3, [sp, #4]
    6b66:	eb61 0303 	sbc.w	r3, r1, r3
    6b6a:	f8cc 2010 	str.w	r2, [ip, #16]
    6b6e:	f8cc 3014 	str.w	r3, [ip, #20]
	sys_dnode_t *const prev = successor->prev;
    6b72:	f8dc 3004 	ldr.w	r3, [ip, #4]
	node->prev = prev;
    6b76:	f8ca 3004 	str.w	r3, [sl, #4]
	node->next = successor;
    6b7a:	f8ca c000 	str.w	ip, [sl]
	prev->next = node;
    6b7e:	f8c3 a000 	str.w	sl, [r3]
	successor->prev = node;
    6b82:	f8cc a004 	str.w	sl, [ip, #4]
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    6b86:	f1bc 0f00 	cmp.w	ip, #0
    6b8a:	d049      	beq.n	6c20 <z_add_timeout+0x110>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    6b8c:	f7ff ff78 	bl	6a80 <first>
    6b90:	4582      	cmp	sl, r0
    6b92:	d050      	beq.n	6c36 <z_add_timeout+0x126>
	__asm__ volatile(
    6b94:	f38b 8811 	msr	BASEPRI, fp
    6b98:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    6b9c:	2301      	movs	r3, #1
    6b9e:	2b00      	cmp	r3, #0
    6ba0:	d156      	bne.n	6c50 <z_add_timeout+0x140>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    6ba2:	f06f 0301 	mvn.w	r3, #1
    6ba6:	ebb3 0804 	subs.w	r8, r3, r4
    6baa:	f04f 30ff 	mov.w	r0, #4294967295
    6bae:	eb60 0905 	sbc.w	r9, r0, r5
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    6bb2:	f1b8 0f00 	cmp.w	r8, #0
    6bb6:	f179 0300 	sbcs.w	r3, r9, #0
    6bba:	dbc4      	blt.n	6b46 <z_add_timeout+0x36>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    6bbc:	4a26      	ldr	r2, [pc, #152]	; (6c58 <z_add_timeout+0x148>)
    6bbe:	6813      	ldr	r3, [r2, #0]
    6bc0:	6852      	ldr	r2, [r2, #4]
    6bc2:	18e3      	adds	r3, r4, r3
    6bc4:	eb45 0202 	adc.w	r2, r5, r2
    6bc8:	f06f 0101 	mvn.w	r1, #1
    6bcc:	1ace      	subs	r6, r1, r3
    6bce:	eb60 0702 	sbc.w	r7, r0, r2
			to->dticks = MAX(1, ticks);
    6bd2:	4632      	mov	r2, r6
    6bd4:	463b      	mov	r3, r7
    6bd6:	2e01      	cmp	r6, #1
    6bd8:	f177 0100 	sbcs.w	r1, r7, #0
    6bdc:	dbb0      	blt.n	6b40 <z_add_timeout+0x30>
    6bde:	f8ca 2010 	str.w	r2, [sl, #16]
    6be2:	f8ca 3014 	str.w	r3, [sl, #20]
		for (t = first(); t != NULL; t = next(t)) {
    6be6:	f7ff ff4b 	bl	6a80 <first>
    6bea:	4684      	mov	ip, r0
    6bec:	f1bc 0f00 	cmp.w	ip, #0
    6bf0:	d0c9      	beq.n	6b86 <z_add_timeout+0x76>
			if (t->dticks > to->dticks) {
    6bf2:	e9dc 0104 	ldrd	r0, r1, [ip, #16]
    6bf6:	e9da 2304 	ldrd	r2, r3, [sl, #16]
    6bfa:	e9cd 2300 	strd	r2, r3, [sp]
    6bfe:	4282      	cmp	r2, r0
    6c00:	418b      	sbcs	r3, r1
    6c02:	dbad      	blt.n	6b60 <z_add_timeout+0x50>
			to->dticks -= t->dticks;
    6c04:	9b00      	ldr	r3, [sp, #0]
    6c06:	1a1a      	subs	r2, r3, r0
    6c08:	9b01      	ldr	r3, [sp, #4]
    6c0a:	eb63 0301 	sbc.w	r3, r3, r1
    6c0e:	f8ca 2010 	str.w	r2, [sl, #16]
    6c12:	f8ca 3014 	str.w	r3, [sl, #20]
		for (t = first(); t != NULL; t = next(t)) {
    6c16:	4660      	mov	r0, ip
    6c18:	f7ff ff3c 	bl	6a94 <next>
    6c1c:	4684      	mov	ip, r0
    6c1e:	e7e5      	b.n	6bec <z_add_timeout+0xdc>
	sys_dnode_t *const tail = list->tail;
    6c20:	4b0e      	ldr	r3, [pc, #56]	; (6c5c <z_add_timeout+0x14c>)
    6c22:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    6c24:	f8ca 3000 	str.w	r3, [sl]
	node->prev = tail;
    6c28:	f8ca 2004 	str.w	r2, [sl, #4]
	tail->next = node;
    6c2c:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
    6c30:	f8c3 a004 	str.w	sl, [r3, #4]
}
    6c34:	e7aa      	b.n	6b8c <z_add_timeout+0x7c>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    6c36:	f7ff ff45 	bl	6ac4 <next_timeout>

			if (next_time == 0 ||
    6c3a:	4603      	mov	r3, r0
    6c3c:	b118      	cbz	r0, 6c46 <z_add_timeout+0x136>
			    _current_cpu->slice_ticks != next_time) {
    6c3e:	4a08      	ldr	r2, [pc, #32]	; (6c60 <z_add_timeout+0x150>)
    6c40:	6912      	ldr	r2, [r2, #16]
			if (next_time == 0 ||
    6c42:	4282      	cmp	r2, r0
    6c44:	d0a6      	beq.n	6b94 <z_add_timeout+0x84>
				sys_clock_set_timeout(next_time, false);
    6c46:	2100      	movs	r1, #0
    6c48:	4618      	mov	r0, r3
    6c4a:	f7fd fd03 	bl	4654 <sys_clock_set_timeout>
    6c4e:	e7a1      	b.n	6b94 <z_add_timeout+0x84>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    6c50:	b003      	add	sp, #12
    6c52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6c56:	bf00      	nop
    6c58:	20000390 	.word	0x20000390
    6c5c:	200000ec 	.word	0x200000ec
    6c60:	200009bc 	.word	0x200009bc

00006c64 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
    6c64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6c66:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    6c68:	f7ff fc06 	bl	6478 <z_time_slice>
	__asm__ volatile(
    6c6c:	f04f 0320 	mov.w	r3, #32
    6c70:	f3ef 8511 	mrs	r5, BASEPRI
    6c74:	f383 8812 	msr	BASEPRI_MAX, r3
    6c78:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    6c7c:	4b28      	ldr	r3, [pc, #160]	; (6d20 <sys_clock_announce+0xbc>)
    6c7e:	601c      	str	r4, [r3, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    6c80:	f7ff fefe 	bl	6a80 <first>
    6c84:	4604      	mov	r4, r0
    6c86:	b350      	cbz	r0, 6cde <sys_clock_announce+0x7a>
    6c88:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
    6c8c:	4b24      	ldr	r3, [pc, #144]	; (6d20 <sys_clock_announce+0xbc>)
    6c8e:	681b      	ldr	r3, [r3, #0]
    6c90:	17d9      	asrs	r1, r3, #31
    6c92:	42b3      	cmp	r3, r6
    6c94:	eb71 0207 	sbcs.w	r2, r1, r7
    6c98:	db21      	blt.n	6cde <sys_clock_announce+0x7a>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    6c9a:	4a22      	ldr	r2, [pc, #136]	; (6d24 <sys_clock_announce+0xc0>)
    6c9c:	e9d2 0100 	ldrd	r0, r1, [r2]
    6ca0:	1980      	adds	r0, r0, r6
    6ca2:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
    6ca6:	e9c2 0100 	strd	r0, r1, [r2]
		announce_remaining -= dt;
    6caa:	1b9b      	subs	r3, r3, r6
    6cac:	4a1c      	ldr	r2, [pc, #112]	; (6d20 <sys_clock_announce+0xbc>)
    6cae:	6013      	str	r3, [r2, #0]
		t->dticks = 0;
    6cb0:	2200      	movs	r2, #0
    6cb2:	2300      	movs	r3, #0
    6cb4:	e9c4 2304 	strd	r2, r3, [r4, #16]
		remove_timeout(t);
    6cb8:	4620      	mov	r0, r4
    6cba:	f001 ff33 	bl	8b24 <remove_timeout>
	__asm__ volatile(
    6cbe:	f385 8811 	msr	BASEPRI, r5
    6cc2:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    6cc6:	68a3      	ldr	r3, [r4, #8]
    6cc8:	4620      	mov	r0, r4
    6cca:	4798      	blx	r3
	__asm__ volatile(
    6ccc:	f04f 0320 	mov.w	r3, #32
    6cd0:	f3ef 8511 	mrs	r5, BASEPRI
    6cd4:	f383 8812 	msr	BASEPRI_MAX, r3
    6cd8:	f3bf 8f6f 	isb	sy
    6cdc:	e7d0      	b.n	6c80 <sys_clock_announce+0x1c>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
    6cde:	b144      	cbz	r4, 6cf2 <sys_clock_announce+0x8e>
		first()->dticks -= announce_remaining;
    6ce0:	4b0f      	ldr	r3, [pc, #60]	; (6d20 <sys_clock_announce+0xbc>)
    6ce2:	6819      	ldr	r1, [r3, #0]
    6ce4:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    6ce8:	1a52      	subs	r2, r2, r1
    6cea:	eb63 73e1 	sbc.w	r3, r3, r1, asr #31
    6cee:	e9c4 2304 	strd	r2, r3, [r4, #16]
	}

	curr_tick += announce_remaining;
    6cf2:	480c      	ldr	r0, [pc, #48]	; (6d24 <sys_clock_announce+0xc0>)
    6cf4:	490a      	ldr	r1, [pc, #40]	; (6d20 <sys_clock_announce+0xbc>)
    6cf6:	680c      	ldr	r4, [r1, #0]
    6cf8:	e9d0 2300 	ldrd	r2, r3, [r0]
    6cfc:	1912      	adds	r2, r2, r4
    6cfe:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
    6d02:	e9c0 2300 	strd	r2, r3, [r0]
	announce_remaining = 0;
    6d06:	2400      	movs	r4, #0
    6d08:	600c      	str	r4, [r1, #0]

	sys_clock_set_timeout(next_timeout(), false);
    6d0a:	f7ff fedb 	bl	6ac4 <next_timeout>
    6d0e:	4621      	mov	r1, r4
    6d10:	f7fd fca0 	bl	4654 <sys_clock_set_timeout>
	__asm__ volatile(
    6d14:	f385 8811 	msr	BASEPRI, r5
    6d18:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    6d1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6d1e:	bf00      	nop
    6d20:	200009f4 	.word	0x200009f4
    6d24:	20000390 	.word	0x20000390

00006d28 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    6d28:	b510      	push	{r4, lr}
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
    6d2a:	2100      	movs	r1, #0
	__asm__ volatile(
    6d2c:	f04f 0320 	mov.w	r3, #32
    6d30:	f3ef 8411 	mrs	r4, BASEPRI
    6d34:	f383 8812 	msr	BASEPRI_MAX, r3
    6d38:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;
    6d3c:	2200      	movs	r2, #0
    6d3e:	2300      	movs	r3, #0
	LOCKED(&timeout_lock) {
    6d40:	b969      	cbnz	r1, 6d5e <sys_clock_tick_get+0x36>
		t = curr_tick + sys_clock_elapsed();
    6d42:	f7fd fcbb 	bl	46bc <sys_clock_elapsed>
    6d46:	4b07      	ldr	r3, [pc, #28]	; (6d64 <sys_clock_tick_get+0x3c>)
    6d48:	e9d3 2300 	ldrd	r2, r3, [r3]
    6d4c:	1812      	adds	r2, r2, r0
    6d4e:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
    6d52:	f384 8811 	msr	BASEPRI, r4
    6d56:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    6d5a:	2101      	movs	r1, #1
    6d5c:	e7f0      	b.n	6d40 <sys_clock_tick_get+0x18>
	}
	return t;
}
    6d5e:	4610      	mov	r0, r2
    6d60:	4619      	mov	r1, r3
    6d62:	bd10      	pop	{r4, pc}
    6d64:	20000390 	.word	0x20000390

00006d68 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    6d68:	b570      	push	{r4, r5, r6, lr}
    6d6a:	4604      	mov	r4, r0
	__asm__ volatile(
    6d6c:	f04f 0320 	mov.w	r3, #32
    6d70:	f3ef 8611 	mrs	r6, BASEPRI
    6d74:	f383 8812 	msr	BASEPRI_MAX, r3
    6d78:	f3bf 8f6f 	isb	sy
    6d7c:	4635      	mov	r5, r6

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    6d7e:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
    6d82:	ea52 0103 	orrs.w	r1, r2, r3
    6d86:	d005      	beq.n	6d94 <z_timer_expiration_handler+0x2c>
    6d88:	f1b3 3fff 	cmp.w	r3, #4294967295
    6d8c:	bf08      	it	eq
    6d8e:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    6d92:	d127      	bne.n	6de4 <z_timer_expiration_handler+0x7c>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    6d94:	6b23      	ldr	r3, [r4, #48]	; 0x30
    6d96:	3301      	adds	r3, #1
    6d98:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    6d9a:	6a23      	ldr	r3, [r4, #32]
    6d9c:	b173      	cbz	r3, 6dbc <z_timer_expiration_handler+0x54>
	__asm__ volatile(
    6d9e:	f386 8811 	msr	BASEPRI, r6
    6da2:	f3bf 8f6f 	isb	sy
		/* Unlock for user handler. */
		k_spin_unlock(&lock, key);
		timer->expiry_fn(timer);
    6da6:	6a23      	ldr	r3, [r4, #32]
    6da8:	4620      	mov	r0, r4
    6daa:	4798      	blx	r3
	__asm__ volatile(
    6dac:	f04f 0320 	mov.w	r3, #32
    6db0:	f3ef 8511 	mrs	r5, BASEPRI
    6db4:	f383 8812 	msr	BASEPRI_MAX, r3
    6db8:	f3bf 8f6f 	isb	sy
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    6dbc:	f104 0318 	add.w	r3, r4, #24
	return list->head == list;
    6dc0:	69a4      	ldr	r4, [r4, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    6dc2:	42a3      	cmp	r3, r4
    6dc4:	d012      	beq.n	6dec <z_timer_expiration_handler+0x84>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    6dc6:	b18c      	cbz	r4, 6dec <z_timer_expiration_handler+0x84>
		k_spin_unlock(&lock, key);
		return;
	}

	z_unpend_thread_no_timeout(thread);
    6dc8:	4620      	mov	r0, r4
    6dca:	f001 fd77 	bl	88bc <z_unpend_thread_no_timeout>
    6dce:	2300      	movs	r3, #0
    6dd0:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
	__asm__ volatile(
    6dd4:	f385 8811 	msr	BASEPRI, r5
    6dd8:	f3bf 8f6f 	isb	sy

	arch_thread_return_value_set(thread, 0);

	k_spin_unlock(&lock, key);

	z_ready_thread(thread);
    6ddc:	4620      	mov	r0, r4
    6dde:	f001 fdb0 	bl	8942 <z_ready_thread>
}
    6de2:	bd70      	pop	{r4, r5, r6, pc}
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    6de4:	4904      	ldr	r1, [pc, #16]	; (6df8 <z_timer_expiration_handler+0x90>)
    6de6:	f7ff fe93 	bl	6b10 <z_add_timeout>
    6dea:	e7d3      	b.n	6d94 <z_timer_expiration_handler+0x2c>
    6dec:	f385 8811 	msr	BASEPRI, r5
    6df0:	f3bf 8f6f 	isb	sy
		return;
    6df4:	e7f5      	b.n	6de2 <z_timer_expiration_handler+0x7a>
    6df6:	bf00      	nop
    6df8:	00006d69 	.word	0x00006d69

00006dfc <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
    6dfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6e00:	b087      	sub	sp, #28
    6e02:	4614      	mov	r4, r2
    6e04:	461d      	mov	r5, r3
    6e06:	e9dd 8910 	ldrd	r8, r9, [sp, #64]	; 0x40
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    6e0a:	f1b3 3fff 	cmp.w	r3, #4294967295
    6e0e:	bf08      	it	eq
    6e10:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    6e14:	d035      	beq.n	6e82 <z_impl_k_timer_start+0x86>
    6e16:	4606      	mov	r6, r0
    6e18:	4613      	mov	r3, r2
    6e1a:	462a      	mov	r2, r5
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    6e1c:	f1b9 3fff 	cmp.w	r9, #4294967295
    6e20:	bf08      	it	eq
    6e22:	f1b8 3fff 	cmpeq.w	r8, #4294967295
    6e26:	d012      	beq.n	6e4e <z_impl_k_timer_start+0x52>
    6e28:	ea58 0109 	orrs.w	r1, r8, r9
    6e2c:	d00f      	beq.n	6e4e <z_impl_k_timer_start+0x52>
	    Z_TICK_ABS(period.ticks) < 0) {
    6e2e:	f06f 0701 	mvn.w	r7, #1
    6e32:	ebb7 0708 	subs.w	r7, r7, r8
    6e36:	9702      	str	r7, [sp, #8]
    6e38:	f04f 31ff 	mov.w	r1, #4294967295
    6e3c:	eb61 0709 	sbc.w	r7, r1, r9
    6e40:	9703      	str	r7, [sp, #12]
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    6e42:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    6e46:	2800      	cmp	r0, #0
    6e48:	f171 0100 	sbcs.w	r1, r1, #0
    6e4c:	db1c      	blt.n	6e88 <z_impl_k_timer_start+0x8c>
		period.ticks = MAX(period.ticks - 1, 1);
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    6e4e:	f06f 0101 	mvn.w	r1, #1
    6e52:	ebb1 0a03 	subs.w	sl, r1, r3
    6e56:	f04f 31ff 	mov.w	r1, #4294967295
    6e5a:	eb61 0b02 	sbc.w	fp, r1, r2
    6e5e:	f1ba 0f00 	cmp.w	sl, #0
    6e62:	f17b 0100 	sbcs.w	r1, fp, #0
    6e66:	db23      	blt.n	6eb0 <z_impl_k_timer_start+0xb4>
		duration.ticks = MAX(duration.ticks - 1, 0);
	}

	(void)z_abort_timeout(&timer->timeout);
    6e68:	4630      	mov	r0, r6
    6e6a:	f001 fe72 	bl	8b52 <z_abort_timeout>
	timer->period = period;
    6e6e:	e9c6 890a 	strd	r8, r9, [r6, #40]	; 0x28
	timer->status = 0U;
    6e72:	2300      	movs	r3, #0
    6e74:	6333      	str	r3, [r6, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    6e76:	4622      	mov	r2, r4
    6e78:	462b      	mov	r3, r5
    6e7a:	4917      	ldr	r1, [pc, #92]	; (6ed8 <z_impl_k_timer_start+0xdc>)
    6e7c:	4630      	mov	r0, r6
    6e7e:	f7ff fe47 	bl	6b10 <z_add_timeout>
		     duration);
}
    6e82:	b007      	add	sp, #28
    6e84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		period.ticks = MAX(period.ticks - 1, 1);
    6e88:	f118 31ff 	adds.w	r1, r8, #4294967295
    6e8c:	9104      	str	r1, [sp, #16]
    6e8e:	f149 31ff 	adc.w	r1, r9, #4294967295
    6e92:	9105      	str	r1, [sp, #20]
    6e94:	e9dd 7804 	ldrd	r7, r8, [sp, #16]
    6e98:	4638      	mov	r0, r7
    6e9a:	4641      	mov	r1, r8
    6e9c:	2f01      	cmp	r7, #1
    6e9e:	f178 0700 	sbcs.w	r7, r8, #0
    6ea2:	db02      	blt.n	6eaa <z_impl_k_timer_start+0xae>
    6ea4:	4680      	mov	r8, r0
    6ea6:	4689      	mov	r9, r1
    6ea8:	e7d1      	b.n	6e4e <z_impl_k_timer_start+0x52>
    6eaa:	2001      	movs	r0, #1
    6eac:	2100      	movs	r1, #0
    6eae:	e7f9      	b.n	6ea4 <z_impl_k_timer_start+0xa8>
		duration.ticks = MAX(duration.ticks - 1, 0);
    6eb0:	f113 33ff 	adds.w	r3, r3, #4294967295
    6eb4:	9300      	str	r3, [sp, #0]
    6eb6:	f142 33ff 	adc.w	r3, r2, #4294967295
    6eba:	9301      	str	r3, [sp, #4]
    6ebc:	e9dd 0100 	ldrd	r0, r1, [sp]
    6ec0:	4602      	mov	r2, r0
    6ec2:	460b      	mov	r3, r1
    6ec4:	2800      	cmp	r0, #0
    6ec6:	f171 0100 	sbcs.w	r1, r1, #0
    6eca:	db02      	blt.n	6ed2 <z_impl_k_timer_start+0xd6>
    6ecc:	4614      	mov	r4, r2
    6ece:	461d      	mov	r5, r3
    6ed0:	e7ca      	b.n	6e68 <z_impl_k_timer_start+0x6c>
    6ed2:	2200      	movs	r2, #0
    6ed4:	4613      	mov	r3, r2
    6ed6:	e7f9      	b.n	6ecc <z_impl_k_timer_start+0xd0>
    6ed8:	00006d69 	.word	0x00006d69

00006edc <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    6edc:	b508      	push	{r3, lr}
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    6ede:	4a03      	ldr	r2, [pc, #12]	; (6eec <boot_banner+0x10>)
    6ee0:	4903      	ldr	r1, [pc, #12]	; (6ef0 <boot_banner+0x14>)
    6ee2:	4804      	ldr	r0, [pc, #16]	; (6ef4 <boot_banner+0x18>)
    6ee4:	f000 f94b 	bl	717e <printk>
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
    6ee8:	bd08      	pop	{r3, pc}
    6eea:	bf00      	nop
    6eec:	00008fbc 	.word	0x00008fbc
    6ef0:	00009964 	.word	0x00009964
    6ef4:	00009974 	.word	0x00009974

00006ef8 <writeReg_bmx160>:

int writeReg_bmx160(bmx160_spi * bmxIMU_spi_p, uint8_t reg, uint8_t data)
{
    6ef8:	b530      	push	{r4, r5, lr}
    6efa:	b089      	sub	sp, #36	; 0x24
    6efc:	4604      	mov	r4, r0
    6efe:	f88d 1007 	strb.w	r1, [sp, #7]
    6f02:	f88d 2006 	strb.w	r2, [sp, #6]
    int result;
	const struct spi_buf buf[2] = {
    6f06:	f10d 0307 	add.w	r3, sp, #7
    6f0a:	9304      	str	r3, [sp, #16]
    6f0c:	2301      	movs	r3, #1
    6f0e:	9305      	str	r3, [sp, #20]
    6f10:	f10d 0206 	add.w	r2, sp, #6
    6f14:	9206      	str	r2, [sp, #24]
    6f16:	9307      	str	r3, [sp, #28]
		{
			.buf = &data,
			.len = 1,
		}
	};
	const struct spi_buf_set tx = {
    6f18:	aa04      	add	r2, sp, #16
    6f1a:	9202      	str	r2, [sp, #8]
    6f1c:	2202      	movs	r2, #2
    6f1e:	9203      	str	r2, [sp, #12]
		.buffers = buf,
		.count = 2,
	};
	gpio_pin_set(bmxIMU_spi_p->gpio0_dev, bmxIMU_spi_p->spi_cs_pin, 1);
    6f20:	6940      	ldr	r0, [r0, #20]
    6f22:	7c21      	ldrb	r1, [r4, #16]
	const struct gpio_driver_data *const data =
    6f24:	6902      	ldr	r2, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    6f26:	6812      	ldr	r2, [r2, #0]
    6f28:	408b      	lsls	r3, r1
    6f2a:	421a      	tst	r2, r3
    6f2c:	d123      	bne.n	6f76 <writeReg_bmx160+0x7e>
    6f2e:	2301      	movs	r3, #1
	if (value != 0)	{
    6f30:	b31b      	cbz	r3, 6f7a <writeReg_bmx160+0x82>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    6f32:	2301      	movs	r3, #1
    6f34:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    6f38:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    6f3a:	68db      	ldr	r3, [r3, #12]
    6f3c:	4798      	blx	r3

	//result = spi_write_dt(bus, &tx);
	result = spi_write(bmxIMU_spi_p->spi_dev, &bmxIMU_spi_p->spi_cfg, &tx);
    6f3e:	68e0      	ldr	r0, [r4, #12]
static inline int z_impl_spi_transceive(const struct device *dev,
					const struct spi_config *config,
					const struct spi_buf_set *tx_bufs,
					const struct spi_buf_set *rx_bufs)
{
	const struct spi_driver_api *api =
    6f40:	6883      	ldr	r3, [r0, #8]
		(const struct spi_driver_api *)dev->api;

	return api->transceive(dev, config, tx_bufs, rx_bufs);
    6f42:	681d      	ldr	r5, [r3, #0]
    6f44:	2300      	movs	r3, #0
    6f46:	aa02      	add	r2, sp, #8
    6f48:	4621      	mov	r1, r4
    6f4a:	47a8      	blx	r5
	if (result) 
    6f4c:	4605      	mov	r5, r0
    6f4e:	b978      	cbnz	r0, 6f70 <writeReg_bmx160+0x78>
    {
        return result;
		//printk("SPI error: %d\n", result);
	}
    gpio_pin_set(bmxIMU_spi_p->gpio0_dev, bmxIMU_spi_p->spi_cs_pin, 0);
    6f50:	6960      	ldr	r0, [r4, #20]
    6f52:	7c21      	ldrb	r1, [r4, #16]
	const struct gpio_driver_data *const data =
    6f54:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    6f56:	681a      	ldr	r2, [r3, #0]
    6f58:	2301      	movs	r3, #1
    6f5a:	408b      	lsls	r3, r1
    6f5c:	421a      	tst	r2, r3
    6f5e:	d113      	bne.n	6f88 <writeReg_bmx160+0x90>
    6f60:	462b      	mov	r3, r5
	if (value != 0)	{
    6f62:	b19b      	cbz	r3, 6f8c <writeReg_bmx160+0x94>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    6f64:	2301      	movs	r3, #1
    6f66:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    6f6a:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    6f6c:	68db      	ldr	r3, [r3, #12]
    6f6e:	4798      	blx	r3
    return 0;
}
    6f70:	4628      	mov	r0, r5
    6f72:	b009      	add	sp, #36	; 0x24
    6f74:	bd30      	pop	{r4, r5, pc}
		value = (value != 0) ? 0 : 1;
    6f76:	2300      	movs	r3, #0
    6f78:	e7da      	b.n	6f30 <writeReg_bmx160+0x38>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    6f7a:	2301      	movs	r3, #1
    6f7c:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    6f80:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    6f82:	691b      	ldr	r3, [r3, #16]
    6f84:	4798      	blx	r3
    6f86:	e7da      	b.n	6f3e <writeReg_bmx160+0x46>
		value = (value != 0) ? 0 : 1;
    6f88:	2301      	movs	r3, #1
    6f8a:	e7ea      	b.n	6f62 <writeReg_bmx160+0x6a>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    6f8c:	2301      	movs	r3, #1
    6f8e:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    6f92:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    6f94:	691b      	ldr	r3, [r3, #16]
    6f96:	4798      	blx	r3
	return ret;
    6f98:	e7ea      	b.n	6f70 <writeReg_bmx160+0x78>

00006f9a <setAccel_ODR_BWP_bmx160>:
{
    6f9a:	b508      	push	{r3, lr}
    writeReg_bmx160(bmxIMU_spi_p, BMX160_ACC_CONF_REG, sentVal);
    6f9c:	430a      	orrs	r2, r1
    6f9e:	2140      	movs	r1, #64	; 0x40
    6fa0:	f7ff ffaa 	bl	6ef8 <writeReg_bmx160>
}
    6fa4:	bd08      	pop	{r3, pc}

00006fa6 <setGyro_ODR_BWP_bmx160>:
{
    6fa6:	b508      	push	{r3, lr}
    writeReg_bmx160(bmxIMU_spi_p, BMX160_GYR_CONF_REG, sentVal);
    6fa8:	430a      	orrs	r2, r1
    6faa:	2142      	movs	r1, #66	; 0x42
    6fac:	f7ff ffa4 	bl	6ef8 <writeReg_bmx160>
}
    6fb0:	bd08      	pop	{r3, pc}

00006fb2 <setSensorMode_bmx160>:
{
    6fb2:	b510      	push	{r4, lr}
    6fb4:	4614      	mov	r4, r2
    writeReg_bmx160(bmxIMU_spi_p, BMX160_CMD_REG, data);
    6fb6:	460a      	mov	r2, r1
    6fb8:	217e      	movs	r1, #126	; 0x7e
    6fba:	f7ff ff9d 	bl	6ef8 <writeReg_bmx160>
    6fbe:	03e1      	lsls	r1, r4, #15
    6fc0:	f240 30e7 	movw	r0, #999	; 0x3e7
    6fc4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    6fc8:	2300      	movs	r3, #0
    6fca:	1808      	adds	r0, r1, r0
    6fcc:	f04f 0400 	mov.w	r4, #0
    6fd0:	4621      	mov	r1, r4
    6fd2:	eb44 0101 	adc.w	r1, r4, r1
    6fd6:	f7f9 fa43 	bl	460 <__aeabi_uldivmod>
	return z_impl_k_sleep(timeout);
    6fda:	f7ff fcdd 	bl	6998 <z_impl_k_sleep>
}
    6fde:	bd10      	pop	{r4, pc}

00006fe0 <readReg_bmx160>:

int readReg_bmx160(bmx160_spi * bmxIMU_spi_p, uint8_t reg, uint8_t *data, size_t len)
{
    6fe0:	b530      	push	{r4, r5, lr}
    6fe2:	b08d      	sub	sp, #52	; 0x34
    6fe4:	4604      	mov	r4, r0
    int result;
	unsigned char tx_buffer[2] = { 0, };
    6fe6:	2000      	movs	r0, #0
    6fe8:	f8ad 002c 	strh.w	r0, [sp, #44]	; 0x2c

	tx_buffer[0] = 0x80 | reg;
    6fec:	f061 017f 	orn	r1, r1, #127	; 0x7f
    6ff0:	f88d 102c 	strb.w	r1, [sp, #44]	; 0x2c

	const struct spi_buf tx_buf = {
    6ff4:	a90b      	add	r1, sp, #44	; 0x2c
    6ff6:	9109      	str	r1, [sp, #36]	; 0x24
    6ff8:	2501      	movs	r5, #1
    6ffa:	950a      	str	r5, [sp, #40]	; 0x28
		.buf = tx_buffer,
		.len = 1,
	};
	const struct spi_buf_set tx = {
    6ffc:	a809      	add	r0, sp, #36	; 0x24
    6ffe:	9007      	str	r0, [sp, #28]
    7000:	9508      	str	r5, [sp, #32]
		.buffers = &tx_buf,
		.count = 1,
	};

	struct spi_buf rx_buf[2] = {
    7002:	9103      	str	r1, [sp, #12]
    7004:	9504      	str	r5, [sp, #16]
    7006:	9205      	str	r2, [sp, #20]
    7008:	9306      	str	r3, [sp, #24]
			.buf = data,
			.len = len,
		}
	};

	const struct spi_buf_set rx = {
    700a:	ab03      	add	r3, sp, #12
    700c:	9301      	str	r3, [sp, #4]
    700e:	2302      	movs	r3, #2
    7010:	9302      	str	r3, [sp, #8]
		.buffers = rx_buf,
		.count = 2,
	};
	gpio_pin_set(bmxIMU_spi_p->gpio0_dev, bmxIMU_spi_p->spi_cs_pin, 1);
    7012:	6960      	ldr	r0, [r4, #20]
    7014:	7c21      	ldrb	r1, [r4, #16]
	const struct gpio_driver_data *const data =
    7016:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    7018:	681b      	ldr	r3, [r3, #0]
    701a:	408d      	lsls	r5, r1
    701c:	422b      	tst	r3, r5
    701e:	d122      	bne.n	7066 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x66>
    7020:	2301      	movs	r3, #1
	if (value != 0)	{
    7022:	b313      	cbz	r3, 706a <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x6a>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    7024:	2301      	movs	r3, #1
    7026:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    702a:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    702c:	68db      	ldr	r3, [r3, #12]
    702e:	4798      	blx	r3
	result = spi_transceive(bmxIMU_spi_p->spi_dev, &bmxIMU_spi_p->spi_cfg, &tx, &rx);
    7030:	68e0      	ldr	r0, [r4, #12]
	const struct spi_driver_api *api =
    7032:	6883      	ldr	r3, [r0, #8]
	return api->transceive(dev, config, tx_bufs, rx_bufs);
    7034:	681d      	ldr	r5, [r3, #0]
    7036:	ab01      	add	r3, sp, #4
    7038:	aa07      	add	r2, sp, #28
    703a:	4621      	mov	r1, r4
    703c:	47a8      	blx	r5
    703e:	4605      	mov	r5, r0
    gpio_pin_set(bmxIMU_spi_p->gpio0_dev, bmxIMU_spi_p->spi_cs_pin, 0);
    7040:	6960      	ldr	r0, [r4, #20]
    7042:	7c21      	ldrb	r1, [r4, #16]
	const struct gpio_driver_data *const data =
    7044:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    7046:	681a      	ldr	r2, [r3, #0]
    7048:	2301      	movs	r3, #1
    704a:	408b      	lsls	r3, r1
    704c:	421a      	tst	r2, r3
    704e:	d113      	bne.n	7078 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x78>
    7050:	2300      	movs	r3, #0
	if (value != 0)	{
    7052:	b19b      	cbz	r3, 707c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x7c>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    7054:	2301      	movs	r3, #1
    7056:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    705a:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    705c:	68db      	ldr	r3, [r3, #12]
    705e:	4798      	blx	r3
	if (result) {
		return result;
	}

	return 0;
}
    7060:	4628      	mov	r0, r5
    7062:	b00d      	add	sp, #52	; 0x34
    7064:	bd30      	pop	{r4, r5, pc}
		value = (value != 0) ? 0 : 1;
    7066:	2300      	movs	r3, #0
    7068:	e7db      	b.n	7022 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x22>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    706a:	2301      	movs	r3, #1
    706c:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    7070:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    7072:	691b      	ldr	r3, [r3, #16]
    7074:	4798      	blx	r3
    7076:	e7db      	b.n	7030 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x30>
		value = (value != 0) ? 0 : 1;
    7078:	2301      	movs	r3, #1
    707a:	e7ea      	b.n	7052 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x52>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    707c:	2301      	movs	r3, #1
    707e:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    7082:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    7084:	691b      	ldr	r3, [r3, #16]
    7086:	4798      	blx	r3
	if (result) {
    7088:	e7ea      	b.n	7060 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x60>

0000708a <getChipID_bmx160>:
{
    708a:	b508      	push	{r3, lr}
    708c:	460a      	mov	r2, r1
    result = readReg_bmx160(bmxIMU_spi_p, BMX160_CHIP_ID_REG, chipID, 1);
    708e:	2301      	movs	r3, #1
    7090:	2100      	movs	r1, #0
    7092:	f7ff ffa5 	bl	6fe0 <readReg_bmx160>
}
    7096:	bd08      	pop	{r3, pc}

00007098 <begin_bmx160>:
{
    7098:	b510      	push	{r4, lr}
    709a:	b082      	sub	sp, #8
    709c:	4604      	mov	r4, r0
    uint8_t chipID = 0;
    709e:	2200      	movs	r2, #0
    70a0:	f88d 2007 	strb.w	r2, [sp, #7]
    readReg_bmx160(bmxIMU_spi_p, BMX160_STARTUP_WRITE_REG, NULL, 1);
    70a4:	2301      	movs	r3, #1
    70a6:	217f      	movs	r1, #127	; 0x7f
    70a8:	f7ff ff9a 	bl	6fe0 <readReg_bmx160>
    getChipID_bmx160(bmxIMU_spi_p, &chipID);
    70ac:	f10d 0107 	add.w	r1, sp, #7
    70b0:	4620      	mov	r0, r4
    70b2:	f7ff ffea 	bl	708a <getChipID_bmx160>
    if(chipID != BMI160_CHIP_ID)
    70b6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    70ba:	2bd1      	cmp	r3, #209	; 0xd1
    70bc:	d11e      	bne.n	70fc <begin_bmx160+0x64>
    setSensorMode_bmx160(bmxIMU_spi_p, bmx160_accel_normal_mode, BMX160_ACCEL_DELAY_MS);    
    70be:	2204      	movs	r2, #4
    70c0:	2111      	movs	r1, #17
    70c2:	4620      	mov	r0, r4
    70c4:	f7ff ff75 	bl	6fb2 <setSensorMode_bmx160>
    setSensorMode_bmx160(bmxIMU_spi_p, bmx160_gyro_normal_mode, BMX160_GRYO_DELAY_MS);  
    70c8:	2250      	movs	r2, #80	; 0x50
    70ca:	2115      	movs	r1, #21
    70cc:	4620      	mov	r0, r4
    70ce:	f7ff ff70 	bl	6fb2 <setSensorMode_bmx160>
    setAccel_ODR_BWP_bmx160(bmxIMU_spi_p, bmx160_accel_odr_1600, bmx160_accel_bwp_osr_1);
    70d2:	2220      	movs	r2, #32
    70d4:	210c      	movs	r1, #12
    70d6:	4620      	mov	r0, r4
    70d8:	f7ff ff5f 	bl	6f9a <setAccel_ODR_BWP_bmx160>
    setGyro_ODR_BWP_bmx160(bmxIMU_spi_p, bmx160_gyr_odr_1600, bmx160_gyr_bwp_osr_1);
    70dc:	2220      	movs	r2, #32
    70de:	210c      	movs	r1, #12
    70e0:	4620      	mov	r0, r4
    70e2:	f7ff ff60 	bl	6fa6 <setGyro_ODR_BWP_bmx160>
    setAccelRange_bmx160(bmxIMU_spi_p, bmx160_accelRange_4g);
    70e6:	2105      	movs	r1, #5
    70e8:	4620      	mov	r0, r4
    70ea:	f7f9 fbb7 	bl	85c <setAccelRange_bmx160>
    setGyroRange_bmx160(bmxIMU_spi_p, bmx160_gyroRange_1000dps);
    70ee:	2101      	movs	r1, #1
    70f0:	4620      	mov	r0, r4
    70f2:	f7f9 fbe1 	bl	8b8 <setGyroRange_bmx160>
    return BMX160_OK;
    70f6:	2000      	movs	r0, #0
}
    70f8:	b002      	add	sp, #8
    70fa:	bd10      	pop	{r4, pc}
        return BMX160_WRONG_CHIP_ID;
    70fc:	f06f 0062 	mvn.w	r0, #98	; 0x62
    7100:	e7fa      	b.n	70f8 <begin_bmx160+0x60>

00007102 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    7102:	4602      	mov	r2, r0
    7104:	b158      	cbz	r0, 711e <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    7106:	6843      	ldr	r3, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    7108:	f003 0303 	and.w	r3, r3, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    710c:	2b01      	cmp	r3, #1
    710e:	d003      	beq.n	7118 <sys_notify_validate+0x16>
    7110:	2b03      	cmp	r3, #3
    7112:	d107      	bne.n	7124 <sys_notify_validate+0x22>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
    7114:	6803      	ldr	r3, [r0, #0]
    7116:	b143      	cbz	r3, 712a <sys_notify_validate+0x28>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
    7118:	2000      	movs	r0, #0
    711a:	6090      	str	r0, [r2, #8]
    711c:	4770      	bx	lr
		return -EINVAL;
    711e:	f06f 0015 	mvn.w	r0, #21
    7122:	4770      	bx	lr
	switch (sys_notify_get_method(notify)) {
    7124:	f06f 0015 	mvn.w	r0, #21
    7128:	4770      	bx	lr
			rv = -EINVAL;
    712a:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
    712e:	4770      	bx	lr

00007130 <sys_notify_finalize>:

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
    7130:	4603      	mov	r3, r0
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    7132:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    7134:	f002 0203 	and.w	r2, r2, #3
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
    7138:	6081      	str	r1, [r0, #8]
	switch (method) {
    713a:	2a03      	cmp	r2, #3
    713c:	d103      	bne.n	7146 <sys_notify_finalize+0x16>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    713e:	6800      	ldr	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    7140:	2200      	movs	r2, #0
    7142:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    7144:	4770      	bx	lr
	sys_notify_generic_callback rv = NULL;
    7146:	2000      	movs	r0, #0
    7148:	e7fa      	b.n	7140 <sys_notify_finalize+0x10>

0000714a <arch_printk_char_out>:
}
    714a:	2000      	movs	r0, #0
    714c:	4770      	bx	lr

0000714e <str_out>:
{
    714e:	b410      	push	{r4}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    7150:	680c      	ldr	r4, [r1, #0]
    7152:	b154      	cbz	r4, 716a <str_out+0x1c>
    7154:	688a      	ldr	r2, [r1, #8]
    7156:	684b      	ldr	r3, [r1, #4]
    7158:	429a      	cmp	r2, r3
    715a:	da06      	bge.n	716a <str_out+0x1c>
	if (ctx->count == ctx->max - 1) {
    715c:	3b01      	subs	r3, #1
    715e:	429a      	cmp	r2, r3
    7160:	d008      	beq.n	7174 <str_out+0x26>
		ctx->str[ctx->count++] = c;
    7162:	1c53      	adds	r3, r2, #1
    7164:	608b      	str	r3, [r1, #8]
    7166:	54a0      	strb	r0, [r4, r2]
    7168:	e002      	b.n	7170 <str_out+0x22>
		ctx->count++;
    716a:	688b      	ldr	r3, [r1, #8]
    716c:	3301      	adds	r3, #1
    716e:	608b      	str	r3, [r1, #8]
}
    7170:	bc10      	pop	{r4}
    7172:	4770      	bx	lr
		ctx->str[ctx->count++] = '\0';
    7174:	1c53      	adds	r3, r2, #1
    7176:	608b      	str	r3, [r1, #8]
    7178:	2300      	movs	r3, #0
    717a:	54a3      	strb	r3, [r4, r2]
    717c:	e7f8      	b.n	7170 <str_out+0x22>

0000717e <printk>:
{
    717e:	b40f      	push	{r0, r1, r2, r3}
    7180:	b500      	push	{lr}
    7182:	b083      	sub	sp, #12
    7184:	a904      	add	r1, sp, #16
    7186:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    718a:	9101      	str	r1, [sp, #4]
	z_log_printk(fmt, ap);
    718c:	f7fa fd54 	bl	1c38 <z_log_printk>
}
    7190:	b003      	add	sp, #12
    7192:	f85d eb04 	ldr.w	lr, [sp], #4
    7196:	b004      	add	sp, #16
    7198:	4770      	bx	lr

0000719a <snprintk>:
{
    719a:	b40c      	push	{r2, r3}
    719c:	b500      	push	{lr}
    719e:	b083      	sub	sp, #12
    71a0:	ab04      	add	r3, sp, #16
    71a2:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
    71a6:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
    71a8:	f7f9 fc34 	bl	a14 <vsnprintk>
}
    71ac:	b003      	add	sp, #12
    71ae:	f85d eb04 	ldr.w	lr, [sp], #4
    71b2:	b002      	add	sp, #8
    71b4:	4770      	bx	lr

000071b6 <set_state>:
	mgr->flags = (state & ONOFF_STATE_MASK)
    71b6:	f001 0307 	and.w	r3, r1, #7
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    71ba:	8b01      	ldrh	r1, [r0, #24]
    71bc:	f021 0107 	bic.w	r1, r1, #7
    71c0:	4319      	orrs	r1, r3
	mgr->flags = (state & ONOFF_STATE_MASK)
    71c2:	8301      	strh	r1, [r0, #24]
}
    71c4:	4770      	bx	lr

000071c6 <notify_monitors>:
{
    71c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    71ca:	4606      	mov	r6, r0
    71cc:	460f      	mov	r7, r1
    71ce:	4690      	mov	r8, r2
	return list->head;
    71d0:	6881      	ldr	r1, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    71d2:	b119      	cbz	r1, 71dc <notify_monitors+0x16>
    71d4:	460c      	mov	r4, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
    71d6:	b131      	cbz	r1, 71e6 <notify_monitors+0x20>
	return node->next;
    71d8:	680c      	ldr	r4, [r1, #0]
    71da:	e004      	b.n	71e6 <notify_monitors+0x20>
    71dc:	460c      	mov	r4, r1
    71de:	e002      	b.n	71e6 <notify_monitors+0x20>
    71e0:	4623      	mov	r3, r4
    71e2:	4621      	mov	r1, r4
    71e4:	461c      	mov	r4, r3
    71e6:	b159      	cbz	r1, 7200 <notify_monitors+0x3a>
		mon->callback(mgr, mon, state, res);
    71e8:	684d      	ldr	r5, [r1, #4]
    71ea:	4643      	mov	r3, r8
    71ec:	463a      	mov	r2, r7
    71ee:	4630      	mov	r0, r6
    71f0:	47a8      	blx	r5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    71f2:	2c00      	cmp	r4, #0
    71f4:	d0f4      	beq.n	71e0 <notify_monitors+0x1a>
    71f6:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
    71f8:	2c00      	cmp	r4, #0
    71fa:	d0f2      	beq.n	71e2 <notify_monitors+0x1c>
	return node->next;
    71fc:	6823      	ldr	r3, [r4, #0]
    71fe:	e7f0      	b.n	71e2 <notify_monitors+0x1c>
}
    7200:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007204 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    7204:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
    7206:	f013 0307 	ands.w	r3, r3, #7
    720a:	d103      	bne.n	7214 <process_recheck+0x10>
	return list->head;
    720c:	6802      	ldr	r2, [r0, #0]
	    && !sys_slist_is_empty(&mgr->clients)) {
    720e:	b10a      	cbz	r2, 7214 <process_recheck+0x10>
		evt = EVT_START;
    7210:	2003      	movs	r0, #3
    7212:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
    7214:	2b02      	cmp	r3, #2
    7216:	d003      	beq.n	7220 <process_recheck+0x1c>
	} else if ((state == ONOFF_STATE_ERROR)
    7218:	2b01      	cmp	r3, #1
    721a:	d006      	beq.n	722a <process_recheck+0x26>
	int evt = EVT_NOP;
    721c:	2000      	movs	r0, #0
    721e:	4770      	bx	lr
		   && (mgr->refs == 0U)) {
    7220:	8b42      	ldrh	r2, [r0, #26]
    7222:	2a00      	cmp	r2, #0
    7224:	d1f8      	bne.n	7218 <process_recheck+0x14>
		evt = EVT_STOP;
    7226:	2004      	movs	r0, #4
    7228:	4770      	bx	lr
    722a:	6803      	ldr	r3, [r0, #0]
		   && !sys_slist_is_empty(&mgr->clients)) {
    722c:	b10b      	cbz	r3, 7232 <process_recheck+0x2e>
		evt = EVT_RESET;
    722e:	2005      	movs	r0, #5
}
    7230:	4770      	bx	lr
	int evt = EVT_NOP;
    7232:	2000      	movs	r0, #0
    7234:	4770      	bx	lr

00007236 <process_complete>:
{
    7236:	b538      	push	{r3, r4, r5, lr}
    7238:	4604      	mov	r4, r0
    723a:	460d      	mov	r5, r1
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    723c:	8b03      	ldrh	r3, [r0, #24]
	if (res < 0) {
    723e:	2a00      	cmp	r2, #0
    7240:	db07      	blt.n	7252 <process_complete+0x1c>
    7242:	f003 0307 	and.w	r3, r3, #7
		   || (state == ONOFF_STATE_RESETTING)) {
    7246:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    7248:	2a01      	cmp	r2, #1
    724a:	d90e      	bls.n	726a <process_complete+0x34>
	} else if (state == ONOFF_STATE_TO_OFF) {
    724c:	2b04      	cmp	r3, #4
    724e:	d032      	beq.n	72b6 <process_complete+0x80>
}
    7250:	bd38      	pop	{r3, r4, r5, pc}
		*clients = mgr->clients;
    7252:	e9d0 0100 	ldrd	r0, r1, [r0]
    7256:	e885 0003 	stmia.w	r5, {r0, r1}
	list->head = NULL;
    725a:	2300      	movs	r3, #0
    725c:	6023      	str	r3, [r4, #0]
	list->tail = NULL;
    725e:	6063      	str	r3, [r4, #4]
		set_state(mgr, ONOFF_STATE_ERROR);
    7260:	2101      	movs	r1, #1
    7262:	4620      	mov	r0, r4
    7264:	f7ff ffa7 	bl	71b6 <set_state>
    7268:	e7f2      	b.n	7250 <process_complete+0x1a>
		*clients = mgr->clients;
    726a:	e9d0 0100 	ldrd	r0, r1, [r0]
    726e:	e885 0003 	stmia.w	r5, {r0, r1}
	list->head = NULL;
    7272:	2200      	movs	r2, #0
    7274:	6022      	str	r2, [r4, #0]
	list->tail = NULL;
    7276:	6062      	str	r2, [r4, #4]
		if (state == ONOFF_STATE_TO_ON) {
    7278:	2b06      	cmp	r3, #6
    727a:	d117      	bne.n	72ac <process_complete+0x76>
	return list->head;
    727c:	682b      	ldr	r3, [r5, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    727e:	b13b      	cbz	r3, 7290 <process_complete+0x5a>
				mgr->refs += 1U;
    7280:	8b62      	ldrh	r2, [r4, #26]
    7282:	3201      	adds	r2, #1
    7284:	8362      	strh	r2, [r4, #26]
Z_GENLIST_PEEK_NEXT(slist, snode)
    7286:	2b00      	cmp	r3, #0
    7288:	d0f9      	beq.n	727e <process_complete+0x48>
	return node->next;
    728a:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    728c:	2b00      	cmp	r3, #0
    728e:	d1f6      	bne.n	727e <process_complete+0x48>
			set_state(mgr, ONOFF_STATE_ON);
    7290:	2102      	movs	r1, #2
    7292:	4620      	mov	r0, r4
    7294:	f7ff ff8f 	bl	71b6 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    7298:	4620      	mov	r0, r4
    729a:	f7ff ffb3 	bl	7204 <process_recheck>
    729e:	2800      	cmp	r0, #0
    72a0:	d0d6      	beq.n	7250 <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    72a2:	8b23      	ldrh	r3, [r4, #24]
    72a4:	f043 0320 	orr.w	r3, r3, #32
    72a8:	8323      	strh	r3, [r4, #24]
    72aa:	e7d1      	b.n	7250 <process_complete+0x1a>
			set_state(mgr, ONOFF_STATE_OFF);
    72ac:	2100      	movs	r1, #0
    72ae:	4620      	mov	r0, r4
    72b0:	f7ff ff81 	bl	71b6 <set_state>
    72b4:	e7f0      	b.n	7298 <process_complete+0x62>
		set_state(mgr, ONOFF_STATE_OFF);
    72b6:	2100      	movs	r1, #0
    72b8:	f7ff ff7d 	bl	71b6 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    72bc:	4620      	mov	r0, r4
    72be:	f7ff ffa1 	bl	7204 <process_recheck>
    72c2:	2800      	cmp	r0, #0
    72c4:	d0c4      	beq.n	7250 <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    72c6:	8b23      	ldrh	r3, [r4, #24]
    72c8:	f043 0320 	orr.w	r3, r3, #32
    72cc:	8323      	strh	r3, [r4, #24]
}
    72ce:	e7bf      	b.n	7250 <process_complete+0x1a>

000072d0 <validate_args>:
	if ((mgr == NULL) || (cli == NULL)) {
    72d0:	b158      	cbz	r0, 72ea <validate_args+0x1a>
{
    72d2:	b510      	push	{r4, lr}
    72d4:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    72d6:	b159      	cbz	r1, 72f0 <validate_args+0x20>
	int rv = sys_notify_validate(&cli->notify);
    72d8:	1d08      	adds	r0, r1, #4
    72da:	f7ff ff12 	bl	7102 <sys_notify_validate>
	if ((rv == 0)
    72de:	b918      	cbnz	r0, 72e8 <validate_args+0x18>
	    && ((cli->notify.flags
    72e0:	68a3      	ldr	r3, [r4, #8]
    72e2:	f033 0303 	bics.w	r3, r3, #3
    72e6:	d106      	bne.n	72f6 <validate_args+0x26>
}
    72e8:	bd10      	pop	{r4, pc}
		return -EINVAL;
    72ea:	f06f 0015 	mvn.w	r0, #21
}
    72ee:	4770      	bx	lr
		return -EINVAL;
    72f0:	f06f 0015 	mvn.w	r0, #21
    72f4:	e7f8      	b.n	72e8 <validate_args+0x18>
		rv = -EINVAL;
    72f6:	f06f 0015 	mvn.w	r0, #21
    72fa:	e7f5      	b.n	72e8 <validate_args+0x18>

000072fc <notify_one>:
{
    72fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7300:	4607      	mov	r7, r0
    7302:	460c      	mov	r4, r1
    7304:	4616      	mov	r6, r2
    7306:	461d      	mov	r5, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    7308:	4619      	mov	r1, r3
    730a:	1d20      	adds	r0, r4, #4
    730c:	f7ff ff10 	bl	7130 <sys_notify_finalize>
	if (cb) {
    7310:	b128      	cbz	r0, 731e <notify_one+0x22>
    7312:	4680      	mov	r8, r0
		cb(mgr, cli, state, res);
    7314:	462b      	mov	r3, r5
    7316:	4632      	mov	r2, r6
    7318:	4621      	mov	r1, r4
    731a:	4638      	mov	r0, r7
    731c:	47c0      	blx	r8
}
    731e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007322 <notify_all>:
{
    7322:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7326:	4681      	mov	r9, r0
    7328:	460c      	mov	r4, r1
    732a:	4690      	mov	r8, r2
    732c:	461f      	mov	r7, r3
	while (!sys_slist_is_empty(list)) {
    732e:	e005      	b.n	733c <notify_all+0x1a>
	list->tail = node;
    7330:	6065      	str	r5, [r4, #4]
		notify_one(mgr, cli, state, res);
    7332:	463b      	mov	r3, r7
    7334:	4642      	mov	r2, r8
    7336:	4648      	mov	r0, r9
    7338:	f7ff ffe0 	bl	72fc <notify_one>
	return list->head;
    733c:	6821      	ldr	r1, [r4, #0]
	while (!sys_slist_is_empty(list)) {
    733e:	b129      	cbz	r1, 734c <notify_all+0x2a>
	return node->next;
    7340:	680d      	ldr	r5, [r1, #0]
	list->head = node;
    7342:	6025      	str	r5, [r4, #0]
	return list->tail;
    7344:	6866      	ldr	r6, [r4, #4]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    7346:	428e      	cmp	r6, r1
    7348:	d1f3      	bne.n	7332 <notify_all+0x10>
    734a:	e7f1      	b.n	7330 <notify_all+0xe>
}
    734c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00007350 <transition_complete>:
{
    7350:	b510      	push	{r4, lr}
	__asm__ volatile(
    7352:	f04f 0420 	mov.w	r4, #32
    7356:	f3ef 8211 	mrs	r2, BASEPRI
    735a:	f384 8812 	msr	BASEPRI_MAX, r4
    735e:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
    7362:	6141      	str	r1, [r0, #20]
	process_event(mgr, EVT_COMPLETE, key);
    7364:	2101      	movs	r1, #1
    7366:	f7f9 fb6b 	bl	a40 <process_event>
}
    736a:	bd10      	pop	{r4, pc}

0000736c <onoff_manager_init>:
	if ((mgr == NULL)
    736c:	4603      	mov	r3, r0
    736e:	b168      	cbz	r0, 738c <onoff_manager_init+0x20>
	    || (transitions == NULL)
    7370:	b179      	cbz	r1, 7392 <onoff_manager_init+0x26>
	    || (transitions->start == NULL)
    7372:	680a      	ldr	r2, [r1, #0]
    7374:	b182      	cbz	r2, 7398 <onoff_manager_init+0x2c>
	    || (transitions->stop == NULL)) {
    7376:	684a      	ldr	r2, [r1, #4]
    7378:	b18a      	cbz	r2, 739e <onoff_manager_init+0x32>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    737a:	2000      	movs	r0, #0
    737c:	6018      	str	r0, [r3, #0]
    737e:	6058      	str	r0, [r3, #4]
    7380:	6098      	str	r0, [r3, #8]
    7382:	60d8      	str	r0, [r3, #12]
    7384:	6158      	str	r0, [r3, #20]
    7386:	6198      	str	r0, [r3, #24]
    7388:	6119      	str	r1, [r3, #16]
	return 0;
    738a:	4770      	bx	lr
		return -EINVAL;
    738c:	f06f 0015 	mvn.w	r0, #21
    7390:	4770      	bx	lr
    7392:	f06f 0015 	mvn.w	r0, #21
    7396:	4770      	bx	lr
    7398:	f06f 0015 	mvn.w	r0, #21
    739c:	4770      	bx	lr
    739e:	f06f 0015 	mvn.w	r0, #21
}
    73a2:	4770      	bx	lr

000073a4 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
    73a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    73a6:	4604      	mov	r4, r0
    73a8:	460f      	mov	r7, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
    73aa:	f7ff ff91 	bl	72d0 <validate_args>

	if (rv < 0) {
    73ae:	1e06      	subs	r6, r0, #0
    73b0:	db37      	blt.n	7422 <onoff_request+0x7e>
    73b2:	f04f 0320 	mov.w	r3, #32
    73b6:	f3ef 8211 	mrs	r2, BASEPRI
    73ba:	f383 8812 	msr	BASEPRI_MAX, r3
    73be:	f3bf 8f6f 	isb	sy
		return rv;
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    73c2:	8b25      	ldrh	r5, [r4, #24]
    73c4:	f005 0507 	and.w	r5, r5, #7

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
    73c8:	8b63      	ldrh	r3, [r4, #26]
    73ca:	f64f 71ff 	movw	r1, #65535	; 0xffff
    73ce:	428b      	cmp	r3, r1
    73d0:	d02f      	beq.n	7432 <onoff_request+0x8e>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
    73d2:	462e      	mov	r6, r5
	if (state == ONOFF_STATE_ON) {
    73d4:	2d02      	cmp	r5, #2
    73d6:	d00c      	beq.n	73f2 <onoff_request+0x4e>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
	} else if ((state == ONOFF_STATE_OFF)
    73d8:	b18d      	cbz	r5, 73fe <onoff_request+0x5a>
		   || (state == ONOFF_STATE_TO_OFF)
    73da:	2d04      	cmp	r5, #4
    73dc:	d00f      	beq.n	73fe <onoff_request+0x5a>
		   || (state == ONOFF_STATE_TO_ON)) {
    73de:	2d06      	cmp	r5, #6
    73e0:	d00d      	beq.n	73fe <onoff_request+0x5a>
		/* Start if OFF, queue client */
		start = (state == ONOFF_STATE_OFF);
		add_client = true;
	} else if (state == ONOFF_STATE_RESETTING) {
    73e2:	2d05      	cmp	r5, #5
    73e4:	d01f      	beq.n	7426 <onoff_request+0x82>
		rv = -ENOTSUP;
	} else {
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
		rv = -EIO;
    73e6:	f06f 0604 	mvn.w	r6, #4
	bool notify = false;            /* do client notification */
    73ea:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
    73ec:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
    73ee:	4608      	mov	r0, r1
    73f0:	e00a      	b.n	7408 <onoff_request+0x64>
		mgr->refs += 1U;
    73f2:	3301      	adds	r3, #1
    73f4:	8363      	strh	r3, [r4, #26]
		notify = true;
    73f6:	2101      	movs	r1, #1
	bool start = false;             /* trigger a start transition */
    73f8:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
    73fa:	4618      	mov	r0, r3
    73fc:	e004      	b.n	7408 <onoff_request+0x64>
		start = (state == ONOFF_STATE_OFF);
    73fe:	fab5 f385 	clz	r3, r5
    7402:	095b      	lsrs	r3, r3, #5
	bool notify = false;            /* do client notification */
    7404:	2100      	movs	r1, #0
		add_client = true;
    7406:	2001      	movs	r0, #1
	}

out:
	if (add_client) {
    7408:	b128      	cbz	r0, 7416 <onoff_request+0x72>
	parent->next = child;
    740a:	2000      	movs	r0, #0
    740c:	6038      	str	r0, [r7, #0]
	return list->tail;
    740e:	6860      	ldr	r0, [r4, #4]
Z_GENLIST_APPEND(slist, snode)
    7410:	b1a8      	cbz	r0, 743e <onoff_request+0x9a>
	parent->next = child;
    7412:	6007      	str	r7, [r0, #0]
	list->tail = node;
    7414:	6067      	str	r7, [r4, #4]
		sys_slist_append(&mgr->clients, &cli->node);
	}

	if (start) {
    7416:	b9ab      	cbnz	r3, 7444 <onoff_request+0xa0>
	__asm__ volatile(
    7418:	f382 8811 	msr	BASEPRI, r2
    741c:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
    7420:	b9a9      	cbnz	r1, 744e <onoff_request+0xaa>
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
    7422:	4630      	mov	r0, r6
    7424:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		rv = -ENOTSUP;
    7426:	f06f 0685 	mvn.w	r6, #133	; 0x85
	bool notify = false;            /* do client notification */
    742a:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
    742c:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
    742e:	4608      	mov	r0, r1
    7430:	e7ea      	b.n	7408 <onoff_request+0x64>
		rv = -EAGAIN;
    7432:	f06f 060a 	mvn.w	r6, #10
	bool notify = false;            /* do client notification */
    7436:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
    7438:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
    743a:	4608      	mov	r0, r1
    743c:	e7e4      	b.n	7408 <onoff_request+0x64>
    743e:	6067      	str	r7, [r4, #4]
	list->head = node;
    7440:	6027      	str	r7, [r4, #0]
}
    7442:	e7e8      	b.n	7416 <onoff_request+0x72>
		process_event(mgr, EVT_RECHECK, key);
    7444:	2102      	movs	r1, #2
    7446:	4620      	mov	r0, r4
    7448:	f7f9 fafa 	bl	a40 <process_event>
    744c:	e7e9      	b.n	7422 <onoff_request+0x7e>
			notify_one(mgr, cli, state, 0);
    744e:	2300      	movs	r3, #0
    7450:	462a      	mov	r2, r5
    7452:	4639      	mov	r1, r7
    7454:	4620      	mov	r0, r4
    7456:	f7ff ff51 	bl	72fc <notify_one>
    745a:	e7e2      	b.n	7422 <onoff_request+0x7e>

0000745c <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    745c:	b508      	push	{r3, lr}
    745e:	4604      	mov	r4, r0
    7460:	4608      	mov	r0, r1
    7462:	4611      	mov	r1, r2
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
    7464:	461a      	mov	r2, r3
    7466:	47a0      	blx	r4
	return z_impl_z_current_get();
    7468:	f7ff fac2 	bl	69f0 <z_impl_z_current_get>
	z_impl_k_thread_abort(thread);
    746c:	f7fb feda 	bl	3224 <z_impl_k_thread_abort>

00007470 <extract_decimal>:
{
    7470:	b410      	push	{r4}
    7472:	4604      	mov	r4, r0
	const char *sp = *str;
    7474:	6802      	ldr	r2, [r0, #0]
	size_t val = 0;
    7476:	2000      	movs	r0, #0
	while (isdigit((int)(unsigned char)*sp)) {
    7478:	7813      	ldrb	r3, [r2, #0]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    747a:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    747e:	2909      	cmp	r1, #9
    7480:	d806      	bhi.n	7490 <extract_decimal+0x20>
		val = 10U * val + *sp++ - '0';
    7482:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    7486:	3201      	adds	r2, #1
    7488:	eb03 0040 	add.w	r0, r3, r0, lsl #1
    748c:	3830      	subs	r0, #48	; 0x30
    748e:	e7f3      	b.n	7478 <extract_decimal+0x8>
	*str = sp;
    7490:	6022      	str	r2, [r4, #0]
}
    7492:	bc10      	pop	{r4}
    7494:	4770      	bx	lr

00007496 <encode_uint>:
{
    7496:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    749a:	b083      	sub	sp, #12
    749c:	4604      	mov	r4, r0
    749e:	460d      	mov	r5, r1
    74a0:	9201      	str	r2, [sp, #4]
    74a2:	469a      	mov	sl, r3
    74a4:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	bool upcase = isupper((int)conv->specifier);
    74a8:	78d3      	ldrb	r3, [r2, #3]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    74aa:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
    74ae:	2b6f      	cmp	r3, #111	; 0x6f
    74b0:	d00f      	beq.n	74d2 <encode_uint+0x3c>
    74b2:	d906      	bls.n	74c2 <encode_uint+0x2c>
    74b4:	2b70      	cmp	r3, #112	; 0x70
    74b6:	d00f      	beq.n	74d8 <encode_uint+0x42>
    74b8:	2b78      	cmp	r3, #120	; 0x78
    74ba:	d110      	bne.n	74de <encode_uint+0x48>
		return 16;
    74bc:	f04f 0910 	mov.w	r9, #16
    74c0:	e026      	b.n	7510 <encode_uint+0x7a>
	switch (specifier) {
    74c2:	2b58      	cmp	r3, #88	; 0x58
    74c4:	d002      	beq.n	74cc <encode_uint+0x36>
    74c6:	f04f 090a 	mov.w	r9, #10
    74ca:	e021      	b.n	7510 <encode_uint+0x7a>
		return 16;
    74cc:	f04f 0910 	mov.w	r9, #16
    74d0:	e01e      	b.n	7510 <encode_uint+0x7a>
		return 8;
    74d2:	f04f 0908 	mov.w	r9, #8
    74d6:	e01b      	b.n	7510 <encode_uint+0x7a>
		return 16;
    74d8:	f04f 0910 	mov.w	r9, #16
    74dc:	e018      	b.n	7510 <encode_uint+0x7a>
	switch (specifier) {
    74de:	f04f 090a 	mov.w	r9, #10
	char *bp = bps + (bpe - bps);
    74e2:	e015      	b.n	7510 <encode_uint+0x7a>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    74e4:	f1bb 0f19 	cmp.w	fp, #25
    74e8:	d820      	bhi.n	752c <encode_uint+0x96>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    74ea:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    74ec:	3237      	adds	r2, #55	; 0x37
    74ee:	b2d2      	uxtb	r2, r2
    74f0:	f808 2d01 	strb.w	r2, [r8, #-1]!
		value /= radix;
    74f4:	4632      	mov	r2, r6
    74f6:	463b      	mov	r3, r7
    74f8:	4620      	mov	r0, r4
    74fa:	4629      	mov	r1, r5
    74fc:	f7f8 ffb0 	bl	460 <__aeabi_uldivmod>
	} while ((value != 0) && (bps < bp));
    7500:	42bd      	cmp	r5, r7
    7502:	bf08      	it	eq
    7504:	42b4      	cmpeq	r4, r6
    7506:	d315      	bcc.n	7534 <encode_uint+0x9e>
    7508:	45d0      	cmp	r8, sl
    750a:	d913      	bls.n	7534 <encode_uint+0x9e>
		value /= radix;
    750c:	4604      	mov	r4, r0
    750e:	460d      	mov	r5, r1
		unsigned int lsv = (unsigned int)(value % radix);
    7510:	464e      	mov	r6, r9
    7512:	2700      	movs	r7, #0
    7514:	464a      	mov	r2, r9
    7516:	463b      	mov	r3, r7
    7518:	4620      	mov	r0, r4
    751a:	4629      	mov	r1, r5
    751c:	f7f8 ffa0 	bl	460 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    7520:	2a09      	cmp	r2, #9
    7522:	d8df      	bhi.n	74e4 <encode_uint+0x4e>
    7524:	b2d2      	uxtb	r2, r2
    7526:	3230      	adds	r2, #48	; 0x30
    7528:	b2d2      	uxtb	r2, r2
    752a:	e7e1      	b.n	74f0 <encode_uint+0x5a>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    752c:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    752e:	3257      	adds	r2, #87	; 0x57
    7530:	b2d2      	uxtb	r2, r2
    7532:	e7dd      	b.n	74f0 <encode_uint+0x5a>
	if (conv->flag_hash) {
    7534:	9b01      	ldr	r3, [sp, #4]
    7536:	781b      	ldrb	r3, [r3, #0]
    7538:	f013 0f20 	tst.w	r3, #32
    753c:	d005      	beq.n	754a <encode_uint+0xb4>
		if (radix == 8) {
    753e:	f1b9 0f08 	cmp.w	r9, #8
    7542:	d006      	beq.n	7552 <encode_uint+0xbc>
		} else if (radix == 16) {
    7544:	f1b9 0f10 	cmp.w	r9, #16
    7548:	d009      	beq.n	755e <encode_uint+0xc8>
}
    754a:	4640      	mov	r0, r8
    754c:	b003      	add	sp, #12
    754e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			conv->altform_0 = true;
    7552:	9a01      	ldr	r2, [sp, #4]
    7554:	7893      	ldrb	r3, [r2, #2]
    7556:	f043 0308 	orr.w	r3, r3, #8
    755a:	7093      	strb	r3, [r2, #2]
    755c:	e7f5      	b.n	754a <encode_uint+0xb4>
			conv->altform_0c = true;
    755e:	9a01      	ldr	r2, [sp, #4]
    7560:	7893      	ldrb	r3, [r2, #2]
    7562:	f043 0310 	orr.w	r3, r3, #16
    7566:	7093      	strb	r3, [r2, #2]
    7568:	e7ef      	b.n	754a <encode_uint+0xb4>

0000756a <outs>:
{
    756a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    756e:	4607      	mov	r7, r0
    7570:	460e      	mov	r6, r1
    7572:	4614      	mov	r4, r2
    7574:	4698      	mov	r8, r3
	size_t count = 0;
    7576:	2500      	movs	r5, #0
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    7578:	e006      	b.n	7588 <outs+0x1e>
		int rc = out((int)*sp++, ctx);
    757a:	4631      	mov	r1, r6
    757c:	f814 0b01 	ldrb.w	r0, [r4], #1
    7580:	47b8      	blx	r7
		if (rc < 0) {
    7582:	2800      	cmp	r0, #0
    7584:	db09      	blt.n	759a <outs+0x30>
		++count;
    7586:	3501      	adds	r5, #1
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    7588:	4544      	cmp	r4, r8
    758a:	d3f6      	bcc.n	757a <outs+0x10>
    758c:	f1b8 0f00 	cmp.w	r8, #0
    7590:	d102      	bne.n	7598 <outs+0x2e>
    7592:	7823      	ldrb	r3, [r4, #0]
    7594:	2b00      	cmp	r3, #0
    7596:	d1f0      	bne.n	757a <outs+0x10>
	return (int)count;
    7598:	4628      	mov	r0, r5
}
    759a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000759e <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    759e:	4770      	bx	lr

000075a0 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    75a0:	2300      	movs	r3, #0
    75a2:	6043      	str	r3, [r0, #4]
	list->head = NULL;
    75a4:	6003      	str	r3, [r0, #0]
}
    75a6:	4770      	bx	lr

000075a8 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    75a8:	6803      	ldr	r3, [r0, #0]
    75aa:	b12b      	cbz	r3, 75b8 <log_list_add_tail+0x10>
		list->head = msg;
	} else {
		list->tail->next = msg;
    75ac:	6843      	ldr	r3, [r0, #4]
    75ae:	6019      	str	r1, [r3, #0]
	}

	list->tail = msg;
    75b0:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
    75b2:	2300      	movs	r3, #0
    75b4:	600b      	str	r3, [r1, #0]
}
    75b6:	4770      	bx	lr
		list->head = msg;
    75b8:	6001      	str	r1, [r0, #0]
    75ba:	e7f9      	b.n	75b0 <log_list_add_tail+0x8>

000075bc <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
    75bc:	6800      	ldr	r0, [r0, #0]
    75be:	4770      	bx	lr

000075c0 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
    75c0:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
    75c2:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
    75c4:	b108      	cbz	r0, 75ca <log_list_head_get+0xa>
		list->head = list->head->next;
    75c6:	6802      	ldr	r2, [r0, #0]
    75c8:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
    75ca:	4770      	bx	lr

000075cc <dummy_timestamp>:
}
    75cc:	2000      	movs	r0, #0
    75ce:	4770      	bx	lr

000075d0 <msg_filter_check>:
}
    75d0:	2001      	movs	r0, #1
    75d2:	4770      	bx	lr

000075d4 <default_get_timestamp>:
{
    75d4:	b508      	push	{r3, lr}
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    75d6:	f000 fe71 	bl	82bc <sys_clock_cycle_get_32>
}
    75da:	bd08      	pop	{r3, pc}

000075dc <z_log_get_s_mask>:
{
    75dc:	b470      	push	{r4, r5, r6}
    75de:	4603      	mov	r3, r0
	uint32_t mask = 0U;
    75e0:	2000      	movs	r0, #0
	uint32_t arg = 0U;
    75e2:	4605      	mov	r5, r0
	bool arm = false;
    75e4:	4604      	mov	r4, r0
	while ((curr = *str++) && arg < nargs) {
    75e6:	e001      	b.n	75ec <z_log_get_s_mask+0x10>
			arm = !arm;
    75e8:	f084 0401 	eor.w	r4, r4, #1
	while ((curr = *str++) && arg < nargs) {
    75ec:	f813 2b01 	ldrb.w	r2, [r3], #1
    75f0:	b19a      	cbz	r2, 761a <z_log_get_s_mask+0x3e>
    75f2:	428d      	cmp	r5, r1
    75f4:	d211      	bcs.n	761a <z_log_get_s_mask+0x3e>
		if (curr == '%') {
    75f6:	2a25      	cmp	r2, #37	; 0x25
    75f8:	d0f6      	beq.n	75e8 <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
    75fa:	2c00      	cmp	r4, #0
    75fc:	d0f6      	beq.n	75ec <z_log_get_s_mask+0x10>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    75fe:	f042 0620 	orr.w	r6, r2, #32
    7602:	3e61      	subs	r6, #97	; 0x61
    7604:	2e19      	cmp	r6, #25
    7606:	d8f1      	bhi.n	75ec <z_log_get_s_mask+0x10>
			if (curr == 's') {
    7608:	2a73      	cmp	r2, #115	; 0x73
    760a:	d002      	beq.n	7612 <z_log_get_s_mask+0x36>
			arg++;
    760c:	3501      	adds	r5, #1
			arm = false;
    760e:	2400      	movs	r4, #0
    7610:	e7ec      	b.n	75ec <z_log_get_s_mask+0x10>
				mask |= BIT(arg);
    7612:	2201      	movs	r2, #1
    7614:	40aa      	lsls	r2, r5
    7616:	4310      	orrs	r0, r2
    7618:	e7f8      	b.n	760c <z_log_get_s_mask+0x30>
}
    761a:	bc70      	pop	{r4, r5, r6}
    761c:	4770      	bx	lr

0000761e <z_log_get_tag>:
}
    761e:	2000      	movs	r0, #0
    7620:	4770      	bx	lr

00007622 <block_on_alloc>:
}
    7622:	2000      	movs	r0, #0
    7624:	4770      	bx	lr

00007626 <cont_arg_get>:

static log_arg_t cont_arg_get(struct log_msg *msg, uint32_t arg_idx)
{
	struct log_msg_cont *cont;

	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    7626:	2901      	cmp	r1, #1
    7628:	d906      	bls.n	7638 <cont_arg_get+0x12>
		return msg->payload.ext.data.args[arg_idx];
	}


	cont = msg->payload.ext.next;
    762a:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    762c:	3902      	subs	r1, #2

	while (arg_idx >= ARGS_CONT_MSG) {
    762e:	2906      	cmp	r1, #6
    7630:	d907      	bls.n	7642 <cont_arg_get+0x1c>
		arg_idx -= ARGS_CONT_MSG;
    7632:	3907      	subs	r1, #7
		cont = cont->next;
    7634:	681b      	ldr	r3, [r3, #0]
    7636:	e7fa      	b.n	762e <cont_arg_get+0x8>
		return msg->payload.ext.data.args[arg_idx];
    7638:	3104      	adds	r1, #4
    763a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    763e:	6888      	ldr	r0, [r1, #8]
    7640:	4770      	bx	lr
	}

	return cont->payload.args[arg_idx];
    7642:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    7646:	6848      	ldr	r0, [r1, #4]
}
    7648:	4770      	bx	lr

0000764a <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
    764a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    764e:	461c      	mov	r4, r3
    7650:	f89d 9020 	ldrb.w	r9, [sp, #32]
	uint32_t available_len = msg->hdr.params.hexdump.length;
    7654:	8903      	ldrh	r3, [r0, #8]
    7656:	f3c3 038d 	ubfx	r3, r3, #2, #14
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
    765a:	42a3      	cmp	r3, r4
    765c:	d91f      	bls.n	769e <log_msg_hexdump_data_op+0x54>
    765e:	4688      	mov	r8, r1
		*length = 0;
		return;
	}

	if ((offset + *length) > available_len) {
    7660:	6811      	ldr	r1, [r2, #0]
    7662:	4421      	add	r1, r4
    7664:	4299      	cmp	r1, r3
    7666:	d901      	bls.n	766c <log_msg_hexdump_data_op+0x22>
		*length = available_len - offset;
    7668:	1b19      	subs	r1, r3, r4
    766a:	6011      	str	r1, [r2, #0]
	}

	req_len = *length;
    766c:	6817      	ldr	r7, [r2, #0]

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    766e:	2b0c      	cmp	r3, #12
    7670:	d919      	bls.n	76a6 <log_msg_hexdump_data_op+0x5c>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
		head_data = msg->payload.ext.data.bytes;
    7672:	f100 0c18 	add.w	ip, r0, #24
		cont = msg->payload.ext.next;
    7676:	6946      	ldr	r6, [r0, #20]
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    7678:	2308      	movs	r3, #8
		head_data = msg->payload.single.bytes;
		chunk_len = available_len;

	}

	if (offset < chunk_len) {
    767a:	42a3      	cmp	r3, r4
    767c:	d91e      	bls.n	76bc <log_msg_hexdump_data_op+0x72>
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    767e:	42bb      	cmp	r3, r7
    7680:	bf28      	it	cs
    7682:	463b      	movcs	r3, r7
    7684:	461d      	mov	r5, r3

		if (put_op) {
    7686:	f1b9 0f00 	cmp.w	r9, #0
    768a:	d010      	beq.n	76ae <log_msg_hexdump_data_op+0x64>
			(void)memcpy(&head_data[offset], data, cpy_len);
    768c:	461a      	mov	r2, r3
    768e:	4641      	mov	r1, r8
    7690:	eb0c 0004 	add.w	r0, ip, r4
    7694:	f000 fb78 	bl	7d88 <memcpy>
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
		}

		req_len -= cpy_len;
    7698:	1b7f      	subs	r7, r7, r5
		data += cpy_len;
    769a:	44a8      	add	r8, r5
    769c:	e021      	b.n	76e2 <log_msg_hexdump_data_op+0x98>
		*length = 0;
    769e:	2300      	movs	r3, #0
    76a0:	6013      	str	r3, [r2, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
    76a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		head_data = msg->payload.single.bytes;
    76a6:	f100 0c14 	add.w	ip, r0, #20
	struct log_msg_cont *cont = NULL;
    76aa:	2600      	movs	r6, #0
    76ac:	e7e5      	b.n	767a <log_msg_hexdump_data_op+0x30>
			(void)memcpy(data, &head_data[offset], cpy_len);
    76ae:	461a      	mov	r2, r3
    76b0:	eb0c 0104 	add.w	r1, ip, r4
    76b4:	4640      	mov	r0, r8
    76b6:	f000 fb67 	bl	7d88 <memcpy>
    76ba:	e7ed      	b.n	7698 <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
    76bc:	1ae4      	subs	r4, r4, r3
		if (cont == NULL) {
    76be:	b91e      	cbnz	r6, 76c8 <log_msg_hexdump_data_op+0x7e>
			cont = msg->payload.ext.next;
    76c0:	6946      	ldr	r6, [r0, #20]
    76c2:	e001      	b.n	76c8 <log_msg_hexdump_data_op+0x7e>
			cont = cont->next;
    76c4:	6836      	ldr	r6, [r6, #0]
			offset -= chunk_len;
    76c6:	3c1c      	subs	r4, #28
		while (offset >= chunk_len) {
    76c8:	2c1b      	cmp	r4, #27
    76ca:	d8fb      	bhi.n	76c4 <log_msg_hexdump_data_op+0x7a>
    76cc:	e009      	b.n	76e2 <log_msg_hexdump_data_op+0x98>
			(void)memcpy(data, &cont->payload.bytes[offset],
    76ce:	1931      	adds	r1, r6, r4
    76d0:	462a      	mov	r2, r5
    76d2:	3104      	adds	r1, #4
    76d4:	4640      	mov	r0, r8
    76d6:	f000 fb57 	bl	7d88 <memcpy>
		cont = cont->next;
    76da:	6836      	ldr	r6, [r6, #0]
		req_len -= cpy_len;
    76dc:	1b7f      	subs	r7, r7, r5
		data += cpy_len;
    76de:	44a8      	add	r8, r5
		offset = 0;
    76e0:	2400      	movs	r4, #0
	while ((req_len > 0) && (cont != NULL)) {
    76e2:	2f00      	cmp	r7, #0
    76e4:	d0dd      	beq.n	76a2 <log_msg_hexdump_data_op+0x58>
    76e6:	2e00      	cmp	r6, #0
    76e8:	d0db      	beq.n	76a2 <log_msg_hexdump_data_op+0x58>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    76ea:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    76ee:	42bd      	cmp	r5, r7
    76f0:	bf28      	it	cs
    76f2:	463d      	movcs	r5, r7
		if (put_op) {
    76f4:	f1b9 0f00 	cmp.w	r9, #0
    76f8:	d0e9      	beq.n	76ce <log_msg_hexdump_data_op+0x84>
			(void)memcpy(&cont->payload.bytes[offset],
    76fa:	1930      	adds	r0, r6, r4
    76fc:	462a      	mov	r2, r5
    76fe:	4641      	mov	r1, r8
    7700:	3004      	adds	r0, #4
    7702:	f000 fb41 	bl	7d88 <memcpy>
    7706:	e7e8      	b.n	76da <log_msg_hexdump_data_op+0x90>

00007708 <log_msg_get>:
	atomic_inc(&msg->hdr.ref_cnt);
    7708:	3004      	adds	r0, #4
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    770a:	f3bf 8f5b 	dmb	ish
    770e:	e850 3f00 	ldrex	r3, [r0]
    7712:	3301      	adds	r3, #1
    7714:	e840 3200 	strex	r2, r3, [r0]
    7718:	2a00      	cmp	r2, #0
    771a:	d1f8      	bne.n	770e <log_msg_get+0x6>
    771c:	f3bf 8f5b 	dmb	ish
}
    7720:	4770      	bx	lr

00007722 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    7722:	7a40      	ldrb	r0, [r0, #9]
}
    7724:	0900      	lsrs	r0, r0, #4
    7726:	4770      	bx	lr

00007728 <log_msg_arg_get>:
{
    7728:	b508      	push	{r3, lr}
	if (arg_idx >= msg->hdr.params.std.nargs) {
    772a:	7a43      	ldrb	r3, [r0, #9]
    772c:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
    7730:	d20a      	bcs.n	7748 <log_msg_arg_get+0x20>
    7732:	091a      	lsrs	r2, r3, #4
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    7734:	2a03      	cmp	r2, #3
    7736:	d804      	bhi.n	7742 <log_msg_arg_get+0x1a>
		arg = msg->payload.single.args[arg_idx];
    7738:	3104      	adds	r1, #4
    773a:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    773e:	6840      	ldr	r0, [r0, #4]
    7740:	e003      	b.n	774a <log_msg_arg_get+0x22>
		arg = cont_arg_get(msg, arg_idx);
    7742:	f7ff ff70 	bl	7626 <cont_arg_get>
    7746:	e000      	b.n	774a <log_msg_arg_get+0x22>
		return 0;
    7748:	2000      	movs	r0, #0
}
    774a:	bd08      	pop	{r3, pc}

0000774c <log_msg_str_get>:
}
    774c:	6900      	ldr	r0, [r0, #16]
    774e:	4770      	bx	lr

00007750 <log_msg_put>:
{
    7750:	b508      	push	{r3, lr}
	atomic_dec(&msg->hdr.ref_cnt);
    7752:	1d03      	adds	r3, r0, #4
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    7754:	f3bf 8f5b 	dmb	ish
    7758:	e853 2f00 	ldrex	r2, [r3]
    775c:	3a01      	subs	r2, #1
    775e:	e843 2100 	strex	r1, r2, [r3]
    7762:	2900      	cmp	r1, #0
    7764:	d1f8      	bne.n	7758 <log_msg_put+0x8>
    7766:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
    776a:	6843      	ldr	r3, [r0, #4]
    776c:	b103      	cbz	r3, 7770 <log_msg_put+0x20>
}
    776e:	bd08      	pop	{r3, pc}
		msg_free(msg);
    7770:	f7fa fb64 	bl	1e3c <msg_free>
}
    7774:	e7fb      	b.n	776e <log_msg_put+0x1e>

00007776 <log_msg_hexdump_create>:
{
    7776:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    777a:	4606      	mov	r6, r0
    777c:	460f      	mov	r7, r1
    777e:	4614      	mov	r4, r2
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
    7780:	f643 75ff 	movw	r5, #16383	; 0x3fff
    7784:	4295      	cmp	r5, r2
    7786:	bf28      	it	cs
    7788:	4615      	movcs	r5, r2
	msg = (struct log_msg *)log_msg_chunk_alloc();
    778a:	f7fa fb3b 	bl	1e04 <log_msg_chunk_alloc>
	if (msg == NULL) {
    778e:	4681      	mov	r9, r0
    7790:	2800      	cmp	r0, #0
    7792:	d045      	beq.n	7820 <log_msg_hexdump_create+0xaa>
	msg->hdr.ref_cnt = 1;
    7794:	2301      	movs	r3, #1
    7796:	6043      	str	r3, [r0, #4]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
    7798:	7a03      	ldrb	r3, [r0, #8]
    779a:	f043 0301 	orr.w	r3, r3, #1
    779e:	7203      	strb	r3, [r0, #8]
	msg->hdr.params.hexdump.length = length;
    77a0:	8903      	ldrh	r3, [r0, #8]
    77a2:	f365 038f 	bfi	r3, r5, #2, #14
    77a6:	8103      	strh	r3, [r0, #8]
	msg->str = str;
    77a8:	6106      	str	r6, [r0, #16]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    77aa:	2c0c      	cmp	r4, #12
    77ac:	d927      	bls.n	77fe <log_msg_hexdump_create+0x88>
		(void)memcpy(msg->payload.ext.data.bytes,
    77ae:	2208      	movs	r2, #8
    77b0:	4639      	mov	r1, r7
    77b2:	3018      	adds	r0, #24
    77b4:	f000 fae8 	bl	7d88 <memcpy>
		msg->payload.ext.next = NULL;
    77b8:	2300      	movs	r3, #0
    77ba:	f8c9 3014 	str.w	r3, [r9, #20]
		msg->hdr.params.generic.ext = 1;
    77be:	f899 3008 	ldrb.w	r3, [r9, #8]
    77c2:	f043 0302 	orr.w	r3, r3, #2
    77c6:	f889 3008 	strb.w	r3, [r9, #8]
		data += LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    77ca:	3708      	adds	r7, #8
		length -= LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    77cc:	3d08      	subs	r5, #8
	prev_cont = &msg->payload.ext.next;
    77ce:	f109 0814 	add.w	r8, r9, #20
	while (length > 0) {
    77d2:	b32d      	cbz	r5, 7820 <log_msg_hexdump_create+0xaa>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
    77d4:	f7fa fb16 	bl	1e04 <log_msg_chunk_alloc>
		if (cont == NULL) {
    77d8:	4604      	mov	r4, r0
    77da:	b1e8      	cbz	r0, 7818 <log_msg_hexdump_create+0xa2>
		*prev_cont = cont;
    77dc:	f8c8 0000 	str.w	r0, [r8]
		cont->next = NULL;
    77e0:	2300      	movs	r3, #0
    77e2:	6003      	str	r3, [r0, #0]
		prev_cont = &cont->next;
    77e4:	4680      	mov	r8, r0
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
    77e6:	462e      	mov	r6, r5
    77e8:	2d1c      	cmp	r5, #28
    77ea:	bf28      	it	cs
    77ec:	261c      	movcs	r6, #28
		(void)memcpy(cont->payload.bytes, data, chunk_length);
    77ee:	4632      	mov	r2, r6
    77f0:	4639      	mov	r1, r7
    77f2:	3004      	adds	r0, #4
    77f4:	f000 fac8 	bl	7d88 <memcpy>
		data += chunk_length;
    77f8:	4437      	add	r7, r6
		length -= chunk_length;
    77fa:	1bad      	subs	r5, r5, r6
    77fc:	e7e9      	b.n	77d2 <log_msg_hexdump_create+0x5c>
		(void)memcpy(msg->payload.single.bytes, data, length);
    77fe:	462a      	mov	r2, r5
    7800:	4639      	mov	r1, r7
    7802:	3014      	adds	r0, #20
    7804:	f000 fac0 	bl	7d88 <memcpy>
		msg->hdr.params.generic.ext = 0;
    7808:	f899 3008 	ldrb.w	r3, [r9, #8]
    780c:	f36f 0341 	bfc	r3, #1, #1
    7810:	f889 3008 	strb.w	r3, [r9, #8]
		length = 0U;
    7814:	2500      	movs	r5, #0
    7816:	e7da      	b.n	77ce <log_msg_hexdump_create+0x58>
			msg_free(msg);
    7818:	4648      	mov	r0, r9
    781a:	f7fa fb0f 	bl	1e3c <msg_free>
			return NULL;
    781e:	46a1      	mov	r9, r4
}
    7820:	4648      	mov	r0, r9
    7822:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00007826 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
    7826:	b510      	push	{r4, lr}
    7828:	b082      	sub	sp, #8
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    782a:	2400      	movs	r4, #0
    782c:	9400      	str	r4, [sp, #0]
    782e:	f7ff ff0c 	bl	764a <log_msg_hexdump_data_op>
}
    7832:	b002      	add	sp, #8
    7834:	bd10      	pop	{r4, pc}

00007836 <buffer_write>:
{
    7836:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7838:	4607      	mov	r7, r0
    783a:	460d      	mov	r5, r1
    783c:	4614      	mov	r4, r2
    783e:	461e      	mov	r6, r3
		processed = outf(buf, len, ctx);
    7840:	4632      	mov	r2, r6
    7842:	4621      	mov	r1, r4
    7844:	4628      	mov	r0, r5
    7846:	47b8      	blx	r7
		buf += processed;
    7848:	4405      	add	r5, r0
	} while (len != 0);
    784a:	1a24      	subs	r4, r4, r0
    784c:	d1f8      	bne.n	7840 <buffer_write+0xa>
}
    784e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00007850 <color_prefix>:
{
    7850:	b508      	push	{r3, lr}
    7852:	4613      	mov	r3, r2
	color_print(output, color, true, level);
    7854:	2201      	movs	r2, #1
    7856:	f7fa fb89 	bl	1f6c <color_print>
}
    785a:	bd08      	pop	{r3, pc}

0000785c <color_postfix>:
{
    785c:	b508      	push	{r3, lr}
    785e:	4613      	mov	r3, r2
	color_print(output, color, false, level);
    7860:	2200      	movs	r2, #0
    7862:	f7fa fb83 	bl	1f6c <color_print>
}
    7866:	bd08      	pop	{r3, pc}

00007868 <postfix_print>:
{
    7868:	b538      	push	{r3, r4, r5, lr}
    786a:	4605      	mov	r5, r0
    786c:	460c      	mov	r4, r1
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
    786e:	f001 0101 	and.w	r1, r1, #1
    7872:	f7ff fff3 	bl	785c <color_postfix>
	newline_print(output, flags);
    7876:	4621      	mov	r1, r4
    7878:	4628      	mov	r0, r5
    787a:	f7fa fb8d 	bl	1f98 <newline_print>
}
    787e:	bd38      	pop	{r3, r4, r5, pc}

00007880 <std_print>:
{
    7880:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7884:	b08e      	sub	sp, #56	; 0x38
    7886:	af0e      	add	r7, sp, #56	; 0x38
    7888:	4606      	mov	r6, r0
    788a:	4689      	mov	r9, r1
	const char *str = log_msg_str_get(msg);
    788c:	f7ff ff5e 	bl	774c <log_msg_str_get>
    7890:	4682      	mov	sl, r0
	uint32_t nargs = log_msg_nargs_get(msg);
    7892:	4630      	mov	r0, r6
    7894:	f7ff ff45 	bl	7722 <log_msg_nargs_get>
    7898:	4680      	mov	r8, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
    789a:	0083      	lsls	r3, r0, #2
    789c:	3307      	adds	r3, #7
    789e:	f023 0307 	bic.w	r3, r3, #7
    78a2:	ebad 0d03 	sub.w	sp, sp, r3
    78a6:	ad0e      	add	r5, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
    78a8:	2400      	movs	r4, #0
    78aa:	4544      	cmp	r4, r8
    78ac:	d207      	bcs.n	78be <std_print+0x3e>
		args[i] = log_msg_arg_get(msg, i);
    78ae:	4621      	mov	r1, r4
    78b0:	4630      	mov	r0, r6
    78b2:	f7ff ff39 	bl	7728 <log_msg_arg_get>
    78b6:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
	for (i = 0; i < nargs; i++) {
    78ba:	3401      	adds	r4, #1
    78bc:	e7f5      	b.n	78aa <std_print+0x2a>
	switch (log_msg_nargs_get(msg)) {
    78be:	4630      	mov	r0, r6
    78c0:	f7ff ff2f 	bl	7722 <log_msg_nargs_get>
    78c4:	280f      	cmp	r0, #15
    78c6:	d815      	bhi.n	78f4 <std_print+0x74>
    78c8:	e8df f010 	tbh	[pc, r0, lsl #1]
    78cc:	00170010 	.word	0x00170010
    78d0:	0024001d 	.word	0x0024001d
    78d4:	0038002d 	.word	0x0038002d
    78d8:	00540045 	.word	0x00540045
    78dc:	00780065 	.word	0x00780065
    78e0:	00a4008d 	.word	0x00a4008d
    78e4:	00d800bd 	.word	0x00d800bd
    78e8:	011400f5 	.word	0x011400f5
		print_formatted(output, str);
    78ec:	4651      	mov	r1, sl
    78ee:	4648      	mov	r0, r9
    78f0:	f7fa fae4 	bl	1ebc <print_formatted>
}
    78f4:	46bd      	mov	sp, r7
    78f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
    78fa:	682a      	ldr	r2, [r5, #0]
    78fc:	4651      	mov	r1, sl
    78fe:	4648      	mov	r0, r9
    7900:	f7fa fadc 	bl	1ebc <print_formatted>
		break;
    7904:	e7f6      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1]);
    7906:	686b      	ldr	r3, [r5, #4]
    7908:	682a      	ldr	r2, [r5, #0]
    790a:	4651      	mov	r1, sl
    790c:	4648      	mov	r0, r9
    790e:	f7fa fad5 	bl	1ebc <print_formatted>
		break;
    7912:	e7ef      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2]);
    7914:	686b      	ldr	r3, [r5, #4]
    7916:	682a      	ldr	r2, [r5, #0]
    7918:	68a9      	ldr	r1, [r5, #8]
    791a:	9100      	str	r1, [sp, #0]
    791c:	4651      	mov	r1, sl
    791e:	4648      	mov	r0, r9
    7920:	f7fa facc 	bl	1ebc <print_formatted>
		break;
    7924:	e7e6      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7926:	686b      	ldr	r3, [r5, #4]
    7928:	682a      	ldr	r2, [r5, #0]
    792a:	68e9      	ldr	r1, [r5, #12]
    792c:	9101      	str	r1, [sp, #4]
    792e:	68a9      	ldr	r1, [r5, #8]
    7930:	9100      	str	r1, [sp, #0]
    7932:	4651      	mov	r1, sl
    7934:	4648      	mov	r0, r9
    7936:	f7fa fac1 	bl	1ebc <print_formatted>
		break;
    793a:	e7db      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    793c:	686b      	ldr	r3, [r5, #4]
    793e:	682a      	ldr	r2, [r5, #0]
    7940:	6929      	ldr	r1, [r5, #16]
    7942:	9102      	str	r1, [sp, #8]
    7944:	68e9      	ldr	r1, [r5, #12]
    7946:	9101      	str	r1, [sp, #4]
    7948:	68a9      	ldr	r1, [r5, #8]
    794a:	9100      	str	r1, [sp, #0]
    794c:	4651      	mov	r1, sl
    794e:	4648      	mov	r0, r9
    7950:	f7fa fab4 	bl	1ebc <print_formatted>
		break;
    7954:	e7ce      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7956:	686b      	ldr	r3, [r5, #4]
    7958:	682a      	ldr	r2, [r5, #0]
    795a:	6969      	ldr	r1, [r5, #20]
    795c:	9103      	str	r1, [sp, #12]
    795e:	6929      	ldr	r1, [r5, #16]
    7960:	9102      	str	r1, [sp, #8]
    7962:	68e9      	ldr	r1, [r5, #12]
    7964:	9101      	str	r1, [sp, #4]
    7966:	68a9      	ldr	r1, [r5, #8]
    7968:	9100      	str	r1, [sp, #0]
    796a:	4651      	mov	r1, sl
    796c:	4648      	mov	r0, r9
    796e:	f7fa faa5 	bl	1ebc <print_formatted>
		break;
    7972:	e7bf      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7974:	686b      	ldr	r3, [r5, #4]
    7976:	682a      	ldr	r2, [r5, #0]
    7978:	69a9      	ldr	r1, [r5, #24]
    797a:	9104      	str	r1, [sp, #16]
    797c:	6969      	ldr	r1, [r5, #20]
    797e:	9103      	str	r1, [sp, #12]
    7980:	6929      	ldr	r1, [r5, #16]
    7982:	9102      	str	r1, [sp, #8]
    7984:	68e9      	ldr	r1, [r5, #12]
    7986:	9101      	str	r1, [sp, #4]
    7988:	68a9      	ldr	r1, [r5, #8]
    798a:	9100      	str	r1, [sp, #0]
    798c:	4651      	mov	r1, sl
    798e:	4648      	mov	r0, r9
    7990:	f7fa fa94 	bl	1ebc <print_formatted>
		break;
    7994:	e7ae      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7996:	686b      	ldr	r3, [r5, #4]
    7998:	682a      	ldr	r2, [r5, #0]
    799a:	69e9      	ldr	r1, [r5, #28]
    799c:	9105      	str	r1, [sp, #20]
    799e:	69a9      	ldr	r1, [r5, #24]
    79a0:	9104      	str	r1, [sp, #16]
    79a2:	6969      	ldr	r1, [r5, #20]
    79a4:	9103      	str	r1, [sp, #12]
    79a6:	6929      	ldr	r1, [r5, #16]
    79a8:	9102      	str	r1, [sp, #8]
    79aa:	68e9      	ldr	r1, [r5, #12]
    79ac:	9101      	str	r1, [sp, #4]
    79ae:	68a9      	ldr	r1, [r5, #8]
    79b0:	9100      	str	r1, [sp, #0]
    79b2:	4651      	mov	r1, sl
    79b4:	4648      	mov	r0, r9
    79b6:	f7fa fa81 	bl	1ebc <print_formatted>
		break;
    79ba:	e79b      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    79bc:	686b      	ldr	r3, [r5, #4]
    79be:	682a      	ldr	r2, [r5, #0]
    79c0:	6a29      	ldr	r1, [r5, #32]
    79c2:	9106      	str	r1, [sp, #24]
    79c4:	69e9      	ldr	r1, [r5, #28]
    79c6:	9105      	str	r1, [sp, #20]
    79c8:	69a9      	ldr	r1, [r5, #24]
    79ca:	9104      	str	r1, [sp, #16]
    79cc:	6969      	ldr	r1, [r5, #20]
    79ce:	9103      	str	r1, [sp, #12]
    79d0:	6929      	ldr	r1, [r5, #16]
    79d2:	9102      	str	r1, [sp, #8]
    79d4:	68e9      	ldr	r1, [r5, #12]
    79d6:	9101      	str	r1, [sp, #4]
    79d8:	68a9      	ldr	r1, [r5, #8]
    79da:	9100      	str	r1, [sp, #0]
    79dc:	4651      	mov	r1, sl
    79de:	4648      	mov	r0, r9
    79e0:	f7fa fa6c 	bl	1ebc <print_formatted>
		break;
    79e4:	e786      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    79e6:	686b      	ldr	r3, [r5, #4]
    79e8:	682a      	ldr	r2, [r5, #0]
    79ea:	6a69      	ldr	r1, [r5, #36]	; 0x24
    79ec:	9107      	str	r1, [sp, #28]
    79ee:	6a29      	ldr	r1, [r5, #32]
    79f0:	9106      	str	r1, [sp, #24]
    79f2:	69e9      	ldr	r1, [r5, #28]
    79f4:	9105      	str	r1, [sp, #20]
    79f6:	69a9      	ldr	r1, [r5, #24]
    79f8:	9104      	str	r1, [sp, #16]
    79fa:	6969      	ldr	r1, [r5, #20]
    79fc:	9103      	str	r1, [sp, #12]
    79fe:	6929      	ldr	r1, [r5, #16]
    7a00:	9102      	str	r1, [sp, #8]
    7a02:	68e9      	ldr	r1, [r5, #12]
    7a04:	9101      	str	r1, [sp, #4]
    7a06:	68a9      	ldr	r1, [r5, #8]
    7a08:	9100      	str	r1, [sp, #0]
    7a0a:	4651      	mov	r1, sl
    7a0c:	4648      	mov	r0, r9
    7a0e:	f7fa fa55 	bl	1ebc <print_formatted>
		break;
    7a12:	e76f      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7a14:	686b      	ldr	r3, [r5, #4]
    7a16:	682a      	ldr	r2, [r5, #0]
    7a18:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    7a1a:	9108      	str	r1, [sp, #32]
    7a1c:	6a69      	ldr	r1, [r5, #36]	; 0x24
    7a1e:	9107      	str	r1, [sp, #28]
    7a20:	6a29      	ldr	r1, [r5, #32]
    7a22:	9106      	str	r1, [sp, #24]
    7a24:	69e9      	ldr	r1, [r5, #28]
    7a26:	9105      	str	r1, [sp, #20]
    7a28:	69a9      	ldr	r1, [r5, #24]
    7a2a:	9104      	str	r1, [sp, #16]
    7a2c:	6969      	ldr	r1, [r5, #20]
    7a2e:	9103      	str	r1, [sp, #12]
    7a30:	6929      	ldr	r1, [r5, #16]
    7a32:	9102      	str	r1, [sp, #8]
    7a34:	68e9      	ldr	r1, [r5, #12]
    7a36:	9101      	str	r1, [sp, #4]
    7a38:	68a9      	ldr	r1, [r5, #8]
    7a3a:	9100      	str	r1, [sp, #0]
    7a3c:	4651      	mov	r1, sl
    7a3e:	4648      	mov	r0, r9
    7a40:	f7fa fa3c 	bl	1ebc <print_formatted>
		break;
    7a44:	e756      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7a46:	686b      	ldr	r3, [r5, #4]
    7a48:	682a      	ldr	r2, [r5, #0]
    7a4a:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    7a4c:	9109      	str	r1, [sp, #36]	; 0x24
    7a4e:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    7a50:	9108      	str	r1, [sp, #32]
    7a52:	6a69      	ldr	r1, [r5, #36]	; 0x24
    7a54:	9107      	str	r1, [sp, #28]
    7a56:	6a29      	ldr	r1, [r5, #32]
    7a58:	9106      	str	r1, [sp, #24]
    7a5a:	69e9      	ldr	r1, [r5, #28]
    7a5c:	9105      	str	r1, [sp, #20]
    7a5e:	69a9      	ldr	r1, [r5, #24]
    7a60:	9104      	str	r1, [sp, #16]
    7a62:	6969      	ldr	r1, [r5, #20]
    7a64:	9103      	str	r1, [sp, #12]
    7a66:	6929      	ldr	r1, [r5, #16]
    7a68:	9102      	str	r1, [sp, #8]
    7a6a:	68e9      	ldr	r1, [r5, #12]
    7a6c:	9101      	str	r1, [sp, #4]
    7a6e:	68a9      	ldr	r1, [r5, #8]
    7a70:	9100      	str	r1, [sp, #0]
    7a72:	4651      	mov	r1, sl
    7a74:	4648      	mov	r0, r9
    7a76:	f7fa fa21 	bl	1ebc <print_formatted>
		break;
    7a7a:	e73b      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7a7c:	686b      	ldr	r3, [r5, #4]
    7a7e:	682a      	ldr	r2, [r5, #0]
    7a80:	6b29      	ldr	r1, [r5, #48]	; 0x30
    7a82:	910a      	str	r1, [sp, #40]	; 0x28
    7a84:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    7a86:	9109      	str	r1, [sp, #36]	; 0x24
    7a88:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    7a8a:	9108      	str	r1, [sp, #32]
    7a8c:	6a69      	ldr	r1, [r5, #36]	; 0x24
    7a8e:	9107      	str	r1, [sp, #28]
    7a90:	6a29      	ldr	r1, [r5, #32]
    7a92:	9106      	str	r1, [sp, #24]
    7a94:	69e9      	ldr	r1, [r5, #28]
    7a96:	9105      	str	r1, [sp, #20]
    7a98:	69a9      	ldr	r1, [r5, #24]
    7a9a:	9104      	str	r1, [sp, #16]
    7a9c:	6969      	ldr	r1, [r5, #20]
    7a9e:	9103      	str	r1, [sp, #12]
    7aa0:	6929      	ldr	r1, [r5, #16]
    7aa2:	9102      	str	r1, [sp, #8]
    7aa4:	68e9      	ldr	r1, [r5, #12]
    7aa6:	9101      	str	r1, [sp, #4]
    7aa8:	68a9      	ldr	r1, [r5, #8]
    7aaa:	9100      	str	r1, [sp, #0]
    7aac:	4651      	mov	r1, sl
    7aae:	4648      	mov	r0, r9
    7ab0:	f7fa fa04 	bl	1ebc <print_formatted>
		break;
    7ab4:	e71e      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7ab6:	686b      	ldr	r3, [r5, #4]
    7ab8:	682a      	ldr	r2, [r5, #0]
    7aba:	6b69      	ldr	r1, [r5, #52]	; 0x34
    7abc:	910b      	str	r1, [sp, #44]	; 0x2c
    7abe:	6b29      	ldr	r1, [r5, #48]	; 0x30
    7ac0:	910a      	str	r1, [sp, #40]	; 0x28
    7ac2:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    7ac4:	9109      	str	r1, [sp, #36]	; 0x24
    7ac6:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    7ac8:	9108      	str	r1, [sp, #32]
    7aca:	6a69      	ldr	r1, [r5, #36]	; 0x24
    7acc:	9107      	str	r1, [sp, #28]
    7ace:	6a29      	ldr	r1, [r5, #32]
    7ad0:	9106      	str	r1, [sp, #24]
    7ad2:	69e9      	ldr	r1, [r5, #28]
    7ad4:	9105      	str	r1, [sp, #20]
    7ad6:	69a9      	ldr	r1, [r5, #24]
    7ad8:	9104      	str	r1, [sp, #16]
    7ada:	6969      	ldr	r1, [r5, #20]
    7adc:	9103      	str	r1, [sp, #12]
    7ade:	6929      	ldr	r1, [r5, #16]
    7ae0:	9102      	str	r1, [sp, #8]
    7ae2:	68e9      	ldr	r1, [r5, #12]
    7ae4:	9101      	str	r1, [sp, #4]
    7ae6:	68a9      	ldr	r1, [r5, #8]
    7ae8:	9100      	str	r1, [sp, #0]
    7aea:	4651      	mov	r1, sl
    7aec:	4648      	mov	r0, r9
    7aee:	f7fa f9e5 	bl	1ebc <print_formatted>
		break;
    7af2:	e6ff      	b.n	78f4 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    7af4:	686b      	ldr	r3, [r5, #4]
    7af6:	682a      	ldr	r2, [r5, #0]
    7af8:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    7afa:	910c      	str	r1, [sp, #48]	; 0x30
    7afc:	6b69      	ldr	r1, [r5, #52]	; 0x34
    7afe:	910b      	str	r1, [sp, #44]	; 0x2c
    7b00:	6b29      	ldr	r1, [r5, #48]	; 0x30
    7b02:	910a      	str	r1, [sp, #40]	; 0x28
    7b04:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    7b06:	9109      	str	r1, [sp, #36]	; 0x24
    7b08:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    7b0a:	9108      	str	r1, [sp, #32]
    7b0c:	6a69      	ldr	r1, [r5, #36]	; 0x24
    7b0e:	9107      	str	r1, [sp, #28]
    7b10:	6a29      	ldr	r1, [r5, #32]
    7b12:	9106      	str	r1, [sp, #24]
    7b14:	69e9      	ldr	r1, [r5, #28]
    7b16:	9105      	str	r1, [sp, #20]
    7b18:	69a9      	ldr	r1, [r5, #24]
    7b1a:	9104      	str	r1, [sp, #16]
    7b1c:	6969      	ldr	r1, [r5, #20]
    7b1e:	9103      	str	r1, [sp, #12]
    7b20:	6929      	ldr	r1, [r5, #16]
    7b22:	9102      	str	r1, [sp, #8]
    7b24:	68e9      	ldr	r1, [r5, #12]
    7b26:	9101      	str	r1, [sp, #4]
    7b28:	68a9      	ldr	r1, [r5, #8]
    7b2a:	9100      	str	r1, [sp, #0]
    7b2c:	4651      	mov	r1, sl
    7b2e:	4648      	mov	r0, r9
    7b30:	f7fa f9c4 	bl	1ebc <print_formatted>
}
    7b34:	e6de      	b.n	78f4 <std_print+0x74>

00007b36 <log_output_flush>:
{
    7b36:	b510      	push	{r4, lr}
    7b38:	4604      	mov	r4, r0
		     output->control_block->offset,
    7b3a:	6842      	ldr	r2, [r0, #4]
	buffer_write(output->func, output->buf,
    7b3c:	6853      	ldr	r3, [r2, #4]
    7b3e:	6812      	ldr	r2, [r2, #0]
    7b40:	6881      	ldr	r1, [r0, #8]
    7b42:	6800      	ldr	r0, [r0, #0]
    7b44:	f7ff fe77 	bl	7836 <buffer_write>
	output->control_block->offset = 0;
    7b48:	6863      	ldr	r3, [r4, #4]
    7b4a:	2200      	movs	r2, #0
    7b4c:	601a      	str	r2, [r3, #0]
}
    7b4e:	bd10      	pop	{r4, pc}

00007b50 <out_func>:
{
    7b50:	b538      	push	{r3, r4, r5, lr}
    7b52:	4605      	mov	r5, r0
    7b54:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
    7b56:	684b      	ldr	r3, [r1, #4]
    7b58:	681a      	ldr	r2, [r3, #0]
    7b5a:	68cb      	ldr	r3, [r1, #12]
    7b5c:	429a      	cmp	r2, r3
    7b5e:	d00f      	beq.n	7b80 <out_func+0x30>
	idx = atomic_inc(&out_ctx->control_block->offset);
    7b60:	6863      	ldr	r3, [r4, #4]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    7b62:	f3bf 8f5b 	dmb	ish
    7b66:	e853 2f00 	ldrex	r2, [r3]
    7b6a:	1c51      	adds	r1, r2, #1
    7b6c:	e843 1000 	strex	r0, r1, [r3]
    7b70:	2800      	cmp	r0, #0
    7b72:	d1f8      	bne.n	7b66 <out_func+0x16>
    7b74:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (uint8_t)c;
    7b78:	68a3      	ldr	r3, [r4, #8]
    7b7a:	549d      	strb	r5, [r3, r2]
}
    7b7c:	2000      	movs	r0, #0
    7b7e:	bd38      	pop	{r3, r4, r5, pc}
		log_output_flush(out_ctx);
    7b80:	4608      	mov	r0, r1
    7b82:	f7ff ffd8 	bl	7b36 <log_output_flush>
    7b86:	e7eb      	b.n	7b60 <out_func+0x10>

00007b88 <log_output_msg_process>:
{
    7b88:	b5f0      	push	{r4, r5, r6, r7, lr}
    7b8a:	b085      	sub	sp, #20
    7b8c:	4606      	mov	r6, r0
    7b8e:	460c      	mov	r4, r1
    7b90:	4617      	mov	r7, r2
    7b92:	7a0b      	ldrb	r3, [r1, #8]
    7b94:	f083 0301 	eor.w	r3, r3, #1
    7b98:	f003 0201 	and.w	r2, r3, #1
	return msg->hdr.timestamp;
    7b9c:	68cb      	ldr	r3, [r1, #12]
	return msg->hdr.ids.level;
    7b9e:	7a89      	ldrb	r1, [r1, #10]
	return msg->hdr.ids.domain_id;
    7ba0:	f3c1 0cc2 	ubfx	ip, r1, #3, #3
	return msg->hdr.ids.source_id;
    7ba4:	8960      	ldrh	r0, [r4, #10]
	int16_t source_id = (int16_t)log_msg_source_id_get(msg);
    7ba6:	f3c0 1089 	ubfx	r0, r0, #6, #10
			0 : prefix_print(output, flags, std_msg, timestamp,
    7baa:	f011 0507 	ands.w	r5, r1, #7
    7bae:	d10f      	bne.n	7bd0 <log_output_msg_process+0x48>
    7bb0:	2200      	movs	r2, #0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    7bb2:	7a23      	ldrb	r3, [r4, #8]
	if (log_msg_is_std(msg)) {
    7bb4:	f013 0f01 	tst.w	r3, #1
    7bb8:	d014      	beq.n	7be4 <log_output_msg_process+0x5c>
	} else if (raw_string) {
    7bba:	b9c5      	cbnz	r5, 7bee <log_output_msg_process+0x66>
		raw_string_print(msg, output);
    7bbc:	4631      	mov	r1, r6
    7bbe:	4620      	mov	r0, r4
    7bc0:	f7fa faf8 	bl	21b4 <raw_string_print>
	if (!raw_string) {
    7bc4:	b9cd      	cbnz	r5, 7bfa <log_output_msg_process+0x72>
	log_output_flush(output);
    7bc6:	4630      	mov	r0, r6
    7bc8:	f7ff ffb5 	bl	7b36 <log_output_flush>
}
    7bcc:	b005      	add	sp, #20
    7bce:	bdf0      	pop	{r4, r5, r6, r7, pc}
			0 : prefix_print(output, flags, std_msg, timestamp,
    7bd0:	9002      	str	r0, [sp, #8]
    7bd2:	f8cd c004 	str.w	ip, [sp, #4]
    7bd6:	9500      	str	r5, [sp, #0]
    7bd8:	4639      	mov	r1, r7
    7bda:	4630      	mov	r0, r6
    7bdc:	f7fa fa84 	bl	20e8 <prefix_print>
    7be0:	4602      	mov	r2, r0
    7be2:	e7e6      	b.n	7bb2 <log_output_msg_process+0x2a>
		std_print(msg, output);
    7be4:	4631      	mov	r1, r6
    7be6:	4620      	mov	r0, r4
    7be8:	f7ff fe4a 	bl	7880 <std_print>
    7bec:	e7ea      	b.n	7bc4 <log_output_msg_process+0x3c>
		hexdump_print(msg, output, prefix_offset, flags);
    7bee:	463b      	mov	r3, r7
    7bf0:	4631      	mov	r1, r6
    7bf2:	4620      	mov	r0, r4
    7bf4:	f7fa fab4 	bl	2160 <hexdump_print>
    7bf8:	e7e4      	b.n	7bc4 <log_output_msg_process+0x3c>
		postfix_print(output, flags, level);
    7bfa:	462a      	mov	r2, r5
    7bfc:	4639      	mov	r1, r7
    7bfe:	4630      	mov	r0, r6
    7c00:	f7ff fe32 	bl	7868 <postfix_print>
    7c04:	e7df      	b.n	7bc6 <log_output_msg_process+0x3e>

00007c06 <pm_policy_next_state>:
		}
	}

error:
	LOG_DBG("No suitable power state found for cpu: %d!", cpu);
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
    7c06:	2200      	movs	r2, #0
    7c08:	6002      	str	r2, [r0, #0]
    7c0a:	6042      	str	r2, [r0, #4]
    7c0c:	6082      	str	r2, [r0, #8]
}
    7c0e:	4770      	bx	lr

00007c10 <z_arm_fatal_error>:

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    7c10:	b538      	push	{r3, r4, r5, lr}
    7c12:	4604      	mov	r4, r0

	if (esf != NULL) {
    7c14:	460d      	mov	r5, r1
    7c16:	b111      	cbz	r1, 7c1e <z_arm_fatal_error+0xe>
		esf_dump(esf);
    7c18:	4608      	mov	r0, r1
    7c1a:	f7fa fd1f 	bl	265c <esf_dump>
	}
	z_fatal_error(reason, esf);
    7c1e:	4629      	mov	r1, r5
    7c20:	4620      	mov	r0, r4
    7c22:	f7fd ff53 	bl	5acc <z_fatal_error>
}
    7c26:	bd38      	pop	{r3, r4, r5, pc}

00007c28 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    7c28:	b508      	push	{r3, lr}
    7c2a:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
    7c2c:	6800      	ldr	r0, [r0, #0]
    7c2e:	f7ff ffef 	bl	7c10 <z_arm_fatal_error>

	memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
    7c32:	bd08      	pop	{r3, pc}

00007c34 <z_irq_spurious>:
 * called.
 *
 * @return N/A
 */
void z_irq_spurious(const void *unused)
{
    7c34:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    7c36:	2100      	movs	r1, #0
    7c38:	2001      	movs	r0, #1
    7c3a:	f7ff ffe9 	bl	7c10 <z_arm_fatal_error>
}
    7c3e:	bd08      	pop	{r3, pc}

00007c40 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    7c40:	b508      	push	{r3, lr}
	handler();
    7c42:	f7fa fda1 	bl	2788 <z_SysNmiOnReset>
	z_arm_int_exit();
    7c46:	f7fa fe9d 	bl	2984 <z_arm_exc_exit>
}
    7c4a:	bd08      	pop	{r3, pc}

00007c4c <memory_fault_recoverable>:
}
    7c4c:	2000      	movs	r0, #0
    7c4e:	4770      	bx	lr

00007c50 <fault_handle>:
{
    7c50:	b508      	push	{r3, lr}
	*recoverable = false;
    7c52:	2300      	movs	r3, #0
    7c54:	7013      	strb	r3, [r2, #0]
	switch (fault) {
    7c56:	1ecb      	subs	r3, r1, #3
    7c58:	2b09      	cmp	r3, #9
    7c5a:	d81a      	bhi.n	7c92 <fault_handle+0x42>
    7c5c:	e8df f003 	tbb	[pc, r3]
    7c60:	110d0905 	.word	0x110d0905
    7c64:	19191919 	.word	0x19191919
    7c68:	1419      	.short	0x1419
		reason = hard_fault(esf, recoverable);
    7c6a:	4611      	mov	r1, r2
    7c6c:	f7fb f91e 	bl	2eac <hard_fault>
}
    7c70:	bd08      	pop	{r3, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    7c72:	2100      	movs	r1, #0
    7c74:	f7fb f838 	bl	2ce8 <mem_manage_fault>
		break;
    7c78:	e7fa      	b.n	7c70 <fault_handle+0x20>
		reason = bus_fault(esf, 0, recoverable);
    7c7a:	2100      	movs	r1, #0
    7c7c:	f7fa ff5c 	bl	2b38 <bus_fault>
		break;
    7c80:	e7f6      	b.n	7c70 <fault_handle+0x20>
		reason = usage_fault(esf);
    7c82:	f7fa fe8d 	bl	29a0 <usage_fault>
		break;
    7c86:	e7f3      	b.n	7c70 <fault_handle+0x20>
		debug_monitor(esf, recoverable);
    7c88:	4611      	mov	r1, r2
    7c8a:	f7fa ff3b 	bl	2b04 <debug_monitor>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    7c8e:	2000      	movs	r0, #0
		break;
    7c90:	e7ee      	b.n	7c70 <fault_handle+0x20>
		reserved_exception(esf, fault);
    7c92:	f7fb f9b1 	bl	2ff8 <reserved_exception>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    7c96:	2000      	movs	r0, #0
	return reason;
    7c98:	e7ea      	b.n	7c70 <fault_handle+0x20>

00007c9a <mpu_partition_is_valid>:
		((part->size & (part->size - 1U)) == 0U)
    7c9a:	6843      	ldr	r3, [r0, #4]
    7c9c:	1e5a      	subs	r2, r3, #1
		&&
    7c9e:	4213      	tst	r3, r2
    7ca0:	d106      	bne.n	7cb0 <mpu_partition_is_valid+0x16>
		&&
    7ca2:	2b1f      	cmp	r3, #31
    7ca4:	d906      	bls.n	7cb4 <mpu_partition_is_valid+0x1a>
		((part->start & (part->size - 1U)) == 0U);
    7ca6:	6803      	ldr	r3, [r0, #0]
		&&
    7ca8:	421a      	tst	r2, r3
    7caa:	d005      	beq.n	7cb8 <mpu_partition_is_valid+0x1e>
    7cac:	2000      	movs	r0, #0
    7cae:	4770      	bx	lr
    7cb0:	2000      	movs	r0, #0
    7cb2:	4770      	bx	lr
    7cb4:	2000      	movs	r0, #0
    7cb6:	4770      	bx	lr
    7cb8:	2001      	movs	r0, #1
}
    7cba:	4770      	bx	lr

00007cbc <mpu_configure_region>:
{
    7cbc:	b500      	push	{lr}
    7cbe:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
    7cc0:	680b      	ldr	r3, [r1, #0]
    7cc2:	9301      	str	r3, [sp, #4]
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
    7cc4:	684b      	ldr	r3, [r1, #4]
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    7cc6:	688a      	ldr	r2, [r1, #8]
	if (size <= 32U) {
    7cc8:	2b20      	cmp	r3, #32
    7cca:	d912      	bls.n	7cf2 <mpu_configure_region+0x36>
	if (size > (1UL << 31)) {
    7ccc:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    7cd0:	d811      	bhi.n	7cf6 <mpu_configure_region+0x3a>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    7cd2:	3b01      	subs	r3, #1
    7cd4:	fab3 f383 	clz	r3, r3
    7cd8:	f1c3 031f 	rsb	r3, r3, #31
    7cdc:	005b      	lsls	r3, r3, #1
    7cde:	f003 033e 	and.w	r3, r3, #62	; 0x3e
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    7ce2:	4313      	orrs	r3, r2
    7ce4:	9303      	str	r3, [sp, #12]
	return region_allocate_and_init(index,
    7ce6:	a901      	add	r1, sp, #4
    7ce8:	f7fb fae2 	bl	32b0 <region_allocate_and_init>
}
    7cec:	b005      	add	sp, #20
    7cee:	f85d fb04 	ldr.w	pc, [sp], #4
		return REGION_32B;
    7cf2:	2308      	movs	r3, #8
    7cf4:	e7f5      	b.n	7ce2 <mpu_configure_region+0x26>
		return REGION_4G;
    7cf6:	233e      	movs	r3, #62	; 0x3e
    7cf8:	e7f3      	b.n	7ce2 <mpu_configure_region+0x26>

00007cfa <arm_core_mpu_configure_static_mpu_regions>:
{
    7cfa:	b508      	push	{r3, lr}
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
    7cfc:	f7fb fb3a 	bl	3374 <mpu_configure_static_mpu_regions>
}
    7d00:	bd08      	pop	{r3, pc}

00007d02 <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    7d02:	b508      	push	{r3, lr}
	if (mpu_configure_dynamic_mpu_regions(dynamic_regions, regions_num)
    7d04:	f7fb fb40 	bl	3388 <mpu_configure_dynamic_mpu_regions>
}
    7d08:	bd08      	pop	{r3, pc}

00007d0a <strcpy>:

char *strcpy(char *ZRESTRICT d, const char *ZRESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    7d0a:	4602      	mov	r2, r0
    7d0c:	780b      	ldrb	r3, [r1, #0]
    7d0e:	b11b      	cbz	r3, 7d18 <strcpy+0xe>
		*d = *s;
    7d10:	f802 3b01 	strb.w	r3, [r2], #1
		d++;
		s++;
    7d14:	3101      	adds	r1, #1
    7d16:	e7f9      	b.n	7d0c <strcpy+0x2>
	}

	*d = '\0';
    7d18:	7013      	strb	r3, [r2, #0]

	return dest;
}
    7d1a:	4770      	bx	lr

00007d1c <strncpy>:

char *strncpy(char *ZRESTRICT d, const char *ZRESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    7d1c:	4603      	mov	r3, r0
    7d1e:	b1a2      	cbz	r2, 7d4a <strncpy+0x2e>
{
    7d20:	b410      	push	{r4}
	while ((n > 0) && *s != '\0') {
    7d22:	780c      	ldrb	r4, [r1, #0]
    7d24:	b12c      	cbz	r4, 7d32 <strncpy+0x16>
		*d = *s;
    7d26:	f803 4b01 	strb.w	r4, [r3], #1
		s++;
    7d2a:	3101      	adds	r1, #1
		d++;
		n--;
    7d2c:	3a01      	subs	r2, #1
	while ((n > 0) && *s != '\0') {
    7d2e:	2a00      	cmp	r2, #0
    7d30:	d1f7      	bne.n	7d22 <strncpy+0x6>
	}

	while (n > 0) {
    7d32:	b122      	cbz	r2, 7d3e <strncpy+0x22>
		*d = '\0';
    7d34:	2100      	movs	r1, #0
    7d36:	f803 1b01 	strb.w	r1, [r3], #1
		d++;
		n--;
    7d3a:	3a01      	subs	r2, #1
    7d3c:	e7f9      	b.n	7d32 <strncpy+0x16>
	}

	return dest;
}
    7d3e:	bc10      	pop	{r4}
    7d40:	4770      	bx	lr
		*d = '\0';
    7d42:	2100      	movs	r1, #0
    7d44:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    7d48:	3a01      	subs	r2, #1
	while (n > 0) {
    7d4a:	2a00      	cmp	r2, #0
    7d4c:	d1f9      	bne.n	7d42 <strncpy+0x26>
    7d4e:	4770      	bx	lr

00007d50 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    7d50:	4603      	mov	r3, r0
	size_t n = 0;
    7d52:	2000      	movs	r0, #0

	while (*s != '\0') {
    7d54:	781a      	ldrb	r2, [r3, #0]
    7d56:	b112      	cbz	r2, 7d5e <strlen+0xe>
		s++;
    7d58:	3301      	adds	r3, #1
		n++;
    7d5a:	3001      	adds	r0, #1
    7d5c:	e7fa      	b.n	7d54 <strlen+0x4>
	}

	return n;
}
    7d5e:	4770      	bx	lr

00007d60 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    7d60:	4603      	mov	r3, r0
	size_t n = 0;
    7d62:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    7d64:	781a      	ldrb	r2, [r3, #0]
    7d66:	b122      	cbz	r2, 7d72 <strnlen+0x12>
    7d68:	4288      	cmp	r0, r1
    7d6a:	d202      	bcs.n	7d72 <strnlen+0x12>
		s++;
    7d6c:	3301      	adds	r3, #1
		n++;
    7d6e:	3001      	adds	r0, #1
    7d70:	e7f8      	b.n	7d64 <strnlen+0x4>
	}

	return n;
}
    7d72:	4770      	bx	lr

00007d74 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    7d74:	7803      	ldrb	r3, [r0, #0]
    7d76:	780a      	ldrb	r2, [r1, #0]
    7d78:	4293      	cmp	r3, r2
    7d7a:	d103      	bne.n	7d84 <strcmp+0x10>
    7d7c:	b113      	cbz	r3, 7d84 <strcmp+0x10>
		s1++;
    7d7e:	3001      	adds	r0, #1
		s2++;
    7d80:	3101      	adds	r1, #1
    7d82:	e7f7      	b.n	7d74 <strcmp>
	}

	return *s1 - *s2;
}
    7d84:	1a98      	subs	r0, r3, r2
    7d86:	4770      	bx	lr

00007d88 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
    7d88:	b410      	push	{r4}
	const unsigned char *s_byte = (const unsigned char *)s;

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    7d8a:	ea80 0301 	eor.w	r3, r0, r1
    7d8e:	f013 0f03 	tst.w	r3, #3
    7d92:	d001      	beq.n	7d98 <memcpy+0x10>
	unsigned char *d_byte = (unsigned char *)d;
    7d94:	4603      	mov	r3, r0
    7d96:	e017      	b.n	7dc8 <memcpy+0x40>
    7d98:	4603      	mov	r3, r0

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
    7d9a:	f013 0f03 	tst.w	r3, #3
    7d9e:	d00b      	beq.n	7db8 <memcpy+0x30>
			if (n == 0) {
    7da0:	b1a2      	cbz	r2, 7dcc <memcpy+0x44>
				return d;
			}
			*(d_byte++) = *(s_byte++);
    7da2:	f811 4b01 	ldrb.w	r4, [r1], #1
    7da6:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
    7daa:	3a01      	subs	r2, #1
    7dac:	e7f5      	b.n	7d9a <memcpy+0x12>

		mem_word_t *d_word = (mem_word_t *)d_byte;
		const mem_word_t *s_word = (const mem_word_t *)s_byte;

		while (n >= sizeof(mem_word_t)) {
			*(d_word++) = *(s_word++);
    7dae:	f851 4b04 	ldr.w	r4, [r1], #4
    7db2:	f843 4b04 	str.w	r4, [r3], #4
			n -= sizeof(mem_word_t);
    7db6:	3a04      	subs	r2, #4
		while (n >= sizeof(mem_word_t)) {
    7db8:	2a03      	cmp	r2, #3
    7dba:	d8f8      	bhi.n	7dae <memcpy+0x26>
    7dbc:	e004      	b.n	7dc8 <memcpy+0x40>
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
    7dbe:	f811 4b01 	ldrb.w	r4, [r1], #1
    7dc2:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
    7dc6:	3a01      	subs	r2, #1
	while (n > 0) {
    7dc8:	2a00      	cmp	r2, #0
    7dca:	d1f8      	bne.n	7dbe <memcpy+0x36>
	}

	return d;
}
    7dcc:	bc10      	pop	{r4}
    7dce:	4770      	bx	lr

00007dd0 <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    7dd0:	b410      	push	{r4}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    7dd2:	b2cc      	uxtb	r4, r1
	unsigned char *d_byte = (unsigned char *)buf;
    7dd4:	4603      	mov	r3, r0

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    7dd6:	f013 0f03 	tst.w	r3, #3
    7dda:	d004      	beq.n	7de6 <memset+0x16>
		if (n == 0) {
    7ddc:	b19a      	cbz	r2, 7e06 <memset+0x36>
			return buf;
		}
		*(d_byte++) = c_byte;
    7dde:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
    7de2:	3a01      	subs	r2, #1
    7de4:	e7f7      	b.n	7dd6 <memset+0x6>
	}

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
    7de6:	b2c9      	uxtb	r1, r1

	c_word |= c_word << 8;
    7de8:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
	c_word |= c_word << 16;
    7dec:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    7df0:	2a03      	cmp	r2, #3
    7df2:	d906      	bls.n	7e02 <memset+0x32>
		*(d_word++) = c_word;
    7df4:	f843 1b04 	str.w	r1, [r3], #4
		n -= sizeof(mem_word_t);
    7df8:	3a04      	subs	r2, #4
    7dfa:	e7f9      	b.n	7df0 <memset+0x20>

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
		*(d_byte++) = c_byte;
    7dfc:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
    7e00:	3a01      	subs	r2, #1
	while (n > 0) {
    7e02:	2a00      	cmp	r2, #0
    7e04:	d1fa      	bne.n	7dfc <memset+0x2c>
	}

	return buf;
}
    7e06:	bc10      	pop	{r4}
    7e08:	4770      	bx	lr

00007e0a <_stdout_hook_default>:
}
    7e0a:	f04f 30ff 	mov.w	r0, #4294967295
    7e0e:	4770      	bx	lr

00007e10 <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
    7e10:	b084      	sub	sp, #16
    7e12:	ab04      	add	r3, sp, #16
    7e14:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
    7e18:	f89d 3004 	ldrb.w	r3, [sp, #4]
    7e1c:	2b06      	cmp	r3, #6
    7e1e:	d001      	beq.n	7e24 <pm_power_state_set+0x14>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
    7e20:	b004      	add	sp, #16
    7e22:	4770      	bx	lr
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
    7e24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    7e28:	2201      	movs	r2, #1
    7e2a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
    7e2e:	f3bf 8f4f 	dsb	sy
        __WFE();
    7e32:	bf20      	wfe
    while (true)
    7e34:	e7fd      	b.n	7e32 <pm_power_state_set+0x22>

00007e36 <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
    7e36:	b084      	sub	sp, #16
    7e38:	ab04      	add	r3, sp, #16
    7e3a:	e903 0007 	stmdb	r3, {r0, r1, r2}
    7e3e:	2300      	movs	r3, #0
    7e40:	f383 8811 	msr	BASEPRI, r3
    7e44:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    7e48:	b004      	add	sp, #16
    7e4a:	4770      	bx	lr

00007e4c <get_sub_data>:
	struct nrf_clock_control_data *data = dev->data;
    7e4c:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
    7e4e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    7e52:	0089      	lsls	r1, r1, #2
    7e54:	3138      	adds	r1, #56	; 0x38
}
    7e56:	4408      	add	r0, r1
    7e58:	4770      	bx	lr

00007e5a <get_sub_config>:
	const struct nrf_clock_control_config *config =
    7e5a:	6840      	ldr	r0, [r0, #4]
	return &config->subsys[type];
    7e5c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
}
    7e60:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    7e64:	4770      	bx	lr

00007e66 <get_onoff_manager>:
	struct nrf_clock_control_data *data = dev->data;
    7e66:	6900      	ldr	r0, [r0, #16]
	return &data->mgr[type];
    7e68:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
}
    7e6c:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    7e70:	4770      	bx	lr

00007e72 <get_status>:
{
    7e72:	b508      	push	{r3, lr}
	return GET_STATUS(get_sub_data(dev, type)->flags);
    7e74:	b2c9      	uxtb	r1, r1
    7e76:	f7ff ffe9 	bl	7e4c <get_sub_data>
    7e7a:	6880      	ldr	r0, [r0, #8]
}
    7e7c:	f000 0007 	and.w	r0, r0, #7
    7e80:	bd08      	pop	{r3, pc}

00007e82 <set_off_state>:
	__asm__ volatile(
    7e82:	f04f 0320 	mov.w	r3, #32
    7e86:	f3ef 8211 	mrs	r2, BASEPRI
    7e8a:	f383 8812 	msr	BASEPRI_MAX, r3
    7e8e:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    7e92:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    7e94:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
    7e98:	d001      	beq.n	7e9e <set_off_state+0x1c>
    7e9a:	428b      	cmp	r3, r1
    7e9c:	d107      	bne.n	7eae <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
    7e9e:	2301      	movs	r3, #1
    7ea0:	6003      	str	r3, [r0, #0]
	int err = 0;
    7ea2:	2000      	movs	r0, #0
	__asm__ volatile(
    7ea4:	f382 8811 	msr	BASEPRI, r2
    7ea8:	f3bf 8f6f 	isb	sy
}
    7eac:	4770      	bx	lr
		err = -EPERM;
    7eae:	f04f 30ff 	mov.w	r0, #4294967295
    7eb2:	e7f7      	b.n	7ea4 <set_off_state+0x22>

00007eb4 <set_starting_state>:
{
    7eb4:	b410      	push	{r4}
	__asm__ volatile(
    7eb6:	f04f 0320 	mov.w	r3, #32
    7eba:	f3ef 8211 	mrs	r2, BASEPRI
    7ebe:	f383 8812 	msr	BASEPRI_MAX, r3
    7ec2:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    7ec6:	6803      	ldr	r3, [r0, #0]
    7ec8:	f003 04c0 	and.w	r4, r3, #192	; 0xc0
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    7ecc:	f003 0307 	and.w	r3, r3, #7
    7ed0:	2b01      	cmp	r3, #1
    7ed2:	d009      	beq.n	7ee8 <set_starting_state+0x34>
	} else if (current_ctx != ctx) {
    7ed4:	428c      	cmp	r4, r1
    7ed6:	d00a      	beq.n	7eee <set_starting_state+0x3a>
		err = -EPERM;
    7ed8:	f04f 30ff 	mov.w	r0, #4294967295
	__asm__ volatile(
    7edc:	f382 8811 	msr	BASEPRI, r2
    7ee0:	f3bf 8f6f 	isb	sy
}
    7ee4:	bc10      	pop	{r4}
    7ee6:	4770      	bx	lr
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    7ee8:	6001      	str	r1, [r0, #0]
	int err = 0;
    7eea:	2000      	movs	r0, #0
    7eec:	e7f6      	b.n	7edc <set_starting_state+0x28>
		err = -EALREADY;
    7eee:	f06f 0077 	mvn.w	r0, #119	; 0x77
    7ef2:	e7f3      	b.n	7edc <set_starting_state+0x28>

00007ef4 <set_on_state>:
	__asm__ volatile(
    7ef4:	f04f 0320 	mov.w	r3, #32
    7ef8:	f3ef 8211 	mrs	r2, BASEPRI
    7efc:	f383 8812 	msr	BASEPRI_MAX, r3
    7f00:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    7f04:	6803      	ldr	r3, [r0, #0]
    7f06:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    7f0a:	f043 0302 	orr.w	r3, r3, #2
    7f0e:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
    7f10:	f382 8811 	msr	BASEPRI, r2
    7f14:	f3bf 8f6f 	isb	sy
}
    7f18:	4770      	bx	lr

00007f1a <clkstarted_handle>:
{
    7f1a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7f1c:	4606      	mov	r6, r0
    7f1e:	460c      	mov	r4, r1
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    7f20:	f7ff ff94 	bl	7e4c <get_sub_data>
	clock_control_cb_t callback = sub_data->cb;
    7f24:	6805      	ldr	r5, [r0, #0]
	void *user_data = sub_data->user_data;
    7f26:	6847      	ldr	r7, [r0, #4]
	sub_data->cb = NULL;
    7f28:	2300      	movs	r3, #0
    7f2a:	f840 3b08 	str.w	r3, [r0], #8
	set_on_state(&sub_data->flags);
    7f2e:	f7ff ffe1 	bl	7ef4 <set_on_state>
	if (callback) {
    7f32:	b11d      	cbz	r5, 7f3c <clkstarted_handle+0x22>
		callback(dev, (clock_control_subsys_t)type, user_data);
    7f34:	463a      	mov	r2, r7
    7f36:	4621      	mov	r1, r4
    7f38:	4630      	mov	r0, r6
    7f3a:	47a8      	blx	r5
}
    7f3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00007f3e <stop>:
{
    7f3e:	b570      	push	{r4, r5, r6, lr}
    7f40:	4606      	mov	r6, r0
    7f42:	4615      	mov	r5, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    7f44:	b2cc      	uxtb	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    7f46:	4621      	mov	r1, r4
    7f48:	f7ff ff80 	bl	7e4c <get_sub_data>
	err = set_off_state(&subdata->flags, ctx);
    7f4c:	4629      	mov	r1, r5
    7f4e:	3008      	adds	r0, #8
    7f50:	f7ff ff97 	bl	7e82 <set_off_state>
	if (err < 0) {
    7f54:	2800      	cmp	r0, #0
    7f56:	db06      	blt.n	7f66 <stop+0x28>
	get_sub_config(dev, type)->stop();
    7f58:	4621      	mov	r1, r4
    7f5a:	4630      	mov	r0, r6
    7f5c:	f7ff ff7d 	bl	7e5a <get_sub_config>
    7f60:	6843      	ldr	r3, [r0, #4]
    7f62:	4798      	blx	r3
	return 0;
    7f64:	2000      	movs	r0, #0
}
    7f66:	bd70      	pop	{r4, r5, r6, pc}

00007f68 <api_stop>:
{
    7f68:	b508      	push	{r3, lr}
	return stop(dev, subsys, CTX_API);
    7f6a:	2280      	movs	r2, #128	; 0x80
    7f6c:	f7ff ffe7 	bl	7f3e <stop>
}
    7f70:	bd08      	pop	{r3, pc}

00007f72 <async_start>:
{
    7f72:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7f76:	4606      	mov	r6, r0
    7f78:	4690      	mov	r8, r2
    7f7a:	461f      	mov	r7, r3
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    7f7c:	b2cd      	uxtb	r5, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    7f7e:	4629      	mov	r1, r5
    7f80:	f7ff ff64 	bl	7e4c <get_sub_data>
    7f84:	4604      	mov	r4, r0
	err = set_starting_state(&subdata->flags, ctx);
    7f86:	9906      	ldr	r1, [sp, #24]
    7f88:	3008      	adds	r0, #8
    7f8a:	f7ff ff93 	bl	7eb4 <set_starting_state>
	if (err < 0) {
    7f8e:	2800      	cmp	r0, #0
    7f90:	db09      	blt.n	7fa6 <async_start+0x34>
	subdata->cb = cb;
    7f92:	f8c4 8000 	str.w	r8, [r4]
	subdata->user_data = user_data;
    7f96:	6067      	str	r7, [r4, #4]
	 get_sub_config(dev, type)->start();
    7f98:	4629      	mov	r1, r5
    7f9a:	4630      	mov	r0, r6
    7f9c:	f7ff ff5d 	bl	7e5a <get_sub_config>
    7fa0:	6803      	ldr	r3, [r0, #0]
    7fa2:	4798      	blx	r3
	return 0;
    7fa4:	2000      	movs	r0, #0
}
    7fa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00007faa <api_start>:
{
    7faa:	b510      	push	{r4, lr}
    7fac:	b082      	sub	sp, #8
	return async_start(dev, subsys, cb, user_data, CTX_API);
    7fae:	2480      	movs	r4, #128	; 0x80
    7fb0:	9400      	str	r4, [sp, #0]
    7fb2:	f7ff ffde 	bl	7f72 <async_start>
}
    7fb6:	b002      	add	sp, #8
    7fb8:	bd10      	pop	{r4, pc}

00007fba <onoff_started_callback>:
{
    7fba:	b510      	push	{r4, lr}
    7fbc:	4614      	mov	r4, r2
	struct onoff_manager *mgr = get_onoff_manager(dev, type);
    7fbe:	b2c9      	uxtb	r1, r1
    7fc0:	f7ff ff51 	bl	7e66 <get_onoff_manager>
	notify(mgr, 0);
    7fc4:	2100      	movs	r1, #0
    7fc6:	47a0      	blx	r4
}
    7fc8:	bd10      	pop	{r4, pc}

00007fca <hfclk_start>:
{
    7fca:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    7fcc:	2001      	movs	r0, #1
    7fce:	f7fc fdf1 	bl	4bb4 <nrfx_clock_start>
}
    7fd2:	bd08      	pop	{r3, pc}

00007fd4 <hfclk_stop>:
{
    7fd4:	b508      	push	{r3, lr}
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    7fd6:	2001      	movs	r0, #1
    7fd8:	f7fc fe2a 	bl	4c30 <nrfx_clock_stop>
}
    7fdc:	bd08      	pop	{r3, pc}

00007fde <lfclk_stop>:
{
    7fde:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    7fe0:	2000      	movs	r0, #0
    7fe2:	f7fc fe25 	bl	4c30 <nrfx_clock_stop>
}
    7fe6:	bd08      	pop	{r3, pc}

00007fe8 <blocking_start_callback>:
{
    7fe8:	b508      	push	{r3, lr}
    7fea:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
    7fec:	f7fe f8f6 	bl	61dc <z_impl_k_sem_give>
}
    7ff0:	bd08      	pop	{r3, pc}

00007ff2 <wait>:
{
    7ff2:	b508      	push	{r3, lr}
	if (!IS_ENABLED(CONFIG_MULTITHREADING) || k_is_in_isr()) {
    7ff4:	f000 fbff 	bl	87f6 <k_is_in_isr>
    7ff8:	b100      	cbz	r0, 7ffc <wait+0xa>
}
    7ffa:	bd08      	pop	{r3, pc}
	return z_impl_k_sleep(timeout);
    7ffc:	2042      	movs	r0, #66	; 0x42
    7ffe:	2100      	movs	r1, #0
    8000:	f7fe fcca 	bl	6998 <z_impl_k_sleep>
    8004:	e7f9      	b.n	7ffa <wait+0x8>

00008006 <get_pull>:
	if (flags & GPIO_PULL_UP) {
    8006:	f010 0f10 	tst.w	r0, #16
    800a:	d104      	bne.n	8016 <get_pull+0x10>
	} else if (flags & GPIO_PULL_DOWN) {
    800c:	f010 0f20 	tst.w	r0, #32
    8010:	d103      	bne.n	801a <get_pull+0x14>
	return NRF_GPIO_PIN_NOPULL;
    8012:	2000      	movs	r0, #0
    8014:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLUP;
    8016:	2003      	movs	r0, #3
    8018:	4770      	bx	lr
		return NRF_GPIO_PIN_PULLDOWN;
    801a:	2001      	movs	r0, #1
}
    801c:	4770      	bx	lr

0000801e <gpio_nrfx_port_get_raw>:
	return port->config;
    801e:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8020:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
    8022:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
    8026:	600b      	str	r3, [r1, #0]
}
    8028:	2000      	movs	r0, #0
    802a:	4770      	bx	lr

0000802c <gpio_nrfx_port_set_masked_raw>:
	return port->config;
    802c:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    802e:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
    8030:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
    8034:	4042      	eors	r2, r0
    8036:	400a      	ands	r2, r1
    8038:	4042      	eors	r2, r0
    p_reg->OUT = value;
    803a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
    803e:	2000      	movs	r0, #0
    8040:	4770      	bx	lr

00008042 <gpio_nrfx_port_set_bits_raw>:
	return port->config;
    8042:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8044:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
    8046:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
}
    804a:	2000      	movs	r0, #0
    804c:	4770      	bx	lr

0000804e <gpio_nrfx_port_clear_bits_raw>:
	return port->config;
    804e:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    8050:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
    8052:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
}
    8056:	2000      	movs	r0, #0
    8058:	4770      	bx	lr

0000805a <gpio_nrfx_port_toggle_bits>:
	return port->config;
    805a:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    805c:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
    805e:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
    8062:	404b      	eors	r3, r1
    p_reg->OUT = value;
    8064:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
    8068:	2000      	movs	r0, #0
    806a:	4770      	bx	lr

0000806c <get_trigger>:
	if (mode == GPIO_INT_MODE_LEVEL) {
    806c:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
    8070:	d007      	beq.n	8082 <get_trigger+0x16>
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    8072:	f5b1 2fc0 	cmp.w	r1, #393216	; 0x60000
    8076:	d00d      	beq.n	8094 <get_trigger+0x28>
    8078:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
    807c:	d008      	beq.n	8090 <get_trigger+0x24>
    807e:	2001      	movs	r0, #1
}
    8080:	4770      	bx	lr
		return trig == GPIO_INT_TRIG_LOW ? NRFX_GPIOTE_TRIGGER_LOW :
    8082:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
    8086:	d001      	beq.n	808c <get_trigger+0x20>
    8088:	2005      	movs	r0, #5
    808a:	4770      	bx	lr
    808c:	2004      	movs	r0, #4
    808e:	4770      	bx	lr
	return trig == GPIO_INT_TRIG_BOTH ? NRFX_GPIOTE_TRIGGER_TOGGLE :
    8090:	2002      	movs	r0, #2
    8092:	4770      	bx	lr
    8094:	2003      	movs	r0, #3
    8096:	4770      	bx	lr

00008098 <gpio_nrfx_manage_callback>:
{
    8098:	b470      	push	{r4, r5, r6}
	return port->data;
    809a:	6900      	ldr	r0, [r0, #16]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    809c:	1d05      	adds	r5, r0, #4
	return list->head;
    809e:	6843      	ldr	r3, [r0, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
    80a0:	b1db      	cbz	r3, 80da <gpio_nrfx_manage_callback+0x42>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
    80a2:	460e      	mov	r6, r1
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    80a4:	2400      	movs	r4, #0
    80a6:	e00a      	b.n	80be <gpio_nrfx_manage_callback+0x26>
	return node->next;
    80a8:	680b      	ldr	r3, [r1, #0]
	list->head = node;
    80aa:	6043      	str	r3, [r0, #4]
	return list->tail;
    80ac:	686c      	ldr	r4, [r5, #4]
Z_GENLIST_REMOVE(slist, snode)
    80ae:	42a1      	cmp	r1, r4
    80b0:	d10f      	bne.n	80d2 <gpio_nrfx_manage_callback+0x3a>
	list->tail = node;
    80b2:	606b      	str	r3, [r5, #4]
}
    80b4:	e00d      	b.n	80d2 <gpio_nrfx_manage_callback+0x3a>
	list->tail = node;
    80b6:	606c      	str	r4, [r5, #4]
}
    80b8:	e00b      	b.n	80d2 <gpio_nrfx_manage_callback+0x3a>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    80ba:	461c      	mov	r4, r3
    80bc:	681b      	ldr	r3, [r3, #0]
    80be:	b15b      	cbz	r3, 80d8 <gpio_nrfx_manage_callback+0x40>
    80c0:	429e      	cmp	r6, r3
    80c2:	d1fa      	bne.n	80ba <gpio_nrfx_manage_callback+0x22>
Z_GENLIST_REMOVE(slist, snode)
    80c4:	2c00      	cmp	r4, #0
    80c6:	d0ef      	beq.n	80a8 <gpio_nrfx_manage_callback+0x10>
	return node->next;
    80c8:	680b      	ldr	r3, [r1, #0]
	parent->next = child;
    80ca:	6023      	str	r3, [r4, #0]
	return list->tail;
    80cc:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_REMOVE(slist, snode)
    80ce:	4299      	cmp	r1, r3
    80d0:	d0f1      	beq.n	80b6 <gpio_nrfx_manage_callback+0x1e>
	parent->next = child;
    80d2:	2300      	movs	r3, #0
    80d4:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    80d6:	e000      	b.n	80da <gpio_nrfx_manage_callback+0x42>
			if (!set) {
    80d8:	b152      	cbz	r2, 80f0 <gpio_nrfx_manage_callback+0x58>
				return -EINVAL;
			}
		}
	}

	if (set) {
    80da:	b162      	cbz	r2, 80f6 <gpio_nrfx_manage_callback+0x5e>
	return list->head;
    80dc:	6843      	ldr	r3, [r0, #4]
	parent->next = child;
    80de:	600b      	str	r3, [r1, #0]
	list->head = node;
    80e0:	6041      	str	r1, [r0, #4]
	return list->tail;
    80e2:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_PREPEND(slist, snode)
    80e4:	b10b      	cbz	r3, 80ea <gpio_nrfx_manage_callback+0x52>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
    80e6:	2000      	movs	r0, #0
    80e8:	e006      	b.n	80f8 <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
    80ea:	6069      	str	r1, [r5, #4]
    80ec:	2000      	movs	r0, #0
}
    80ee:	e003      	b.n	80f8 <gpio_nrfx_manage_callback+0x60>
				return -EINVAL;
    80f0:	f06f 0015 	mvn.w	r0, #21
    80f4:	e000      	b.n	80f8 <gpio_nrfx_manage_callback+0x60>
	return 0;
    80f6:	2000      	movs	r0, #0
}
    80f8:	bc70      	pop	{r4, r5, r6}
    80fa:	4770      	bx	lr

000080fc <nrfx_gpio_handler>:
{
    80fc:	b570      	push	{r4, r5, r6, lr}
    *p_pin = pin_number & 0x1F;
    80fe:	f000 041f 	and.w	r4, r0, #31
	const struct device *port = get_dev(port_id);
    8102:	0940      	lsrs	r0, r0, #5
    8104:	f7fb fbec 	bl	38e0 <get_dev>
	if (port == NULL) {
    8108:	b1d8      	cbz	r0, 8142 <nrfx_gpio_handler+0x46>
    810a:	4606      	mov	r6, r0
	return port->data;
    810c:	6903      	ldr	r3, [r0, #16]
	gpio_fire_callbacks(list, port, BIT(pin));
    810e:	2501      	movs	r5, #1
    8110:	40a5      	lsls	r5, r4
	return list->head;
    8112:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    8114:	b119      	cbz	r1, 811e <nrfx_gpio_handler+0x22>
    8116:	460c      	mov	r4, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
    8118:	b149      	cbz	r1, 812e <nrfx_gpio_handler+0x32>
	return node->next;
    811a:	680c      	ldr	r4, [r1, #0]
    811c:	e007      	b.n	812e <nrfx_gpio_handler+0x32>
    811e:	460c      	mov	r4, r1
    8120:	e005      	b.n	812e <nrfx_gpio_handler+0x32>
    8122:	b164      	cbz	r4, 813e <nrfx_gpio_handler+0x42>
    8124:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
    8126:	b104      	cbz	r4, 812a <nrfx_gpio_handler+0x2e>
	return node->next;
    8128:	6823      	ldr	r3, [r4, #0]
    812a:	4621      	mov	r1, r4
    812c:	461c      	mov	r4, r3
    812e:	b141      	cbz	r1, 8142 <nrfx_gpio_handler+0x46>
		if (cb->pin_mask & pins) {
    8130:	688a      	ldr	r2, [r1, #8]
    8132:	402a      	ands	r2, r5
    8134:	d0f5      	beq.n	8122 <nrfx_gpio_handler+0x26>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
    8136:	684b      	ldr	r3, [r1, #4]
    8138:	4630      	mov	r0, r6
    813a:	4798      	blx	r3
    813c:	e7f1      	b.n	8122 <nrfx_gpio_handler+0x26>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    813e:	4623      	mov	r3, r4
    8140:	e7f3      	b.n	812a <nrfx_gpio_handler+0x2e>
}
    8142:	bd70      	pop	{r4, r5, r6, pc}

00008144 <spi_nrfx_release>:
{
    8144:	b510      	push	{r4, lr}
	return dev->data;
    8146:	6904      	ldr	r4, [r0, #16]
	return !!(ctx->config == config);
    8148:	6823      	ldr	r3, [r4, #0]
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
    814a:	428b      	cmp	r3, r1
    814c:	d131      	bne.n	81b2 <spi_nrfx_release+0x6e>
	if (dev_data->busy) {
    814e:	f894 305c 	ldrb.w	r3, [r4, #92]	; 0x5c
    8152:	2b00      	cmp	r3, #0
    8154:	d130      	bne.n	81b8 <spi_nrfx_release+0x74>
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio.port) {
    8156:	6823      	ldr	r3, [r4, #0]
    8158:	b1c3      	cbz	r3, 818c <spi_nrfx_release+0x48>
    815a:	689b      	ldr	r3, [r3, #8]
    815c:	b1b3      	cbz	r3, 818c <spi_nrfx_release+0x48>
    815e:	681a      	ldr	r2, [r3, #0]
    8160:	b1a2      	cbz	r2, 818c <spi_nrfx_release+0x48>
			k_busy_wait(ctx->config->cs->delay);
    8162:	6898      	ldr	r0, [r3, #8]
	z_impl_k_busy_wait(usec_to_wait);
    8164:	f000 fd58 	bl	8c18 <z_impl_k_busy_wait>
			gpio_pin_set_dt(&ctx->config->cs->gpio, 0);
    8168:	6823      	ldr	r3, [r4, #0]
    816a:	689b      	ldr	r3, [r3, #8]
	return gpio_pin_set(spec->port, spec->pin, value);
    816c:	6818      	ldr	r0, [r3, #0]
    816e:	7919      	ldrb	r1, [r3, #4]
	const struct gpio_driver_data *const data =
    8170:	6903      	ldr	r3, [r0, #16]
	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
    8172:	681a      	ldr	r2, [r3, #0]
    8174:	2301      	movs	r3, #1
    8176:	408b      	lsls	r3, r1
    8178:	421a      	tst	r2, r3
    817a:	d10b      	bne.n	8194 <spi_nrfx_release+0x50>
    817c:	2300      	movs	r3, #0
	if (value != 0)	{
    817e:	b15b      	cbz	r3, 8198 <spi_nrfx_release+0x54>
		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    8180:	2301      	movs	r3, #1
    8182:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    8186:	6883      	ldr	r3, [r0, #8]
	return api->port_set_bits_raw(port, pins);
    8188:	68db      	ldr	r3, [r3, #12]
    818a:	4798      	blx	r3
	return sem->count;
    818c:	69a3      	ldr	r3, [r4, #24]
	if (!k_sem_count_get(&ctx->lock)) {
    818e:	b153      	cbz	r3, 81a6 <spi_nrfx_release+0x62>
	return 0;
    8190:	2000      	movs	r0, #0
}
    8192:	bd10      	pop	{r4, pc}
		value = (value != 0) ? 0 : 1;
    8194:	2301      	movs	r3, #1
    8196:	e7f2      	b.n	817e <spi_nrfx_release+0x3a>
		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
    8198:	2301      	movs	r3, #1
    819a:	fa03 f101 	lsl.w	r1, r3, r1
	const struct gpio_driver_api *api =
    819e:	6883      	ldr	r3, [r0, #8]
	return api->port_clear_bits_raw(port, pins);
    81a0:	691b      	ldr	r3, [r3, #16]
    81a2:	4798      	blx	r3
	return gpio_pin_set(spec->port, spec->pin, value);
    81a4:	e7f2      	b.n	818c <spi_nrfx_release+0x48>
		ctx->owner = NULL;
    81a6:	6063      	str	r3, [r4, #4]
		k_sem_give(&ctx->lock);
    81a8:	f104 0010 	add.w	r0, r4, #16
	z_impl_k_sem_give(sem);
    81ac:	f7fe f816 	bl	61dc <z_impl_k_sem_give>
}
    81b0:	e7ee      	b.n	8190 <spi_nrfx_release+0x4c>
		return -EINVAL;
    81b2:	f06f 0015 	mvn.w	r0, #21
    81b6:	e7ec      	b.n	8192 <spi_nrfx_release+0x4e>
		return -EBUSY;
    81b8:	f06f 000f 	mvn.w	r0, #15
    81bc:	e7e9      	b.n	8192 <spi_nrfx_release+0x4e>

000081be <spi_nrfx_transceive>:
{
    81be:	b510      	push	{r4, lr}
    81c0:	b082      	sub	sp, #8
	return transceive(dev, spi_cfg, tx_bufs, rx_bufs, false, NULL);
    81c2:	2400      	movs	r4, #0
    81c4:	9401      	str	r4, [sp, #4]
    81c6:	9400      	str	r4, [sp, #0]
    81c8:	f7fb fee2 	bl	3f90 <transceive>
}
    81cc:	b002      	add	sp, #8
    81ce:	bd10      	pop	{r4, pc}

000081d0 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
    81d0:	4770      	bx	lr

000081d2 <counter_sub>:
	return (a - b) & COUNTER_MAX;
    81d2:	1a40      	subs	r0, r0, r1
}
    81d4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    81d8:	4770      	bx	lr

000081da <event_clear>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    81da:	f100 0350 	add.w	r3, r0, #80	; 0x50
    81de:	009b      	lsls	r3, r3, #2
    81e0:	b29b      	uxth	r3, r3
    81e2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    81e6:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
    81ea:	2200      	movs	r2, #0
    81ec:	601a      	str	r2, [r3, #0]
    81ee:	681b      	ldr	r3, [r3, #0]
}
    81f0:	4770      	bx	lr

000081f2 <absolute_time_to_cc>:
}
    81f2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    81f6:	4770      	bx	lr

000081f8 <full_int_lock>:
	__asm__ volatile(
    81f8:	f04f 0320 	mov.w	r3, #32
    81fc:	f3ef 8011 	mrs	r0, BASEPRI
    8200:	f383 8812 	msr	BASEPRI_MAX, r3
    8204:	f3bf 8f6f 	isb	sy
}
    8208:	4770      	bx	lr

0000820a <full_int_unlock>:
	__asm__ volatile(
    820a:	f380 8811 	msr	BASEPRI, r0
    820e:	f3bf 8f6f 	isb	sy
}
    8212:	4770      	bx	lr

00008214 <set_absolute_alarm>:
{
    8214:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8216:	4606      	mov	r6, r0
	uint32_t cc_val = abs_val & COUNTER_MAX;
    8218:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	uint32_t prev_cc = get_comparator(chan);
    821c:	f7fc f80e 	bl	423c <get_comparator>
    8220:	4607      	mov	r7, r0
    8222:	e019      	b.n	8258 <set_absolute_alarm+0x44>
	z_impl_k_busy_wait(usec_to_wait);
    8224:	2013      	movs	r0, #19
    8226:	f000 fcf7 	bl	8c18 <z_impl_k_busy_wait>
}
    822a:	e022      	b.n	8272 <set_absolute_alarm+0x5e>
		event_clear(chan);
    822c:	4630      	mov	r0, r6
    822e:	f7ff ffd4 	bl	81da <event_clear>
		event_enable(chan);
    8232:	4630      	mov	r0, r6
    8234:	f7fc f80a 	bl	424c <event_enable>
		set_comparator(chan, cc_val);
    8238:	4629      	mov	r1, r5
    823a:	4630      	mov	r0, r6
    823c:	f7fb fff4 	bl	4228 <set_comparator>
		now2 = counter();
    8240:	f7fc f818 	bl	4274 <counter>
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    8244:	4284      	cmp	r4, r0
    8246:	d01e      	beq.n	8286 <set_absolute_alarm+0x72>
    8248:	1c81      	adds	r1, r0, #2
    824a:	4628      	mov	r0, r5
    824c:	f7ff ffc1 	bl	81d2 <counter_sub>
	} while ((now2 != now) &&
    8250:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    8254:	d917      	bls.n	8286 <set_absolute_alarm+0x72>
		prev_cc = cc_val;
    8256:	462f      	mov	r7, r5
		now = counter();
    8258:	f7fc f80c 	bl	4274 <counter>
    825c:	4604      	mov	r4, r0
		set_comparator(chan, now);
    825e:	4601      	mov	r1, r0
    8260:	4630      	mov	r0, r6
    8262:	f7fb ffe1 	bl	4228 <set_comparator>
		if (counter_sub(prev_cc, now) == 1) {
    8266:	4621      	mov	r1, r4
    8268:	4638      	mov	r0, r7
    826a:	f7ff ffb2 	bl	81d2 <counter_sub>
    826e:	2801      	cmp	r0, #1
    8270:	d0d8      	beq.n	8224 <set_absolute_alarm+0x10>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    8272:	1ca7      	adds	r7, r4, #2
    8274:	4639      	mov	r1, r7
    8276:	4628      	mov	r0, r5
    8278:	f7ff ffab 	bl	81d2 <counter_sub>
    827c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    8280:	d9d4      	bls.n	822c <set_absolute_alarm+0x18>
			cc_val = now + 2;
    8282:	463d      	mov	r5, r7
    8284:	e7d2      	b.n	822c <set_absolute_alarm+0x18>
}
    8286:	4628      	mov	r0, r5
    8288:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000828a <compare_set>:
{
    828a:	b5f0      	push	{r4, r5, r6, r7, lr}
    828c:	b083      	sub	sp, #12
    828e:	4604      	mov	r4, r0
    8290:	4617      	mov	r7, r2
    8292:	461d      	mov	r5, r3
	key = compare_int_lock(chan);
    8294:	f7fb fff4 	bl	4280 <compare_int_lock>
    8298:	4606      	mov	r6, r0
	int ret = compare_set_nolocks(chan, target_time, handler, user_data);
    829a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    829c:	9301      	str	r3, [sp, #4]
    829e:	9b08      	ldr	r3, [sp, #32]
    82a0:	9300      	str	r3, [sp, #0]
    82a2:	463a      	mov	r2, r7
    82a4:	462b      	mov	r3, r5
    82a6:	4620      	mov	r0, r4
    82a8:	f7fc f8d8 	bl	445c <compare_set_nolocks>
    82ac:	4605      	mov	r5, r0
	compare_int_unlock(chan, key);
    82ae:	4631      	mov	r1, r6
    82b0:	4620      	mov	r0, r4
    82b2:	f7fc f849 	bl	4348 <compare_int_unlock>
}
    82b6:	4628      	mov	r0, r5
    82b8:	b003      	add	sp, #12
    82ba:	bdf0      	pop	{r4, r5, r6, r7, pc}

000082bc <sys_clock_cycle_get_32>:
{
    82bc:	b508      	push	{r3, lr}
	return (uint32_t)z_nrf_rtc_timer_read();
    82be:	f7fc f8ad 	bl	441c <z_nrf_rtc_timer_read>
}
    82c2:	bd08      	pop	{r3, pc}

000082c4 <nrfx_isr>:

#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
    82c4:	b508      	push	{r3, lr}
	((nrfx_irq_handler_t)irq_handler)();
    82c6:	4780      	blx	r0
}
    82c8:	bd08      	pop	{r3, pc}

000082ca <nrfx_busy_wait>:

void nrfx_busy_wait(uint32_t usec_to_wait)
{
    82ca:	b508      	push	{r3, lr}
	z_impl_k_busy_wait(usec_to_wait);
    82cc:	f000 fca4 	bl	8c18 <z_impl_k_busy_wait>
	k_busy_wait(usec_to_wait);
}
    82d0:	bd08      	pop	{r3, pc}

000082d2 <nrfx_clock_enable>:
{
    82d2:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    82d4:	2000      	movs	r0, #0
    82d6:	f7fa fa33 	bl	2740 <arch_irq_is_enabled>
    82da:	b100      	cbz	r0, 82de <nrfx_clock_enable+0xc>
}
    82dc:	bd08      	pop	{r3, pc}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    82de:	f7fa fa0b 	bl	26f8 <arch_irq_enable>
    82e2:	e7fb      	b.n	82dc <nrfx_clock_enable+0xa>

000082e4 <pin_is_task_output>:
{
    82e4:	b510      	push	{r4, lr}
    82e6:	4604      	mov	r4, r0
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    82e8:	f7fc fd8c 	bl	4e04 <pin_is_output>
    82ec:	b128      	cbz	r0, 82fa <pin_is_task_output+0x16>
    82ee:	4620      	mov	r0, r4
    82f0:	f7fc fd72 	bl	4dd8 <pin_in_use_by_te>
    82f4:	b118      	cbz	r0, 82fe <pin_is_task_output+0x1a>
    82f6:	2001      	movs	r0, #1
    82f8:	e000      	b.n	82fc <pin_is_task_output+0x18>
    82fa:	2000      	movs	r0, #0
}
    82fc:	bd10      	pop	{r4, pc}
    return pin_is_output(pin) && pin_in_use_by_te(pin);
    82fe:	2000      	movs	r0, #0
    8300:	e7fc      	b.n	82fc <pin_is_task_output+0x18>

00008302 <pin_is_input>:
{
    8302:	b508      	push	{r3, lr}
    return !pin_is_output(pin);
    8304:	f7fc fd7e 	bl	4e04 <pin_is_output>
    8308:	f080 0001 	eor.w	r0, r0, #1
}
    830c:	b2c0      	uxtb	r0, r0
    830e:	bd08      	pop	{r3, pc}

00008310 <gpiote_polarity_to_trigger>:
}
    8310:	4770      	bx	lr

00008312 <gpiote_trigger_to_polarity>:
}
    8312:	4770      	bx	lr

00008314 <is_level>:
}
    8314:	2803      	cmp	r0, #3
    8316:	bf94      	ite	ls
    8318:	2000      	movls	r0, #0
    831a:	2001      	movhi	r0, #1
    831c:	4770      	bx	lr

0000831e <next_sense_cond_call_handler>:
{
    831e:	b570      	push	{r4, r5, r6, lr}
    8320:	4604      	mov	r4, r0
    8322:	460d      	mov	r5, r1
    8324:	4616      	mov	r6, r2
    if (is_level(trigger))
    8326:	4608      	mov	r0, r1
    8328:	f7ff fff4 	bl	8314 <is_level>
    832c:	b9b8      	cbnz	r0, 835e <next_sense_cond_call_handler+0x40>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    832e:	2e02      	cmp	r6, #2
    8330:	d037      	beq.n	83a2 <next_sense_cond_call_handler+0x84>
    8332:	2002      	movs	r0, #2
    8334:	f004 031f 	and.w	r3, r4, #31
    uint32_t cnf = reg->PIN_CNF[pin_number];
    8338:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    833c:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    8340:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    cnf &= ~to_update;
    8344:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    8348:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
    834c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
        if ((trigger == NRFX_GPIOTE_TRIGGER_TOGGLE) ||
    8350:	2d03      	cmp	r5, #3
    8352:	d02a      	beq.n	83aa <next_sense_cond_call_handler+0x8c>
    8354:	2e02      	cmp	r6, #2
    8356:	d026      	beq.n	83a6 <next_sense_cond_call_handler+0x88>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    8358:	2e03      	cmp	r6, #3
    835a:	d02b      	beq.n	83b4 <next_sense_cond_call_handler+0x96>
}
    835c:	bd70      	pop	{r4, r5, r6, pc}
        call_handler(pin, trigger);
    835e:	4629      	mov	r1, r5
    8360:	4620      	mov	r0, r4
    8362:	f7fc fda1 	bl	4ea8 <call_handler>
    *p_pin = pin_number & 0x1F;
    8366:	f004 041f 	and.w	r4, r4, #31
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    836a:	f504 72e0 	add.w	r2, r4, #448	; 0x1c0
    836e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    8372:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8376:	f3c3 4301 	ubfx	r3, r3, #16, #2
        if (nrf_gpio_pin_sense_get(pin) == sense)
    837a:	429e      	cmp	r6, r3
    837c:	d1ee      	bne.n	835c <next_sense_cond_call_handler+0x3e>
    uint32_t cnf = reg->PIN_CNF[pin_number];
    837e:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
    8382:	4614      	mov	r4, r2
    8384:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    cnf &= ~to_update;
    8388:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf;
    838c:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
    uint32_t cnf = reg->PIN_CNF[pin_number];
    8390:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
    cnf &= ~to_update;
    8394:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    cnf |= ((uint32_t)(p_dir   ? *p_dir   : 0) << GPIO_PIN_CNF_DIR_Pos)   |
    8398:	ea42 4606 	orr.w	r6, r2, r6, lsl #16
    reg->PIN_CNF[pin_number] = cnf;
    839c:	f843 6024 	str.w	r6, [r3, r4, lsl #2]
}
    83a0:	e7dc      	b.n	835c <next_sense_cond_call_handler+0x3e>
                NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
    83a2:	2003      	movs	r0, #3
    83a4:	e7c6      	b.n	8334 <next_sense_cond_call_handler+0x16>
            (sense == NRF_GPIO_PIN_SENSE_HIGH && trigger == NRFX_GPIOTE_TRIGGER_LOTOHI) ||
    83a6:	2d01      	cmp	r5, #1
    83a8:	d1d6      	bne.n	8358 <next_sense_cond_call_handler+0x3a>
            call_handler(pin, trigger);
    83aa:	4629      	mov	r1, r5
    83ac:	4620      	mov	r0, r4
    83ae:	f7fc fd7b 	bl	4ea8 <call_handler>
}
    83b2:	e7d3      	b.n	835c <next_sense_cond_call_handler+0x3e>
            (sense == NRF_GPIO_PIN_SENSE_LOW && trigger == NRFX_GPIOTE_TRIGGER_HITOLO))
    83b4:	2d02      	cmp	r5, #2
    83b6:	d1d1      	bne.n	835c <next_sense_cond_call_handler+0x3e>
    83b8:	e7f7      	b.n	83aa <next_sense_cond_call_handler+0x8c>

000083ba <latch_pending_read_and_check>:
{
    83ba:	b410      	push	{r4}
    for (i = start_port; i < (start_port + length); i++)
    83bc:	4604      	mov	r4, r0
    83be:	2300      	movs	r3, #0
    83c0:	b94b      	cbnz	r3, 83d6 <latch_pending_read_and_check+0x1c>
        *p_masks = gpio_regs[i]->LATCH;
    83c2:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    83c6:	f8d2 1520 	ldr.w	r1, [r2, #1312]	; 0x520
    83ca:	f844 1b04 	str.w	r1, [r4], #4
        gpio_regs[i]->LATCH = *p_masks;
    83ce:	f8c2 1520 	str.w	r1, [r2, #1312]	; 0x520
    for (i = start_port; i < (start_port + length); i++)
    83d2:	3301      	adds	r3, #1
    83d4:	e7f4      	b.n	83c0 <latch_pending_read_and_check+0x6>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
    83d6:	2300      	movs	r3, #0
    83d8:	b113      	cbz	r3, 83e0 <latch_pending_read_and_check+0x26>
    return false;
    83da:	2000      	movs	r0, #0
}
    83dc:	bc10      	pop	{r4}
    83de:	4770      	bx	lr
        if (latch[port_idx])
    83e0:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
    83e4:	b90a      	cbnz	r2, 83ea <latch_pending_read_and_check+0x30>
    for (uint32_t port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
    83e6:	3301      	adds	r3, #1
    83e8:	e7f6      	b.n	83d8 <latch_pending_read_and_check+0x1e>
            return true;
    83ea:	2001      	movs	r0, #1
    83ec:	e7f6      	b.n	83dc <latch_pending_read_and_check+0x22>

000083ee <configure_pins>:
    if (!p_config->skip_gpio_cfg)
    83ee:	7bcb      	ldrb	r3, [r1, #15]
    83f0:	2b00      	cmp	r3, #0
    83f2:	d16d      	bne.n	84d0 <configure_pins+0xe2>
{
    83f4:	b410      	push	{r4}
        nrf_gpio_pin_write(p_config->sck_pin,
    83f6:	780b      	ldrb	r3, [r1, #0]
                           p_config->mode <= NRF_SPI_MODE_1 ? 0 : 1);
    83f8:	7b0a      	ldrb	r2, [r1, #12]
    if (value == 0)
    83fa:	2a01      	cmp	r2, #1
    83fc:	d858      	bhi.n	84b0 <configure_pins+0xc2>
    *p_pin = pin_number & 0x1F;
    83fe:	f003 031f 	and.w	r3, r3, #31
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    8402:	2201      	movs	r2, #1
    8404:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTCLR = clr_mask;
    8408:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    840c:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
        nrf_gpio_cfg(p_config->sck_pin,
    8410:	780b      	ldrb	r3, [r1, #0]
    *p_pin = pin_number & 0x1F;
    8412:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    8416:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    841a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    841e:	2401      	movs	r4, #1
    8420:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
        if (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
    8424:	784b      	ldrb	r3, [r1, #1]
    8426:	2bff      	cmp	r3, #255	; 0xff
    8428:	d00f      	beq.n	844a <configure_pins+0x5c>
    *p_pin = pin_number & 0x1F;
    842a:	f003 031f 	and.w	r3, r3, #31
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    842e:	fa04 f303 	lsl.w	r3, r4, r3
    p_reg->OUTCLR = clr_mask;
    8432:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    8436:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
            nrf_gpio_cfg_output(p_config->mosi_pin);
    843a:	784b      	ldrb	r3, [r1, #1]
    *p_pin = pin_number & 0x1F;
    843c:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    8440:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    8444:	2403      	movs	r4, #3
    8446:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
        if (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    844a:	788b      	ldrb	r3, [r1, #2]
    844c:	2bff      	cmp	r3, #255	; 0xff
    844e:	d009      	beq.n	8464 <configure_pins+0x76>
            nrf_gpio_cfg_input(p_config->miso_pin, p_config->miso_pull);
    8450:	7b8a      	ldrb	r2, [r1, #14]
    *p_pin = pin_number & 0x1F;
    8452:	f003 031f 	and.w	r3, r3, #31
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    8456:	0092      	lsls	r2, r2, #2
    reg->PIN_CNF[pin_number] = cnf;
    8458:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    845c:	f04f 44a0 	mov.w	r4, #1342177280	; 0x50000000
    8460:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
        if (p_config->ss_pin != NRFX_SPI_PIN_NOT_USED)
    8464:	78cb      	ldrb	r3, [r1, #3]
    8466:	2bff      	cmp	r3, #255	; 0xff
    8468:	d010      	beq.n	848c <configure_pins+0x9e>
    *p_pin = pin_number & 0x1F;
    846a:	f003 031f 	and.w	r3, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    846e:	2201      	movs	r2, #1
    8470:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTSET = set_mask;
    8474:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    8478:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
            nrf_gpio_cfg_output(p_config->ss_pin);
    847c:	78cb      	ldrb	r3, [r1, #3]
    *p_pin = pin_number & 0x1F;
    847e:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    8482:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    8486:	2403      	movs	r4, #3
    8488:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
    if (!p_config->skip_psel_cfg)
    848c:	7c0b      	ldrb	r3, [r1, #16]
    848e:	b96b      	cbnz	r3, 84ac <configure_pins+0xbe>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
    8490:	784b      	ldrb	r3, [r1, #1]
                            : NRF_SPI_PIN_NOT_CONNECTED;
    8492:	2bff      	cmp	r3, #255	; 0xff
    8494:	d016      	beq.n	84c4 <configure_pins+0xd6>
    8496:	461a      	mov	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    8498:	788b      	ldrb	r3, [r1, #2]
                            : NRF_SPI_PIN_NOT_CONNECTED;
    849a:	2bff      	cmp	r3, #255	; 0xff
    849c:	d015      	beq.n	84ca <configure_pins+0xdc>
        nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
    849e:	7809      	ldrb	r1, [r1, #0]
    p_reg->PSELSCK  = sck_pin;
    84a0:	f8c0 1508 	str.w	r1, [r0, #1288]	; 0x508
    p_reg->PSELMOSI = mosi_pin;
    84a4:	f8c0 250c 	str.w	r2, [r0, #1292]	; 0x50c
    p_reg->PSELMISO = miso_pin;
    84a8:	f8c0 3510 	str.w	r3, [r0, #1296]	; 0x510
}
    84ac:	bc10      	pop	{r4}
    84ae:	4770      	bx	lr
    *p_pin = pin_number & 0x1F;
    84b0:	f003 031f 	and.w	r3, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    84b4:	2201      	movs	r2, #1
    84b6:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTSET = set_mask;
    84ba:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    84be:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
}
    84c2:	e7a5      	b.n	8410 <configure_pins+0x22>
                            : NRF_SPI_PIN_NOT_CONNECTED;
    84c4:	f04f 32ff 	mov.w	r2, #4294967295
    84c8:	e7e6      	b.n	8498 <configure_pins+0xaa>
                            : NRF_SPI_PIN_NOT_CONNECTED;
    84ca:	f04f 33ff 	mov.w	r3, #4294967295
    84ce:	e7e6      	b.n	849e <configure_pins+0xb0>
    if (!p_config->skip_psel_cfg)
    84d0:	7c0b      	ldrb	r3, [r1, #16]
    84d2:	b9a3      	cbnz	r3, 84fe <configure_pins+0x110>
        uint32_t mosi_pin = (p_config->mosi_pin != NRFX_SPI_PIN_NOT_USED)
    84d4:	784b      	ldrb	r3, [r1, #1]
                            : NRF_SPI_PIN_NOT_CONNECTED;
    84d6:	2bff      	cmp	r3, #255	; 0xff
    84d8:	d00b      	beq.n	84f2 <configure_pins+0x104>
    84da:	461a      	mov	r2, r3
        uint32_t miso_pin = (p_config->miso_pin != NRFX_SPI_PIN_NOT_USED)
    84dc:	788b      	ldrb	r3, [r1, #2]
                            : NRF_SPI_PIN_NOT_CONNECTED;
    84de:	2bff      	cmp	r3, #255	; 0xff
    84e0:	d00a      	beq.n	84f8 <configure_pins+0x10a>
        nrf_spi_pins_set(p_spi, p_config->sck_pin, mosi_pin, miso_pin);
    84e2:	7809      	ldrb	r1, [r1, #0]
    p_reg->PSELSCK  = sck_pin;
    84e4:	f8c0 1508 	str.w	r1, [r0, #1288]	; 0x508
    p_reg->PSELMOSI = mosi_pin;
    84e8:	f8c0 250c 	str.w	r2, [r0, #1292]	; 0x50c
    p_reg->PSELMISO = miso_pin;
    84ec:	f8c0 3510 	str.w	r3, [r0, #1296]	; 0x510
    84f0:	4770      	bx	lr
                            : NRF_SPI_PIN_NOT_CONNECTED;
    84f2:	f04f 32ff 	mov.w	r2, #4294967295
    84f6:	e7f1      	b.n	84dc <configure_pins+0xee>
                            : NRF_SPI_PIN_NOT_CONNECTED;
    84f8:	f04f 33ff 	mov.w	r3, #4294967295
    84fc:	e7f1      	b.n	84e2 <configure_pins+0xf4>
    84fe:	4770      	bx	lr

00008500 <finish_transfer>:
{
    8500:	b508      	push	{r3, lr}
    8502:	4603      	mov	r3, r0
    if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    8504:	7f82      	ldrb	r2, [r0, #30]
    8506:	2aff      	cmp	r2, #255	; 0xff
    8508:	d008      	beq.n	851c <finish_transfer+0x1c>
    *p_pin = pin_number & 0x1F;
    850a:	f002 021f 	and.w	r2, r2, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    850e:	2101      	movs	r1, #1
    8510:	fa01 f202 	lsl.w	r2, r1, r2
    p_reg->OUTSET = set_mask;
    8514:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    8518:	f8c1 2508 	str.w	r2, [r1, #1288]	; 0x508
    p_cb->transfer_in_progress = false;
    851c:	2200      	movs	r2, #0
    851e:	775a      	strb	r2, [r3, #29]
    p_cb->evt.type = NRFX_SPI_EVENT_DONE;
    8520:	721a      	strb	r2, [r3, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
    8522:	4618      	mov	r0, r3
    8524:	f850 2b08 	ldr.w	r2, [r0], #8
    8528:	6859      	ldr	r1, [r3, #4]
    852a:	4790      	blx	r2
}
    852c:	bd08      	pop	{r3, pc}

0000852e <transfer_byte>:
{
    852e:	b430      	push	{r4, r5}
    8530:	b082      	sub	sp, #8
    return p_reg->RXD;
    8532:	f8d0 3518 	ldr.w	r3, [r0, #1304]	; 0x518
    8536:	b2db      	uxtb	r3, r3
    volatile uint8_t rx_data = nrf_spi_rxd_get(p_spi);
    8538:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_cb->bytes_transferred < p_cb->evt.xfer_desc.rx_length)
    853c:	6a0b      	ldr	r3, [r1, #32]
    853e:	698a      	ldr	r2, [r1, #24]
    8540:	4293      	cmp	r3, r2
    8542:	d203      	bcs.n	854c <transfer_byte+0x1e>
        p_cb->evt.xfer_desc.p_rx_buffer[p_cb->bytes_transferred] = rx_data;
    8544:	694a      	ldr	r2, [r1, #20]
    8546:	f89d 4007 	ldrb.w	r4, [sp, #7]
    854a:	54d4      	strb	r4, [r2, r3]
    ++p_cb->bytes_transferred;
    854c:	6a0b      	ldr	r3, [r1, #32]
    854e:	3301      	adds	r3, #1
    8550:	620b      	str	r3, [r1, #32]
    size_t bytes_used = p_cb->bytes_transferred + 1;
    8552:	1c5a      	adds	r2, r3, #1
    if (p_cb->abort)
    8554:	f891 4024 	ldrb.w	r4, [r1, #36]	; 0x24
    8558:	b13c      	cbz	r4, 856a <transfer_byte+0x3c>
        if (bytes_used < p_cb->evt.xfer_desc.tx_length)
    855a:	690c      	ldr	r4, [r1, #16]
    855c:	4294      	cmp	r4, r2
    855e:	d900      	bls.n	8562 <transfer_byte+0x34>
            p_cb->evt.xfer_desc.tx_length = bytes_used;
    8560:	610a      	str	r2, [r1, #16]
        if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    8562:	698c      	ldr	r4, [r1, #24]
    8564:	4294      	cmp	r4, r2
    8566:	d900      	bls.n	856a <transfer_byte+0x3c>
            p_cb->evt.xfer_desc.rx_length = bytes_used;
    8568:	618a      	str	r2, [r1, #24]
    if (bytes_used < p_cb->evt.xfer_desc.tx_length)
    856a:	690c      	ldr	r4, [r1, #16]
    856c:	4294      	cmp	r4, r2
    856e:	d808      	bhi.n	8582 <transfer_byte+0x54>
    else if (bytes_used < p_cb->evt.xfer_desc.rx_length)
    8570:	698d      	ldr	r5, [r1, #24]
    8572:	4295      	cmp	r5, r2
    8574:	d80d      	bhi.n	8592 <transfer_byte+0x64>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
    8576:	42a3      	cmp	r3, r4
    8578:	d310      	bcc.n	859c <transfer_byte+0x6e>
    857a:	42ab      	cmp	r3, r5
    857c:	d210      	bcs.n	85a0 <transfer_byte+0x72>
    857e:	2001      	movs	r0, #1
    8580:	e004      	b.n	858c <transfer_byte+0x5e>
        nrf_spi_txd_set(p_spi, p_cb->evt.xfer_desc.p_tx_buffer[bytes_used]);
    8582:	68cb      	ldr	r3, [r1, #12]
    8584:	5c9b      	ldrb	r3, [r3, r2]
    p_reg->TXD = data;
    8586:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
        return true;
    858a:	2001      	movs	r0, #1
}
    858c:	b002      	add	sp, #8
    858e:	bc30      	pop	{r4, r5}
    8590:	4770      	bx	lr
        nrf_spi_txd_set(p_spi, p_cb->orc);
    8592:	7fcb      	ldrb	r3, [r1, #31]
    8594:	f8c0 351c 	str.w	r3, [r0, #1308]	; 0x51c
        return true;
    8598:	2001      	movs	r0, #1
    859a:	e7f7      	b.n	858c <transfer_byte+0x5e>
    return (p_cb->bytes_transferred < p_cb->evt.xfer_desc.tx_length ||
    859c:	2001      	movs	r0, #1
    859e:	e7f5      	b.n	858c <transfer_byte+0x5e>
    85a0:	2000      	movs	r0, #0
    85a2:	e7f3      	b.n	858c <transfer_byte+0x5e>

000085a4 <spi_xfer>:
{
    85a4:	b538      	push	{r3, r4, r5, lr}
    85a6:	4604      	mov	r4, r0
    85a8:	460d      	mov	r5, r1
    p_cb->bytes_transferred = 0;
    85aa:	2300      	movs	r3, #0
    85ac:	620b      	str	r3, [r1, #32]
    p_reg->INTENCLR = mask;
    85ae:	2104      	movs	r1, #4
    85b0:	f8c0 1308 	str.w	r1, [r0, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    85b4:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
    85b8:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
    85bc:	6853      	ldr	r3, [r2, #4]
    nrf_spi_txd_set(p_spi,
    85be:	b183      	cbz	r3, 85e2 <spi_xfer+0x3e>
        (p_xfer_desc->tx_length > 0 ? p_xfer_desc->p_tx_buffer[0] : p_cb->orc));
    85c0:	6813      	ldr	r3, [r2, #0]
    nrf_spi_txd_set(p_spi,
    85c2:	781b      	ldrb	r3, [r3, #0]
    p_reg->TXD = data;
    85c4:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_xfer_desc->tx_length > 1)
    85c8:	6853      	ldr	r3, [r2, #4]
    85ca:	2b01      	cmp	r3, #1
    85cc:	d90b      	bls.n	85e6 <spi_xfer+0x42>
        nrf_spi_txd_set(p_spi, p_xfer_desc->p_tx_buffer[1]);
    85ce:	6813      	ldr	r3, [r2, #0]
    85d0:	785b      	ldrb	r3, [r3, #1]
    85d2:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
    if (p_cb->handler)
    85d6:	682b      	ldr	r3, [r5, #0]
    85d8:	b163      	cbz	r3, 85f4 <spi_xfer+0x50>
    p_reg->INTENSET = mask;
    85da:	2304      	movs	r3, #4
    85dc:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
    85e0:	bd38      	pop	{r3, r4, r5, pc}
    nrf_spi_txd_set(p_spi,
    85e2:	7feb      	ldrb	r3, [r5, #31]
    85e4:	e7ee      	b.n	85c4 <spi_xfer+0x20>
    else if (p_xfer_desc->rx_length > 1)
    85e6:	68d3      	ldr	r3, [r2, #12]
    85e8:	2b01      	cmp	r3, #1
    85ea:	d9f4      	bls.n	85d6 <spi_xfer+0x32>
        nrf_spi_txd_set(p_spi, p_cb->orc);
    85ec:	7feb      	ldrb	r3, [r5, #31]
    p_reg->TXD = data;
    85ee:	f8c4 351c 	str.w	r3, [r4, #1308]	; 0x51c
}
    85f2:	e7f0      	b.n	85d6 <spi_xfer+0x32>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    85f4:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
            while (!nrf_spi_event_check(p_spi, NRF_SPI_EVENT_READY)) {}
    85f8:	2b00      	cmp	r3, #0
    85fa:	d0fb      	beq.n	85f4 <spi_xfer+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    85fc:	2300      	movs	r3, #0
    85fe:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
    8602:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
        } while (transfer_byte(p_spi, p_cb));
    8606:	4629      	mov	r1, r5
    8608:	4620      	mov	r0, r4
    860a:	f7ff ff90 	bl	852e <transfer_byte>
    860e:	2800      	cmp	r0, #0
    8610:	d1f0      	bne.n	85f4 <spi_xfer+0x50>
        if (p_cb->ss_pin != NRFX_SPI_PIN_NOT_USED)
    8612:	7fab      	ldrb	r3, [r5, #30]
    8614:	2bff      	cmp	r3, #255	; 0xff
    8616:	d0e3      	beq.n	85e0 <spi_xfer+0x3c>
    *p_pin = pin_number & 0x1F;
    8618:	f003 031f 	and.w	r3, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    861c:	2201      	movs	r2, #1
    861e:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTSET = set_mask;
    8622:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    8626:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
}
    862a:	e7d9      	b.n	85e0 <spi_xfer+0x3c>

0000862c <irq_handler>:
{
    862c:	b510      	push	{r4, lr}
    862e:	460c      	mov	r4, r1
    8630:	2200      	movs	r2, #0
    8632:	f8c0 2108 	str.w	r2, [r0, #264]	; 0x108
    8636:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
    if (!transfer_byte(p_spi, p_cb))
    863a:	f7ff ff78 	bl	852e <transfer_byte>
    863e:	b100      	cbz	r0, 8642 <irq_handler+0x16>
}
    8640:	bd10      	pop	{r4, pc}
        finish_transfer(p_cb);
    8642:	4620      	mov	r0, r4
    8644:	f7ff ff5c 	bl	8500 <finish_transfer>
}
    8648:	e7fa      	b.n	8640 <irq_handler+0x14>

0000864a <_GetAvailWriteSpace>:
  RdOff = pRing->RdOff;
    864a:	6903      	ldr	r3, [r0, #16]
  WrOff = pRing->WrOff;
    864c:	68c2      	ldr	r2, [r0, #12]
  if (RdOff <= WrOff) {
    864e:	4293      	cmp	r3, r2
    8650:	d804      	bhi.n	865c <_GetAvailWriteSpace+0x12>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
    8652:	6880      	ldr	r0, [r0, #8]
    8654:	1a80      	subs	r0, r0, r2
    8656:	4403      	add	r3, r0
    8658:	1e58      	subs	r0, r3, #1
    865a:	4770      	bx	lr
    r = RdOff - WrOff - 1u;
    865c:	1a9b      	subs	r3, r3, r2
    865e:	1e58      	subs	r0, r3, #1
}
    8660:	4770      	bx	lr

00008662 <_WriteNoCheck>:
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    8662:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8666:	4604      	mov	r4, r0
    8668:	4688      	mov	r8, r1
    866a:	4616      	mov	r6, r2
  WrOff = pRing->WrOff;
    866c:	68c5      	ldr	r5, [r0, #12]
  Rem = pRing->SizeOfBuffer - WrOff;
    866e:	6887      	ldr	r7, [r0, #8]
    8670:	eba7 0905 	sub.w	r9, r7, r5
  if (Rem > NumBytes) {
    8674:	4591      	cmp	r9, r2
    8676:	d907      	bls.n	8688 <_WriteNoCheck+0x26>
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    8678:	6840      	ldr	r0, [r0, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
    867a:	4428      	add	r0, r5
    867c:	f7ff fb84 	bl	7d88 <memcpy>
    pRing->WrOff = WrOff + NumBytes;
    8680:	4435      	add	r5, r6
    8682:	60e5      	str	r5, [r4, #12]
}
    8684:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    8688:	6840      	ldr	r0, [r0, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
    868a:	464a      	mov	r2, r9
    868c:	4428      	add	r0, r5
    868e:	f7ff fb7b 	bl	7d88 <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
    8692:	1bed      	subs	r5, r5, r7
    8694:	4435      	add	r5, r6
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    8696:	462a      	mov	r2, r5
    8698:	eb08 0109 	add.w	r1, r8, r9
    869c:	6860      	ldr	r0, [r4, #4]
    869e:	f7ff fb73 	bl	7d88 <memcpy>
    pRing->WrOff = NumBytesAtOnce;
    86a2:	60e5      	str	r5, [r4, #12]
}
    86a4:	e7ee      	b.n	8684 <_WriteNoCheck+0x22>

000086a6 <_WriteBlocking>:
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    86a6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    86aa:	4606      	mov	r6, r0
    86ac:	4688      	mov	r8, r1
    86ae:	4617      	mov	r7, r2
  WrOff = pRing->WrOff;
    86b0:	68c5      	ldr	r5, [r0, #12]
  NumBytesWritten = 0u;
    86b2:	f04f 0900 	mov.w	r9, #0
    86b6:	e018      	b.n	86ea <_WriteBlocking+0x44>
      NumBytesToWrite = RdOff - WrOff - 1u;
    86b8:	1b64      	subs	r4, r4, r5
    86ba:	1e62      	subs	r2, r4, #1
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
    86bc:	68b3      	ldr	r3, [r6, #8]
    86be:	1b5c      	subs	r4, r3, r5
    86c0:	4294      	cmp	r4, r2
    86c2:	bf28      	it	cs
    86c4:	4614      	movcs	r4, r2
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    86c6:	42bc      	cmp	r4, r7
    86c8:	bf28      	it	cs
    86ca:	463c      	movcs	r4, r7
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    86cc:	6870      	ldr	r0, [r6, #4]
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
    86ce:	4622      	mov	r2, r4
    86d0:	4641      	mov	r1, r8
    86d2:	4428      	add	r0, r5
    86d4:	f7ff fb58 	bl	7d88 <memcpy>
    NumBytesWritten += NumBytesToWrite;
    86d8:	44a1      	add	r9, r4
    pBuffer         += NumBytesToWrite;
    86da:	44a0      	add	r8, r4
    NumBytes        -= NumBytesToWrite;
    86dc:	1b3f      	subs	r7, r7, r4
    WrOff           += NumBytesToWrite;
    86de:	4425      	add	r5, r4
    if (WrOff == pRing->SizeOfBuffer) {
    86e0:	68b3      	ldr	r3, [r6, #8]
    86e2:	42ab      	cmp	r3, r5
    86e4:	d009      	beq.n	86fa <_WriteBlocking+0x54>
    pRing->WrOff = WrOff;
    86e6:	60f5      	str	r5, [r6, #12]
  } while (NumBytes);
    86e8:	b14f      	cbz	r7, 86fe <_WriteBlocking+0x58>
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
    86ea:	6934      	ldr	r4, [r6, #16]
    if (RdOff > WrOff) {
    86ec:	42a5      	cmp	r5, r4
    86ee:	d3e3      	bcc.n	86b8 <_WriteBlocking+0x12>
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    86f0:	68b2      	ldr	r2, [r6, #8]
    86f2:	1b64      	subs	r4, r4, r5
    86f4:	4414      	add	r4, r2
    86f6:	1e62      	subs	r2, r4, #1
    86f8:	e7e0      	b.n	86bc <_WriteBlocking+0x16>
      WrOff = 0u;
    86fa:	2500      	movs	r5, #0
    86fc:	e7f3      	b.n	86e6 <_WriteBlocking+0x40>
}
    86fe:	4648      	mov	r0, r9
    8700:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00008704 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
    8704:	b508      	push	{r3, lr}
  _DoInit();
    8706:	f7fd f871 	bl	57ec <_DoInit>
}
    870a:	bd08      	pop	{r3, pc}

0000870c <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
    870c:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
    870e:	f7ff fff9 	bl	8704 <SEGGER_RTT_Init>

	return 0;
}
    8712:	2000      	movs	r0, #0
    8714:	bd08      	pop	{r3, pc}

00008716 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    8716:	b148      	cbz	r0, 872c <z_device_ready+0x16>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    8718:	68c3      	ldr	r3, [r0, #12]
    871a:	8818      	ldrh	r0, [r3, #0]
    871c:	f3c0 0008 	ubfx	r0, r0, #0, #9
    8720:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    8724:	bf14      	ite	ne
    8726:	2000      	movne	r0, #0
    8728:	2001      	moveq	r0, #1
    872a:	4770      	bx	lr
		return false;
    872c:	2000      	movs	r0, #0
}
    872e:	4770      	bx	lr

00008730 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    8730:	68c2      	ldr	r2, [r0, #12]
    8732:	6903      	ldr	r3, [r0, #16]
    8734:	431a      	orrs	r2, r3
    8736:	f012 0203 	ands.w	r2, r2, #3
    873a:	d10d      	bne.n	8758 <create_free_list+0x28>
	slab->free_list = NULL;
    873c:	2100      	movs	r1, #0
    873e:	6141      	str	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    8740:	e005      	b.n	874e <create_free_list+0x1e>
		*(char **)p = slab->free_list;
    8742:	6941      	ldr	r1, [r0, #20]
    8744:	6019      	str	r1, [r3, #0]
		slab->free_list = p;
    8746:	6143      	str	r3, [r0, #20]
		p += slab->block_size;
    8748:	68c1      	ldr	r1, [r0, #12]
    874a:	440b      	add	r3, r1
	for (j = 0U; j < slab->num_blocks; j++) {
    874c:	3201      	adds	r2, #1
    874e:	6881      	ldr	r1, [r0, #8]
    8750:	4291      	cmp	r1, r2
    8752:	d8f6      	bhi.n	8742 <create_free_list+0x12>
	return 0;
    8754:	2000      	movs	r0, #0
    8756:	4770      	bx	lr
		return -EINVAL;
    8758:	f06f 0015 	mvn.w	r0, #21
}
    875c:	4770      	bx	lr

0000875e <k_mem_slab_init>:
{
    875e:	b510      	push	{r4, lr}
    8760:	4604      	mov	r4, r0
	slab->num_blocks = num_blocks;
    8762:	6083      	str	r3, [r0, #8]
	slab->block_size = block_size;
    8764:	60c2      	str	r2, [r0, #12]
	slab->buffer = buffer;
    8766:	6101      	str	r1, [r0, #16]
	slab->num_used = 0U;
    8768:	2300      	movs	r3, #0
    876a:	6183      	str	r3, [r0, #24]
	rc = create_free_list(slab);
    876c:	f7ff ffe0 	bl	8730 <create_free_list>
	if (rc < 0) {
    8770:	2800      	cmp	r0, #0
    8772:	db01      	blt.n	8778 <k_mem_slab_init+0x1a>
	list->head = (sys_dnode_t *)list;
    8774:	6024      	str	r4, [r4, #0]
	list->tail = (sys_dnode_t *)list;
    8776:	6064      	str	r4, [r4, #4]
}
    8778:	bd10      	pop	{r4, pc}

0000877a <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    877a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    877c:	4604      	mov	r4, r0
    877e:	460d      	mov	r5, r1
	__asm__ volatile(
    8780:	f04f 0320 	mov.w	r3, #32
    8784:	f3ef 8611 	mrs	r6, BASEPRI
    8788:	f383 8812 	msr	BASEPRI_MAX, r3
    878c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
    8790:	6943      	ldr	r3, [r0, #20]
    8792:	b163      	cbz	r3, 87ae <k_mem_slab_free+0x34>
			z_ready_thread(pending_thread);
			z_reschedule(&slab->lock, key);
			return;
		}
	}
	**(char ***) mem = slab->free_list;
    8794:	682b      	ldr	r3, [r5, #0]
    8796:	6962      	ldr	r2, [r4, #20]
    8798:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
    879a:	682b      	ldr	r3, [r5, #0]
    879c:	6163      	str	r3, [r4, #20]
	slab->num_used--;
    879e:	69a3      	ldr	r3, [r4, #24]
    87a0:	3b01      	subs	r3, #1
    87a2:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    87a4:	f386 8811 	msr	BASEPRI, r6
    87a8:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
    87ac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    87ae:	f100 0708 	add.w	r7, r0, #8
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    87b2:	f000 f988 	bl	8ac6 <z_unpend_first_thread>
		if (pending_thread != NULL) {
    87b6:	2800      	cmp	r0, #0
    87b8:	d0ec      	beq.n	8794 <k_mem_slab_free+0x1a>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    87ba:	682a      	ldr	r2, [r5, #0]
    87bc:	2100      	movs	r1, #0
    87be:	f8c0 10ac 	str.w	r1, [r0, #172]	; 0xac
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    87c2:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
    87c4:	f000 f8bd 	bl	8942 <z_ready_thread>
			z_reschedule(&slab->lock, key);
    87c8:	4631      	mov	r1, r6
    87ca:	4638      	mov	r0, r7
    87cc:	f7fd fdb6 	bl	633c <z_reschedule>
			return;
    87d0:	e7ec      	b.n	87ac <k_mem_slab_free+0x32>

000087d2 <setup_thread_stack>:
{
    87d2:	b410      	push	{r4}
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    87d4:	3207      	adds	r2, #7
    87d6:	f022 0207 	bic.w	r2, r2, #7
    87da:	f102 0320 	add.w	r3, r2, #32

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
    87de:	f101 0420 	add.w	r4, r1, #32
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
    87e2:	f8c0 4098 	str.w	r4, [r0, #152]	; 0x98
	new_thread->stack_info.size = stack_buf_size;
    87e6:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
	new_thread->stack_info.delta = delta;
    87ea:	2200      	movs	r2, #0
    87ec:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
}
    87f0:	18c8      	adds	r0, r1, r3
    87f2:	bc10      	pop	{r4}
    87f4:	4770      	bx	lr

000087f6 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    87f6:	f3ef 8005 	mrs	r0, IPSR
}
    87fa:	3800      	subs	r0, #0
    87fc:	bf18      	it	ne
    87fe:	2001      	movne	r0, #1
    8800:	4770      	bx	lr

00008802 <k_thread_name_get>:
}
    8802:	3074      	adds	r0, #116	; 0x74
    8804:	4770      	bx	lr

00008806 <z_impl_k_thread_start>:
{
    8806:	b508      	push	{r3, lr}
	z_sched_start(thread);
    8808:	f7fd fec2 	bl	6590 <z_sched_start>
}
    880c:	bd08      	pop	{r3, pc}

0000880e <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    880e:	b410      	push	{r4}
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    8810:	2400      	movs	r4, #0
    8812:	6084      	str	r4, [r0, #8]
	thread_base->user_options = (uint8_t)options;
    8814:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    8816:	7342      	strb	r2, [r0, #13]

	thread_base->prio = priority;
    8818:	7381      	strb	r1, [r0, #14]

	thread_base->sched_locked = 0U;
    881a:	73c4      	strb	r4, [r0, #15]
	node->next = NULL;
    881c:	6184      	str	r4, [r0, #24]
	node->prev = NULL;
    881e:	61c4      	str	r4, [r0, #28]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    8820:	bc10      	pop	{r4}
    8822:	4770      	bx	lr

00008824 <z_impl_k_thread_create>:
{
    8824:	b5f0      	push	{r4, r5, r6, r7, lr}
    8826:	b087      	sub	sp, #28
    8828:	4604      	mov	r4, r0
    882a:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    882e:	2500      	movs	r5, #0
    8830:	9505      	str	r5, [sp, #20]
    8832:	9d10      	ldr	r5, [sp, #64]	; 0x40
    8834:	9504      	str	r5, [sp, #16]
    8836:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    8838:	9503      	str	r5, [sp, #12]
    883a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    883c:	9502      	str	r5, [sp, #8]
    883e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    8840:	9501      	str	r5, [sp, #4]
    8842:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    8844:	9500      	str	r5, [sp, #0]
    8846:	f7fd fb31 	bl	5eac <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    884a:	f1b7 3fff 	cmp.w	r7, #4294967295
    884e:	bf08      	it	eq
    8850:	f1b6 3fff 	cmpeq.w	r6, #4294967295
    8854:	d102      	bne.n	885c <z_impl_k_thread_create+0x38>
}
    8856:	4620      	mov	r0, r4
    8858:	b007      	add	sp, #28
    885a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		schedule_new_thread(new_thread, delay);
    885c:	4632      	mov	r2, r6
    885e:	463b      	mov	r3, r7
    8860:	4620      	mov	r0, r4
    8862:	f7fd fb11 	bl	5e88 <schedule_new_thread>
    8866:	e7f6      	b.n	8856 <z_impl_k_thread_create+0x32>

00008868 <z_pm_save_idle_exit>:
{
    8868:	b508      	push	{r3, lr}
	pm_system_resume();
    886a:	f7f9 fdb5 	bl	23d8 <pm_system_resume>
	sys_clock_idle_exit();
    886e:	f7ff fcaf 	bl	81d0 <sys_clock_idle_exit>
}
    8872:	bd08      	pop	{r3, pc}

00008874 <new_prio_for_inheritance>:
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
    8874:	4288      	cmp	r0, r1
    8876:	da00      	bge.n	887a <new_prio_for_inheritance+0x6>
    8878:	4601      	mov	r1, r0
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
    887a:	f111 0f7f 	cmn.w	r1, #127	; 0x7f
    887e:	db01      	blt.n	8884 <new_prio_for_inheritance+0x10>
    8880:	4608      	mov	r0, r1
    8882:	4770      	bx	lr
    8884:	f06f 007e 	mvn.w	r0, #126	; 0x7e
}
    8888:	4770      	bx	lr

0000888a <adjust_owner_prio>:
{
    888a:	b508      	push	{r3, lr}
	if (mutex->owner->base.prio != new_prio) {
    888c:	6880      	ldr	r0, [r0, #8]
    888e:	f990 300e 	ldrsb.w	r3, [r0, #14]
    8892:	428b      	cmp	r3, r1
    8894:	d101      	bne.n	889a <adjust_owner_prio+0x10>
	return false;
    8896:	2000      	movs	r0, #0
}
    8898:	bd08      	pop	{r3, pc}
		return z_set_prio(mutex->owner, new_prio);
    889a:	f7fd fec7 	bl	662c <z_set_prio>
    889e:	e7fb      	b.n	8898 <adjust_owner_prio+0xe>

000088a0 <thread_active_elsewhere>:
}
    88a0:	2000      	movs	r0, #0
    88a2:	4770      	bx	lr

000088a4 <pended_on_thread>:
}
    88a4:	6880      	ldr	r0, [r0, #8]
    88a6:	4770      	bx	lr

000088a8 <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    88a8:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
    88ac:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
    88b0:	4283      	cmp	r3, r0
    88b2:	d001      	beq.n	88b8 <z_sched_prio_cmp+0x10>
		return b2 - b1;
    88b4:	1ac0      	subs	r0, r0, r3
    88b6:	4770      	bx	lr
	return 0;
    88b8:	2000      	movs	r0, #0
}
    88ba:	4770      	bx	lr

000088bc <z_unpend_thread_no_timeout>:
{
    88bc:	b538      	push	{r3, r4, r5, lr}
    88be:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
    88c0:	2300      	movs	r3, #0
	__asm__ volatile(
    88c2:	f04f 0220 	mov.w	r2, #32
    88c6:	f3ef 8511 	mrs	r5, BASEPRI
    88ca:	f382 8812 	msr	BASEPRI_MAX, r2
    88ce:	f3bf 8f6f 	isb	sy
    88d2:	b98b      	cbnz	r3, 88f8 <z_unpend_thread_no_timeout+0x3c>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    88d4:	4620      	mov	r0, r4
    88d6:	f7ff ffe5 	bl	88a4 <pended_on_thread>
    88da:	4621      	mov	r1, r4
    88dc:	f000 f822 	bl	8924 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    88e0:	7b63      	ldrb	r3, [r4, #13]
    88e2:	f023 0302 	bic.w	r3, r3, #2
    88e6:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    88e8:	2300      	movs	r3, #0
    88ea:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
    88ec:	f385 8811 	msr	BASEPRI, r5
    88f0:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    88f4:	2301      	movs	r3, #1
    88f6:	e7ec      	b.n	88d2 <z_unpend_thread_no_timeout+0x16>
}
    88f8:	bd38      	pop	{r3, r4, r5, pc}

000088fa <z_reschedule_irqlock>:
{
    88fa:	b508      	push	{r3, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    88fc:	4603      	mov	r3, r0
    88fe:	b920      	cbnz	r0, 890a <z_reschedule_irqlock+0x10>
    8900:	f3ef 8205 	mrs	r2, IPSR
    8904:	b942      	cbnz	r2, 8918 <z_reschedule_irqlock+0x1e>
    8906:	2201      	movs	r2, #1
    8908:	e000      	b.n	890c <z_reschedule_irqlock+0x12>
    890a:	2200      	movs	r2, #0
	if (resched(key)) {
    890c:	b932      	cbnz	r2, 891c <z_reschedule_irqlock+0x22>
    890e:	f383 8811 	msr	BASEPRI, r3
    8912:	f3bf 8f6f 	isb	sy
}
    8916:	bd08      	pop	{r3, pc}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    8918:	2200      	movs	r2, #0
    891a:	e7f7      	b.n	890c <z_reschedule_irqlock+0x12>
	ret = arch_swap(key);
    891c:	4618      	mov	r0, r3
    891e:	f7f9 ff53 	bl	27c8 <arch_swap>
	return ret;
    8922:	e7f8      	b.n	8916 <z_reschedule_irqlock+0x1c>

00008924 <z_priq_dumb_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    8924:	684a      	ldr	r2, [r1, #4]
	sys_dnode_t *const next = node->next;
    8926:	680b      	ldr	r3, [r1, #0]

	prev->next = next;
    8928:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    892a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    892c:	2300      	movs	r3, #0
    892e:	600b      	str	r3, [r1, #0]
	node->prev = NULL;
    8930:	604b      	str	r3, [r1, #4]
}
    8932:	4770      	bx	lr

00008934 <z_priq_dumb_best>:
{
    8934:	4603      	mov	r3, r0
	return list->head == list;
    8936:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    8938:	4283      	cmp	r3, r0
    893a:	d000      	beq.n	893e <z_priq_dumb_best+0xa>
}
    893c:	4770      	bx	lr
	struct k_thread *thread = NULL;
    893e:	2000      	movs	r0, #0
	return thread;
    8940:	e7fc      	b.n	893c <z_priq_dumb_best+0x8>

00008942 <z_ready_thread>:
{
    8942:	b538      	push	{r3, r4, r5, lr}
    8944:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
    8946:	2300      	movs	r3, #0
	__asm__ volatile(
    8948:	f04f 0220 	mov.w	r2, #32
    894c:	f3ef 8511 	mrs	r5, BASEPRI
    8950:	f382 8812 	msr	BASEPRI_MAX, r2
    8954:	f3bf 8f6f 	isb	sy
    8958:	e007      	b.n	896a <z_ready_thread+0x28>
			ready_thread(thread);
    895a:	4620      	mov	r0, r4
    895c:	f7fd fdd8 	bl	6510 <ready_thread>
	__asm__ volatile(
    8960:	f385 8811 	msr	BASEPRI, r5
    8964:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    8968:	2301      	movs	r3, #1
    896a:	b92b      	cbnz	r3, 8978 <z_ready_thread+0x36>
		if (!thread_active_elsewhere(thread)) {
    896c:	4620      	mov	r0, r4
    896e:	f7ff ff97 	bl	88a0 <thread_active_elsewhere>
    8972:	2800      	cmp	r0, #0
    8974:	d1f4      	bne.n	8960 <z_ready_thread+0x1e>
    8976:	e7f0      	b.n	895a <z_ready_thread+0x18>
}
    8978:	bd38      	pop	{r3, r4, r5, pc}

0000897a <z_thread_timeout>:
{
    897a:	b570      	push	{r4, r5, r6, lr}
    897c:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
    897e:	f1a0 0518 	sub.w	r5, r0, #24
	LOCKED(&sched_spinlock) {
    8982:	2300      	movs	r3, #0
	__asm__ volatile(
    8984:	f04f 0220 	mov.w	r2, #32
    8988:	f3ef 8611 	mrs	r6, BASEPRI
    898c:	f382 8812 	msr	BASEPRI_MAX, r2
    8990:	f3bf 8f6f 	isb	sy
    8994:	e019      	b.n	89ca <z_thread_timeout+0x50>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    8996:	4628      	mov	r0, r5
    8998:	f7ff ff84 	bl	88a4 <pended_on_thread>
    899c:	4629      	mov	r1, r5
    899e:	f7ff ffc1 	bl	8924 <z_priq_dumb_remove>
    89a2:	7b6b      	ldrb	r3, [r5, #13]
    89a4:	f023 0302 	bic.w	r3, r3, #2
    89a8:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
    89aa:	2300      	movs	r3, #0
    89ac:	60ab      	str	r3, [r5, #8]
	thread->base.thread_state &= ~_THREAD_PRESTART;
    89ae:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    89b2:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
    89b6:	f804 3c0b 	strb.w	r3, [r4, #-11]
			ready_thread(thread);
    89ba:	4628      	mov	r0, r5
    89bc:	f7fd fda8 	bl	6510 <ready_thread>
	__asm__ volatile(
    89c0:	f386 8811 	msr	BASEPRI, r6
    89c4:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    89c8:	2301      	movs	r3, #1
    89ca:	b94b      	cbnz	r3, 89e0 <z_thread_timeout+0x66>
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    89cc:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
		if (!killed) {
    89d0:	f013 0f28 	tst.w	r3, #40	; 0x28
    89d4:	d1f4      	bne.n	89c0 <z_thread_timeout+0x46>
			if (thread->base.pended_on != NULL) {
    89d6:	f854 3c10 	ldr.w	r3, [r4, #-16]
    89da:	2b00      	cmp	r3, #0
    89dc:	d1db      	bne.n	8996 <z_thread_timeout+0x1c>
    89de:	e7e6      	b.n	89ae <z_thread_timeout+0x34>
}
    89e0:	bd70      	pop	{r4, r5, r6, pc}

000089e2 <add_to_waitq_locked>:
{
    89e2:	b570      	push	{r4, r5, r6, lr}
    89e4:	4605      	mov	r5, r0
    89e6:	460e      	mov	r6, r1
	unready_thread(thread);
    89e8:	f7fd fdf0 	bl	65cc <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    89ec:	7b6b      	ldrb	r3, [r5, #13]
    89ee:	f043 0302 	orr.w	r3, r3, #2
    89f2:	736b      	strb	r3, [r5, #13]
	if (wait_q != NULL) {
    89f4:	b1b6      	cbz	r6, 8a24 <add_to_waitq_locked+0x42>
		thread->base.pended_on = wait_q;
    89f6:	60ae      	str	r6, [r5, #8]
	return list->head == list;
    89f8:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    89fa:	42a6      	cmp	r6, r4
    89fc:	d019      	beq.n	8a32 <add_to_waitq_locked+0x50>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    89fe:	b164      	cbz	r4, 8a1a <add_to_waitq_locked+0x38>
		if (z_sched_prio_cmp(thread, t) > 0) {
    8a00:	4621      	mov	r1, r4
    8a02:	4628      	mov	r0, r5
    8a04:	f7ff ff50 	bl	88a8 <z_sched_prio_cmp>
    8a08:	2800      	cmp	r0, #0
    8a0a:	dc0c      	bgt.n	8a26 <add_to_waitq_locked+0x44>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    8a0c:	b12c      	cbz	r4, 8a1a <add_to_waitq_locked+0x38>
	return (node == list->tail) ? NULL : node->next;
    8a0e:	6873      	ldr	r3, [r6, #4]
    8a10:	429c      	cmp	r4, r3
    8a12:	d002      	beq.n	8a1a <add_to_waitq_locked+0x38>
    8a14:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8a16:	2c00      	cmp	r4, #0
    8a18:	d1f1      	bne.n	89fe <add_to_waitq_locked+0x1c>
	sys_dnode_t *const tail = list->tail;
    8a1a:	6873      	ldr	r3, [r6, #4]
	node->next = list;
    8a1c:	602e      	str	r6, [r5, #0]
	node->prev = tail;
    8a1e:	606b      	str	r3, [r5, #4]
	tail->next = node;
    8a20:	601d      	str	r5, [r3, #0]
	list->tail = node;
    8a22:	6075      	str	r5, [r6, #4]
}
    8a24:	bd70      	pop	{r4, r5, r6, pc}
	sys_dnode_t *const prev = successor->prev;
    8a26:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    8a28:	606b      	str	r3, [r5, #4]
	node->next = successor;
    8a2a:	602c      	str	r4, [r5, #0]
	prev->next = node;
    8a2c:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    8a2e:	6065      	str	r5, [r4, #4]
}
    8a30:	e7f8      	b.n	8a24 <add_to_waitq_locked+0x42>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    8a32:	2400      	movs	r4, #0
    8a34:	e7e3      	b.n	89fe <add_to_waitq_locked+0x1c>

00008a36 <pend>:
{
    8a36:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    8a3a:	4605      	mov	r5, r0
    8a3c:	460f      	mov	r7, r1
    8a3e:	4691      	mov	r9, r2
    8a40:	4698      	mov	r8, r3
	LOCKED(&sched_spinlock) {
    8a42:	2400      	movs	r4, #0
	__asm__ volatile(
    8a44:	f04f 0320 	mov.w	r3, #32
    8a48:	f3ef 8611 	mrs	r6, BASEPRI
    8a4c:	f383 8812 	msr	BASEPRI_MAX, r3
    8a50:	f3bf 8f6f 	isb	sy
    8a54:	b94c      	cbnz	r4, 8a6a <pend+0x34>
		add_to_waitq_locked(thread, wait_q);
    8a56:	4639      	mov	r1, r7
    8a58:	4628      	mov	r0, r5
    8a5a:	f7ff ffc2 	bl	89e2 <add_to_waitq_locked>
	__asm__ volatile(
    8a5e:	f386 8811 	msr	BASEPRI, r6
    8a62:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    8a66:	2401      	movs	r4, #1
    8a68:	e7f4      	b.n	8a54 <pend+0x1e>
	add_thread_timeout(thread, timeout);
    8a6a:	464a      	mov	r2, r9
    8a6c:	4643      	mov	r3, r8
    8a6e:	4628      	mov	r0, r5
    8a70:	f7fd fc02 	bl	6278 <add_thread_timeout>
}
    8a74:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00008a78 <z_unpend1_no_timeout>:
{
    8a78:	b570      	push	{r4, r5, r6, lr}
    8a7a:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
    8a7c:	2300      	movs	r3, #0
	__asm__ volatile(
    8a7e:	f04f 0220 	mov.w	r2, #32
    8a82:	f3ef 8511 	mrs	r5, BASEPRI
    8a86:	f382 8812 	msr	BASEPRI_MAX, r2
    8a8a:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = NULL;
    8a8e:	461c      	mov	r4, r3
    8a90:	e00f      	b.n	8ab2 <z_unpend1_no_timeout+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    8a92:	f7ff ff07 	bl	88a4 <pended_on_thread>
    8a96:	4621      	mov	r1, r4
    8a98:	f7ff ff44 	bl	8924 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    8a9c:	7b63      	ldrb	r3, [r4, #13]
    8a9e:	f023 0302 	bic.w	r3, r3, #2
    8aa2:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    8aa4:	2300      	movs	r3, #0
    8aa6:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
    8aa8:	f385 8811 	msr	BASEPRI, r5
    8aac:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    8ab0:	2301      	movs	r3, #1
    8ab2:	b933      	cbnz	r3, 8ac2 <z_unpend1_no_timeout+0x4a>
		thread = _priq_wait_best(&wait_q->waitq);
    8ab4:	4630      	mov	r0, r6
    8ab6:	f7ff ff3d 	bl	8934 <z_priq_dumb_best>
		if (thread != NULL) {
    8aba:	4604      	mov	r4, r0
    8abc:	2800      	cmp	r0, #0
    8abe:	d1e8      	bne.n	8a92 <z_unpend1_no_timeout+0x1a>
    8ac0:	e7f2      	b.n	8aa8 <z_unpend1_no_timeout+0x30>
}
    8ac2:	4620      	mov	r0, r4
    8ac4:	bd70      	pop	{r4, r5, r6, pc}

00008ac6 <z_unpend_first_thread>:
{
    8ac6:	b570      	push	{r4, r5, r6, lr}
    8ac8:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
    8aca:	2300      	movs	r3, #0
	__asm__ volatile(
    8acc:	f04f 0220 	mov.w	r2, #32
    8ad0:	f3ef 8511 	mrs	r5, BASEPRI
    8ad4:	f382 8812 	msr	BASEPRI_MAX, r2
    8ad8:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = NULL;
    8adc:	461c      	mov	r4, r3
    8ade:	e013      	b.n	8b08 <z_unpend_first_thread+0x42>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    8ae0:	f7ff fee0 	bl	88a4 <pended_on_thread>
    8ae4:	4621      	mov	r1, r4
    8ae6:	f7ff ff1d 	bl	8924 <z_priq_dumb_remove>
    8aea:	7b63      	ldrb	r3, [r4, #13]
    8aec:	f023 0302 	bic.w	r3, r3, #2
    8af0:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    8af2:	2300      	movs	r3, #0
    8af4:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
    8af6:	f104 0018 	add.w	r0, r4, #24
    8afa:	f000 f82a 	bl	8b52 <z_abort_timeout>
	__asm__ volatile(
    8afe:	f385 8811 	msr	BASEPRI, r5
    8b02:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    8b06:	2301      	movs	r3, #1
    8b08:	b933      	cbnz	r3, 8b18 <z_unpend_first_thread+0x52>
		thread = _priq_wait_best(&wait_q->waitq);
    8b0a:	4630      	mov	r0, r6
    8b0c:	f7ff ff12 	bl	8934 <z_priq_dumb_best>
		if (thread != NULL) {
    8b10:	4604      	mov	r4, r0
    8b12:	2800      	cmp	r0, #0
    8b14:	d1e4      	bne.n	8ae0 <z_unpend_first_thread+0x1a>
    8b16:	e7f2      	b.n	8afe <z_unpend_first_thread+0x38>
}
    8b18:	4620      	mov	r0, r4
    8b1a:	bd70      	pop	{r4, r5, r6, pc}

00008b1c <init_ready_q>:
	sys_dlist_init(&rq->runq);
    8b1c:	1d03      	adds	r3, r0, #4
	list->head = (sys_dnode_t *)list;
    8b1e:	6043      	str	r3, [r0, #4]
	list->tail = (sys_dnode_t *)list;
    8b20:	6083      	str	r3, [r0, #8]
}
    8b22:	4770      	bx	lr

00008b24 <remove_timeout>:
{
    8b24:	b538      	push	{r3, r4, r5, lr}
    8b26:	4604      	mov	r4, r0
	if (next(t) != NULL) {
    8b28:	f7fd ffb4 	bl	6a94 <next>
    8b2c:	b148      	cbz	r0, 8b42 <remove_timeout+0x1e>
    8b2e:	4602      	mov	r2, r0
		next(t)->dticks += t->dticks;
    8b30:	6920      	ldr	r0, [r4, #16]
    8b32:	6965      	ldr	r5, [r4, #20]
    8b34:	6913      	ldr	r3, [r2, #16]
    8b36:	6951      	ldr	r1, [r2, #20]
    8b38:	181b      	adds	r3, r3, r0
    8b3a:	eb45 0101 	adc.w	r1, r5, r1
    8b3e:	6113      	str	r3, [r2, #16]
    8b40:	6151      	str	r1, [r2, #20]
	sys_dnode_t *const prev = node->prev;
    8b42:	6862      	ldr	r2, [r4, #4]
	sys_dnode_t *const next = node->next;
    8b44:	6823      	ldr	r3, [r4, #0]
	prev->next = next;
    8b46:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    8b48:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    8b4a:	2300      	movs	r3, #0
    8b4c:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
    8b4e:	6063      	str	r3, [r4, #4]
}
    8b50:	bd38      	pop	{r3, r4, r5, pc}

00008b52 <z_abort_timeout>:
{
    8b52:	b570      	push	{r4, r5, r6, lr}
    8b54:	4604      	mov	r4, r0
	LOCKED(&timeout_lock) {
    8b56:	2300      	movs	r3, #0
	__asm__ volatile(
    8b58:	f04f 0220 	mov.w	r2, #32
    8b5c:	f3ef 8611 	mrs	r6, BASEPRI
    8b60:	f382 8812 	msr	BASEPRI_MAX, r2
    8b64:	f3bf 8f6f 	isb	sy
	int ret = -EINVAL;
    8b68:	f06f 0015 	mvn.w	r0, #21
    8b6c:	e008      	b.n	8b80 <z_abort_timeout+0x2e>
			remove_timeout(to);
    8b6e:	4620      	mov	r0, r4
    8b70:	f7ff ffd8 	bl	8b24 <remove_timeout>
			ret = 0;
    8b74:	4628      	mov	r0, r5
	__asm__ volatile(
    8b76:	f386 8811 	msr	BASEPRI, r6
    8b7a:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    8b7e:	2301      	movs	r3, #1
    8b80:	461d      	mov	r5, r3
    8b82:	b91b      	cbnz	r3, 8b8c <z_abort_timeout+0x3a>
	return node->next != NULL;
    8b84:	6823      	ldr	r3, [r4, #0]
		if (sys_dnode_is_linked(&to->node)) {
    8b86:	2b00      	cmp	r3, #0
    8b88:	d1f1      	bne.n	8b6e <z_abort_timeout+0x1c>
    8b8a:	e7f4      	b.n	8b76 <z_abort_timeout+0x24>
}
    8b8c:	bd70      	pop	{r4, r5, r6, pc}

00008b8e <z_get_next_timeout_expiry>:
{
    8b8e:	b510      	push	{r4, lr}
	LOCKED(&timeout_lock) {
    8b90:	2300      	movs	r3, #0
	__asm__ volatile(
    8b92:	f04f 0220 	mov.w	r2, #32
    8b96:	f3ef 8411 	mrs	r4, BASEPRI
    8b9a:	f382 8812 	msr	BASEPRI_MAX, r2
    8b9e:	f3bf 8f6f 	isb	sy
	int32_t ret = (int32_t) K_TICKS_FOREVER;
    8ba2:	f04f 30ff 	mov.w	r0, #4294967295
	LOCKED(&timeout_lock) {
    8ba6:	b93b      	cbnz	r3, 8bb8 <z_get_next_timeout_expiry+0x2a>
		ret = next_timeout();
    8ba8:	f7fd ff8c 	bl	6ac4 <next_timeout>
	__asm__ volatile(
    8bac:	f384 8811 	msr	BASEPRI, r4
    8bb0:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    8bb4:	2301      	movs	r3, #1
    8bb6:	e7f6      	b.n	8ba6 <z_get_next_timeout_expiry+0x18>
}
    8bb8:	bd10      	pop	{r4, pc}

00008bba <z_set_timeout_expiry>:
{
    8bba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8bbc:	4606      	mov	r6, r0
    8bbe:	460f      	mov	r7, r1
	LOCKED(&timeout_lock) {
    8bc0:	2300      	movs	r3, #0
	__asm__ volatile(
    8bc2:	f04f 0220 	mov.w	r2, #32
    8bc6:	f3ef 8511 	mrs	r5, BASEPRI
    8bca:	f382 8812 	msr	BASEPRI_MAX, r2
    8bce:	f3bf 8f6f 	isb	sy
    8bd2:	e00a      	b.n	8bea <z_set_timeout_expiry+0x30>
			      || (ticks <= next_to);
    8bd4:	2401      	movs	r4, #1
		bool sooner = (next_to == K_TICKS_FOREVER)
    8bd6:	f004 0401 	and.w	r4, r4, #1
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    8bda:	2801      	cmp	r0, #1
    8bdc:	dd00      	ble.n	8be0 <z_set_timeout_expiry+0x26>
    8bde:	b97c      	cbnz	r4, 8c00 <z_set_timeout_expiry+0x46>
	__asm__ volatile(
    8be0:	f385 8811 	msr	BASEPRI, r5
    8be4:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    8be8:	2301      	movs	r3, #1
    8bea:	461c      	mov	r4, r3
    8bec:	b97b      	cbnz	r3, 8c0e <z_set_timeout_expiry+0x54>
		int next_to = next_timeout();
    8bee:	f7fd ff69 	bl	6ac4 <next_timeout>
			      || (ticks <= next_to);
    8bf2:	f1b0 3fff 	cmp.w	r0, #4294967295
    8bf6:	d0ed      	beq.n	8bd4 <z_set_timeout_expiry+0x1a>
    8bf8:	42b0      	cmp	r0, r6
    8bfa:	dbec      	blt.n	8bd6 <z_set_timeout_expiry+0x1c>
    8bfc:	2401      	movs	r4, #1
    8bfe:	e7ea      	b.n	8bd6 <z_set_timeout_expiry+0x1c>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    8c00:	4639      	mov	r1, r7
    8c02:	42b0      	cmp	r0, r6
    8c04:	bfa8      	it	ge
    8c06:	4630      	movge	r0, r6
    8c08:	f7fb fd24 	bl	4654 <sys_clock_set_timeout>
    8c0c:	e7e8      	b.n	8be0 <z_set_timeout_expiry+0x26>
}
    8c0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00008c10 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    8c10:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    8c12:	f7fe f889 	bl	6d28 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    8c16:	bd08      	pop	{r3, pc}

00008c18 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    8c18:	b900      	cbnz	r0, 8c1c <z_impl_k_busy_wait+0x4>
    8c1a:	4770      	bx	lr
{
    8c1c:	b508      	push	{r3, lr}
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    8c1e:	f7fa fc2f 	bl	3480 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    8c22:	bd08      	pop	{r3, pc}

00008c24 <k_timer_init>:
	timer->expiry_fn = expiry_fn;
    8c24:	6201      	str	r1, [r0, #32]
	timer->stop_fn = stop_fn;
    8c26:	6242      	str	r2, [r0, #36]	; 0x24
	timer->status = 0U;
    8c28:	2300      	movs	r3, #0
    8c2a:	6303      	str	r3, [r0, #48]	; 0x30
	sys_dlist_init(&w->waitq);
    8c2c:	f100 0218 	add.w	r2, r0, #24
	list->head = (sys_dnode_t *)list;
    8c30:	6182      	str	r2, [r0, #24]
	list->tail = (sys_dnode_t *)list;
    8c32:	61c2      	str	r2, [r0, #28]
	node->next = NULL;
    8c34:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
    8c36:	6043      	str	r3, [r0, #4]
	timer->user_data = NULL;
    8c38:	6343      	str	r3, [r0, #52]	; 0x34
}
    8c3a:	4770      	bx	lr

00008c3c <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    8c3c:	b510      	push	{r4, lr}
    8c3e:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
    8c40:	f7ff ff87 	bl	8b52 <z_abort_timeout>

	if (inactive) {
    8c44:	b9a0      	cbnz	r0, 8c70 <z_impl_k_timer_stop+0x34>
		return;
	}

	if (timer->stop_fn != NULL) {
    8c46:	6a63      	ldr	r3, [r4, #36]	; 0x24
    8c48:	b10b      	cbz	r3, 8c4e <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
    8c4a:	4620      	mov	r0, r4
    8c4c:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
    8c4e:	f104 0018 	add.w	r0, r4, #24
    8c52:	f7ff ff11 	bl	8a78 <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
    8c56:	b158      	cbz	r0, 8c70 <z_impl_k_timer_stop+0x34>
			z_ready_thread(pending_thread);
    8c58:	f7ff fe73 	bl	8942 <z_ready_thread>
	__asm__ volatile(
    8c5c:	f04f 0320 	mov.w	r3, #32
    8c60:	f3ef 8011 	mrs	r0, BASEPRI
    8c64:	f383 8812 	msr	BASEPRI_MAX, r3
    8c68:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    8c6c:	f7ff fe45 	bl	88fa <z_reschedule_irqlock>
			z_reschedule_unlocked();
		}
	}
}
    8c70:	bd10      	pop	{r4, pc}

00008c72 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    8c72:	4770      	bx	lr

00008c74 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
    8c74:	f7fb be50 	b.w	4918 <SystemInit>
